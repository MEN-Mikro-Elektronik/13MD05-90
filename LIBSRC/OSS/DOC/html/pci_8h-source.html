<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - OSS module for Linux/RTAI - pci.h Source File</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;"></a>
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">OSS module for Linux/RTAI &nbsp; 2.7</h1>
	<h3>pci.h Source File</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>pci.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  $Id: pci_8h-source.html,v 1.2 2007/12/10 10:36:13 ts Exp $</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  The PCI Library</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Copyright (c) 1997--2002 Martin Mares &lt;mj@ucw.cz&gt;</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *  Can be freely distributed and used under the terms of the GNU GPL.</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#ifndef _PCI_LIB_H</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define _PCI_LIB_H</span>
00013 <span class="preprocessor"></span>
00014 <span class="preprocessor">#include "config.h"</span>
00015 <span class="preprocessor">#include "header.h"</span>
00016 
00017 <span class="comment">/*</span>
00018 <span class="comment"> *  Types</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="preprocessor">#ifdef OS_LINUX</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/types.h&gt;</span>
00023 
00024 <span class="keyword">typedef</span> __u8 byte;
00025 <span class="keyword">typedef</span> __u8 u8;
00026 <span class="keyword">typedef</span> __u16 word;
00027 <span class="keyword">typedef</span> __u16 u16;
00028 <span class="keyword">typedef</span> __u32 u32;
00029 <span class="preprocessor">#endif</span>
00030 <span class="preprocessor"></span>
00031 <span class="preprocessor">#ifdef OS_FREEBSD</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00033 
00034 <span class="keyword">typedef</span> u_int8_t byte;
00035 <span class="keyword">typedef</span> u_int8_t u8;
00036 <span class="keyword">typedef</span> u_int16_t word;
00037 <span class="keyword">typedef</span> u_int16_t u16;
00038 <span class="keyword">typedef</span> u_int32_t u32;
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span>
00041 <span class="preprocessor">#ifdef OS_NETBSD</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00043 
00044 <span class="keyword">typedef</span> u_int8_t byte;
00045 <span class="keyword">typedef</span> u_int8_t u8;
00046 <span class="keyword">typedef</span> u_int16_t word;
00047 <span class="keyword">typedef</span> u_int16_t u16;
00048 <span class="keyword">typedef</span> u_int32_t u32;
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor"></span>
00051 <span class="preprocessor">#ifdef OS_AIX</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00053 
00054 <span class="keyword">typedef</span> u_int8_t byte;
00055 <span class="keyword">typedef</span> u_int8_t u8;
00056 <span class="keyword">typedef</span> u_int16_t word;
00057 <span class="keyword">typedef</span> u_int16_t u16;
00058 <span class="keyword">typedef</span> u_int32_t u32;
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor"></span>
00061 <span class="preprocessor">#ifdef HAVE_LONG_ADDRESS</span>
00062 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> pciaddr_t;
00063 <span class="preprocessor">#else</span>
00064 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pciaddr_t;
00065 <span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span>
00067 <span class="comment">/*</span>
00068 <span class="comment"> *  PCI Access Structure</span>
00069 <span class="comment"> */</span>
00070 
00071 <span class="keyword">struct </span>pci_methods;
00072 <span class="keyword">struct </span>nl_entry;
00073 
00074 <span class="keyword">enum</span> pci_access_type {
00075   <span class="comment">/* Known access methods, remember to update access.c as well */</span>
00076   PCI_ACCESS_AUTO,          <span class="comment">/* Autodetection (params: none) */</span>
00077   PCI_ACCESS_PROC_BUS_PCI,      <span class="comment">/* Linux /proc/bus/pci (params: path) */</span>
00078   PCI_ACCESS_I386_TYPE1,        <span class="comment">/* i386 ports, type 1 (params: none) */</span>
00079   PCI_ACCESS_I386_TYPE2,        <span class="comment">/* i386 ports, type 2 (params: none) */</span>
00080   PCI_ACCESS_FBSD_DEVICE,       <span class="comment">/* FreeBSD /dev/pci (params: path) */</span>
00081   PCI_ACCESS_AIX_DEVICE,        <span class="comment">/* /dev/pci0, /dev/bus0, etc. */</span>
00082   PCI_ACCESS_NBSD_LIBPCI,       <span class="comment">/* NetBSD libpci */</span>
00083   PCI_ACCESS_DUMP,          <span class="comment">/* Dump file (params: filename) */</span>
00084   PCI_ACCESS_MAX
00085 };
00086 
00087 <span class="keyword">struct </span>pci_access {
00088   <span class="comment">/* Options you can change: */</span>
00089   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> method;          <span class="comment">/* Access method */</span>
00090   <span class="keywordtype">char</span> *method_params[PCI_ACCESS_MAX];  <span class="comment">/* Parameters for the methods */</span>
00091   <span class="keywordtype">int</span> writeable;            <span class="comment">/* Open in read/write mode */</span>
00092   <span class="keywordtype">int</span> buscentric;           <span class="comment">/* Bus-centric view of the world */</span>
00093   <span class="keywordtype">char</span> *id_file_name;           <span class="comment">/* Name of ID list file */</span>
00094   <span class="keywordtype">int</span> numeric_ids;          <span class="comment">/* Don't resolve device IDs to names */</span>
00095   <span class="keywordtype">int</span> debugging;            <span class="comment">/* Turn on debugging messages */</span>
00096 
00097   <span class="comment">/* Functions you can override: */</span>
00098   void (*error)(<span class="keywordtype">char</span> *msg, ...);    <span class="comment">/* Write error message and quit */</span>
00099   void (*warning)(<span class="keywordtype">char</span> *msg, ...);  <span class="comment">/* Write a warning message */</span>
00100   void (*debug)(<span class="keywordtype">char</span> *msg, ...);    <span class="comment">/* Write a debugging message */</span>
00101 
00102   <span class="keyword">struct </span>pci_dev *devices;      <span class="comment">/* Devices found on this bus */</span>
00103 
00104   <span class="comment">/* Fields used internally: */</span>
00105   <span class="keyword">struct </span>pci_methods *methods;
00106   <span class="keywordtype">char</span> *nl_list;            <span class="comment">/* Name list cache */</span>
00107   <span class="keyword">struct </span>nl_entry **nl_hash;
00108   <span class="keywordtype">int</span> fd;               <span class="comment">/* proc: fd */</span>
00109   <span class="keywordtype">int</span> fd_rw;                <span class="comment">/* proc: fd opened read-write */</span>
00110   <span class="keyword">struct </span>pci_dev *cached_dev;       <span class="comment">/* proc: device the fd is for */</span>
00111   <span class="keywordtype">int</span> fd_pos;               <span class="comment">/* proc: current position */</span>
00112 };
00113 
00114 <span class="comment">/* Initialize PCI access */</span>
00115 <span class="keyword">struct </span>pci_access *pci_alloc(void);
00116 <span class="keywordtype">void</span> pci_init(<span class="keyword">struct</span> pci_access *);
00117 <span class="keywordtype">void</span> pci_cleanup(<span class="keyword">struct</span> pci_access *);
00118 
00119 <span class="comment">/* Scanning of devices */</span>
00120 <span class="keywordtype">void</span> pci_scan_bus(<span class="keyword">struct</span> pci_access *acc);
00121 <span class="keyword">struct </span>pci_dev *pci_get_dev(struct pci_access *acc, int bus, int dev, int func); <span class="comment">/* Raw access to specified device */</span>
00122 <span class="keywordtype">void</span> pci_free_dev(<span class="keyword">struct</span> pci_dev *);
00123 
00124 <span class="comment">/*</span>
00125 <span class="comment"> *  Devices</span>
00126 <span class="comment"> */</span>
00127 
00128 <span class="keyword">struct </span>pci_dev {
00129   <span class="keyword">struct </span>pci_dev *next;         <span class="comment">/* Next device in the chain */</span>
00130   word bus;             <span class="comment">/* Higher byte can select host bridges */</span>
00131   byte dev, func;           <span class="comment">/* Device and function */</span>
00132 
00133   <span class="comment">/* These fields are set by pci_fill_info() */</span>
00134   <span class="keywordtype">int</span> known_fields;         <span class="comment">/* Set of info fields already known */</span>
00135   word vendor_id, device_id;        <span class="comment">/* Identity of the device */</span>
00136   <span class="keywordtype">int</span> irq;              <span class="comment">/* IRQ number */</span>
00137   pciaddr_t base_addr[6];       <span class="comment">/* Base addresses */</span>
00138   pciaddr_t size[6];            <span class="comment">/* Region sizes */</span>
00139   pciaddr_t rom_base_addr;      <span class="comment">/* Expansion ROM base address */</span>
00140   pciaddr_t rom_size;           <span class="comment">/* Expansion ROM size */</span>
00141 
00142   <span class="comment">/* Fields used internally: */</span>
00143   <span class="keyword">struct </span>pci_access *access;
00144   <span class="keyword">struct </span>pci_methods *methods;
00145   byte *cache;              <span class="comment">/* Cached information */</span>
00146   <span class="keywordtype">int</span> cache_len;
00147   <span class="keywordtype">int</span> hdrtype;              <span class="comment">/* Direct methods: header type */</span>
00148   <span class="keywordtype">void</span> *aux;                <span class="comment">/* Auxillary data */</span>
00149 };
00150 
00151 <span class="preprocessor">#define PCI_ADDR_IO_MASK (~(pciaddr_t) 0x3)</span>
00152 <span class="preprocessor"></span><span class="preprocessor">#define PCI_ADDR_MEM_MASK (~(pciaddr_t) 0xf)</span>
00153 <span class="preprocessor"></span>
00154 byte pci_read_byte(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos); <span class="comment">/* Access to configuration space */</span>
00155 word pci_read_word(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos);
00156 u32  pci_read_long(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos);
00157 <span class="keywordtype">int</span> pci_read_block(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos, byte *buf, <span class="keywordtype">int</span> len);
00158 <span class="keywordtype">int</span> pci_write_byte(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos, byte data);
00159 <span class="keywordtype">int</span> pci_write_word(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos, word data);
00160 <span class="keywordtype">int</span> pci_write_long(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos, u32 data);
00161 <span class="keywordtype">int</span> pci_write_block(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> pos, byte *buf, <span class="keywordtype">int</span> len);
00162 
00163 <span class="keywordtype">int</span> pci_fill_info(<span class="keyword">struct</span> pci_dev *, <span class="keywordtype">int</span> flags); <span class="comment">/* Fill in device information */</span>
00164 
00165 <span class="preprocessor">#define PCI_FILL_IDENT      1</span>
00166 <span class="preprocessor"></span><span class="preprocessor">#define PCI_FILL_IRQ        2</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#define PCI_FILL_BASES      4</span>
00168 <span class="preprocessor"></span><span class="preprocessor">#define PCI_FILL_ROM_BASE   8</span>
00169 <span class="preprocessor"></span><span class="preprocessor">#define PCI_FILL_SIZES      16</span>
00170 <span class="preprocessor"></span><span class="preprocessor">#define PCI_FILL_RESCAN     0x10000</span>
00171 <span class="preprocessor"></span>
00172 <span class="keywordtype">void</span> pci_setup_cache(<span class="keyword">struct</span> pci_dev *, byte *cache, <span class="keywordtype">int</span> len);
00173 
00174 <span class="comment">/*</span>
00175 <span class="comment"> *  Filters</span>
00176 <span class="comment"> */</span>
00177 
00178 <span class="keyword">struct </span>pci_filter {
00179   <span class="keywordtype">int</span> bus, slot, func;          <span class="comment">/* -1 = ANY */</span>
00180   <span class="keywordtype">int</span> vendor, device;
00181 };
00182 
00183 <span class="keywordtype">void</span> pci_filter_init(<span class="keyword">struct</span> pci_access *, <span class="keyword">struct</span> pci_filter *);
00184 <span class="keywordtype">char</span> *pci_filter_parse_slot(<span class="keyword">struct</span> pci_filter *, <span class="keywordtype">char</span> *);
00185 <span class="keywordtype">char</span> *pci_filter_parse_id(<span class="keyword">struct</span> pci_filter *, <span class="keywordtype">char</span> *);
00186 <span class="keywordtype">int</span> pci_filter_match(<span class="keyword">struct</span> pci_filter *, <span class="keyword">struct</span> pci_dev *);
00187 
00188 <span class="comment">/*</span>
00189 <span class="comment"> *  Device names</span>
00190 <span class="comment"> */</span>
00191 
00192 <span class="keywordtype">char</span> *pci_lookup_name(<span class="keyword">struct</span> pci_access *a, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> flags, u32 arg1, u32 arg2, u32 arg3, u32 arg4);
00193 <span class="keywordtype">void</span> pci_free_name_list(<span class="keyword">struct</span> pci_access *a);
00194 
00195 <span class="preprocessor">#define PCI_LOOKUP_VENDOR 1</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#define PCI_LOOKUP_DEVICE 2</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#define PCI_LOOKUP_CLASS 4</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define PCI_LOOKUP_SUBSYSTEM 8</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define PCI_LOOKUP_PROGIF 16</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define PCI_LOOKUP_NUMERIC 0x10000</span>
00201 <span class="preprocessor"></span>
00202 <span class="preprocessor">#endif</span>
</pre></div>
	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for OSS module for Linux/RTAI using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2007 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>
