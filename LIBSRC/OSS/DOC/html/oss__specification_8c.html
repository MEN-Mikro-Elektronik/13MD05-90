<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - OSS module for Linux/RTAI - oss_specification.c File Reference</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;"></a>
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">OSS module for Linux/RTAI &nbsp; 2.15</h1>
	<h3>oss_specification.c File Reference</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>oss_specification.c File Reference</h1>MEN OSS (Operating System Services) module specification.  
<a href="#_details">More...</a>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a0">OSS_SWAP16</a>(word)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to swap bytes in 16-bit word. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a1">OSS_SWAP32</a>(dword)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to swap bytes in 32-bit word. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a2">OSS_SWAP64</a>(qword)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to swap bytes in 64-bit word. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a3" doxytag="oss_specification.c::OSS_Ident"></a>
char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a3">OSS_Ident</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the identification string (Version info) of the OSS module. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a4">OSS_DbgLevelSet</a> (OSS_HANDLE *oss, u_int32 newLevel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set debug level of OSS instance. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a5">OSS_DbgLevelGet</a> (OSS_HANDLE *oss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get debug level of OSS instance. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a6">OSS_MemGet</a> (OSS_HANDLE *oss, u_int32 size, u_int32 *gotsizeP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates general memory block. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a7">OSS_MemFree</a> (OSS_HANDLE *oss, void *addr, u_int32 size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return memory block. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a8">OSS_MemChk</a> (OSS_HANDLE *oss, void *addr, u_int32 size, int32 mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if memory block accessible by caller. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a9">OSS_AlarmCreate</a> (OSS_HANDLE *oss, void(*funct)(void *arg), void *arg, OSS_ALARM_HANDLE **alarmP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an alarm. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a10">OSS_AlarmRemove</a> (OSS_HANDLE *oss, OSS_ALARM_HANDLE **alarmP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys alarm handle. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a11">OSS_AlarmSet</a> (OSS_HANDLE *oss, OSS_ALARM_HANDLE *alarmP, u_int32 msec, u_int32 cyclic, u_int32 *realMsecP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activate an installed alarm routine. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a12">OSS_AlarmClear</a> (OSS_HANDLE *oss, OSS_ALARM_HANDLE *alarmP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deactivate an installed alarm routine. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>OSS_ALARM_STATE&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a13">OSS_AlarmMask</a> (OSS_HANDLE *oss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask alarms. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a14">OSS_AlarmRestore</a> (OSS_HANDLE *oss, OSS_ALARM_STATE oldState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmask alarms. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>OSS_DL_LIST *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a15">OSS_DL_NewList</a> (OSS_DL_LIST *l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize list header. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>OSS_DL_NODE *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a16">OSS_DL_Remove</a> (OSS_DL_NODE *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a node from a list. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>OSS_DL_NODE *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a17">OSS_DL_RemHead</a> (OSS_DL_LIST *l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a node from the head of the list. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>OSS_DL_NODE *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a18">OSS_DL_AddTail</a> (OSS_DL_LIST *l, OSS_DL_NODE *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a node at tail of list. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>OSS_IRQ_STATE&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR</a> (OSS_HANDLE *oss, OSS_IRQ_HANDLE *irqHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask device interrupts. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a20">OSS_IrqRestore</a> (OSS_HANDLE *oss, OSS_IRQ_HANDLE *irqHandle, OSS_IRQ_STATE oldState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmask device interrupts. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask</a> (OSS_HANDLE *oss, OSS_IRQ_HANDLE *irqHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask device interrupts (old implementation). </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a22">OSS_IrqUnMask</a> (OSS_HANDLE *oss, OSS_IRQ_HANDLE *irqHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmask device interrupts (old implementation). </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a23">OSS_IrqLevelToVector</a> (OSS_HANDLE *oss, int32 busType, int32 irqNbr, int32 *vectorP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute interrupt vector from interrupt number and bus type. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a24">OSS_SpinLockCreate</a> (OSS_HANDLE *oss, OSS_SPINL_HANDLE **spinlP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a spin lock. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a25">OSS_SpinLockRemove</a> (OSS_HANDLE *oss, OSS_SPINL_HANDLE **spinlP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy spin lock handle. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a26">OSS_SpinLockAcquire</a> (OSS_HANDLE *oss, OSS_SPINL_HANDLE *spinl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire spin lock. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a27">OSS_SpinLockRelease</a> (OSS_HANDLE *oss, OSS_SPINL_HANDLE *spinl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release spin lock. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a28">OSS_SemCreate</a> (OSS_HANDLE *oss, int32 semType, int32 initVal, OSS_SEM_HANDLE **semP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a semaphore. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a29">OSS_SemRemove</a> (OSS_HANDLE *oss, OSS_SEM_HANDLE **semP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy semaphore handle. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a30">OSS_SemWait</a> (OSS_HANDLE *oss, OSS_SEM_HANDLE *sem, int32 msec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for semaphore. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a31">OSS_SemSignal</a> (OSS_HANDLE *oss, OSS_SEM_HANDLE *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal semaphore. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a32">OSS_SigCreate</a> (OSS_HANDLE *oss, int32 signal, OSS_SIG_HANDLE **sigP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create signal handle. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a33">OSS_SigRemove</a> (OSS_HANDLE *oss, OSS_SIG_HANDLE **sigP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy signal handle. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a34">OSS_SigSend</a> (OSS_HANDLE *oss, OSS_SIG_HANDLE *sig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send signal to a process. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a35">OSS_SigInfo</a> (OSS_HANDLE *oss, OSS_SIG_HANDLE *sig, int32 *signalP, int32 *pidP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get info about signal. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a36">OSS_Delay</a> (OSS_HANDLE *oss, int32 msec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let process sleep for specified time. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a37">OSS_MikroDelayInit</a> (OSS_HANDLE *oss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialisation routine for <a class="el" href="oss__time_8c.html#a13">OSS_MikroDelay()</a>. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a38">OSS_MikroDelay</a> (OSS_HANDLE *oss, u_int32 microSec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay execution of a process by using a busy-loop. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a39">OSS_TickGet</a> (OSS_HANDLE *oss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current system tick. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a40">OSS_TickRateGet</a> (OSS_HANDLE *oss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the tick rate. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a41">OSS_MapPhysToVirtAddr</a> (OSS_HANDLE *oss, void *physAddr, u_int32 size, int32 addrSpace, int32 busType, int32 busNbr, void **virtAddrP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map physical address space to virtual address space. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a42">OSS_UnMapVirtAddr</a> (OSS_HANDLE *oss, void **virtAddrP, u_int32 size, int32 addrSpace)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmap virtual address space. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a43">OSS_BusToPhysAddr</a> (OSS_HANDLE *oss, int32 busType, void **physicalAddrP,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bus address to CPU physical address. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a44">OSS_MapVmeAddr</a> (OSS_HANDLE *oss, u_int64 vmeBusAddr, u_int32 addrMode, u_int32 maxDataMode, u_int32 size, u_int32 flags, void **locAddrP, void **addrWinHdlP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map VMEbus address space into CPU physical address space. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a45">OSS_UnMapVmeAddr</a> (OSS_HANDLE *oss, void *addrWinHdl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmap VMEbus address space. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a46">OSS_PciGetConfig</a> (OSS_HANDLE *oss, int32 busNbr, int32 pciDevNbr, int32 pciFunction, int32 which, int32 *valueP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a register from PCI configuration space. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a47">OSS_PciSetConfig</a> (OSS_HANDLE *oss, int32 busNbr, int32 pciDevNbr, int32 pciFunction, int32 which, int32 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a register in PCI configuration space. </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a48">OSS_PciSlotToPciDevice</a> (OSS_HANDLE *oss, int32 busNbr, int32 mechSlot, int32 *pciDevNbrP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert mechanical slot number to PCI device number. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a49">OSS_IsaGetConfig</a> (OSS_HANDLE *oss, int8 *cardVendId, int16 cardProdId, int8 *devVendId, int16 devProdId, int32 devNbr, int32 resType, int32 resNbr, u_int32 *valueP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get ISAPNP configuration data. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a50">OSS_AssignResources</a> (OSS_HANDLE *oss, int32 busType, int32 busNbr, int32 resNbr, OSS_RESOURCES res[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign memory, I/O, interrupt resources to a driver. </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a51">OSS_UnAssignResources</a> (OSS_HANDLE *oss, int32 busType, int32 busNbr, int32 resNbr, OSS_RESOURCES res[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release resources assigned by <a class="el" href="oss__resource_8c.html#a0">OSS_AssignResources()</a>. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int16&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a52">OSS_Swap16</a> (u_int16 word)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap bytes in 16-bit word. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a53">OSS_Swap32</a> (u_int32 dword)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap bytes in 32-bit word. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a54">OSS_Swap64</a> (u_int64 qword)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap bytes in 64-bit word. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a55">OSS_GetPid</a> (OSS_HANDLE *oss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current task id. </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a56">OSS_MemCopy</a> (OSS_HANDLE *oss, u_int32 size, char *src, char *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy memory block. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a57">OSS_MemFill</a> (OSS_HANDLE *oss, u_int32 size, char *adr, int8 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill data block with byte value. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a58">OSS_StrCpy</a> (OSS_HANDLE *oss, char *from, char *to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy string. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a59">OSS_StrLen</a> (OSS_HANDLE *oss, char *string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the length of a string. </em> <a href="#a59"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a60">OSS_StrCmp</a> (OSS_HANDLE *oss, char *str1, char *str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two strings. </em> <a href="#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a61">OSS_StrNcmp</a> (OSS_HANDLE *oss, char *str1, char *str2, u_int32 nbrOfBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare a limited number of characters of two strings. </em> <a href="#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a62">OSS_StrTok</a> (OSS_HANDLE *oss, char *string, char *separator, char **lastP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Break string into tokens. </em> <a href="#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a63">OSS_Sprintf</a> (OSS_HANDLE *oss, char *str, const char *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print to string using variable number of arguments. </em> <a href="#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a64">OSS_Vsprintf</a> (OSS_HANDLE *oss, char *str, const char *fmt, va_list arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print to string using <em>va_list</em>. </em> <a href="#a64"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a65">OSS_GetSmbHdl</a> (OSS_HANDLE *oss, u_int32 busNbr, void **smbHdlP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get SMB handle. </em> <a href="#a65"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int32&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="oss__specification_8c.html#a66">OSS_SetSmbHdl</a> (OSS_HANDLE *oss, u_int32 busNbr, void *smbHdl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set SMB handle. </em> <a href="#a66"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
MEN OSS (Operating System Services) module specification. 
<p>
<dl compact><dt><b>Author:</b></dt><dd><a href="mailto:klaus.popp@men.de">klaus.popp@men.de</a> <dl compact><dt><b>Date</b></dt><dd>2011/02/24 15:50:08 </dd></dl>
<dl compact><dt><b>Revision</b></dt><dd>1.18 </dd></dl>
</dd></dl>
<p>
This file contains the common, platform independent specification for the OSS module.<hr><h2>Define Documentation</h2>
<a name="a0" doxytag="oss_specification.c::OSS_SWAP16"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSS_SWAP16</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">word&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Macro to swap bytes in 16-bit word. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Parameter <em>word</em> is accessed multiple times by this macro. Use <a class="el" href="oss__specification_8c.html#a52">OSS_Swap16()</a> if this is a problem.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>word</em>&nbsp;</td><td><b>IN</b> word to swap </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>swapped word </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a52">OSS_Swap16</a>, <a class="el" href="oss__specification_8c.html#a1">OSS_SWAP32</a>, <a class="el" href="oss__specification_8c.html#a2">OSS_SWAP64</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="oss_specification.c::OSS_SWAP32"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSS_SWAP32</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">dword&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Macro to swap bytes in 32-bit word. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Parameter <em>dword</em> is accessed multiple times by this macro. Use <a class="el" href="oss__specification_8c.html#a53">OSS_Swap32()</a> if this is a problem.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dword</em>&nbsp;</td><td><b>IN</b> double word to swap </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>swapped double word </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a53">OSS_Swap32</a>, <a class="el" href="oss__specification_8c.html#a0">OSS_SWAP16</a>, <a class="el" href="oss__specification_8c.html#a2">OSS_SWAP64</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="oss_specification.c::OSS_SWAP64"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSS_SWAP64</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">qword&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Macro to swap bytes in 64-bit word. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Parameter <em>qword</em> is accessed multiple times by this macro. Use <a class="el" href="oss__specification_8c.html#a54">OSS_Swap64()</a> if this is a problem.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>qword</em>&nbsp;</td><td><b>IN</b> quad word to swap </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>swapped quad word </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a1">OSS_SWAP32</a>, <a class="el" href="oss__specification_8c.html#a0">OSS_SWAP16</a>, <a class="el" href="oss__specification_8c.html#a53">OSS_Swap32</a>, <a class="el" href="oss__specification_8c.html#a52">OSS_Swap16</a> </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a12" doxytag="oss_specification.c::OSS_AlarmClear"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_AlarmClear </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_ALARM_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>alarmP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deactivate an installed alarm routine. 
<p>
This routine deactivates an alarm previously activated with <a class="el" href="oss__specification_8c.html#a11">OSS_AlarmSet()</a>. Can be used to shut down a cyclic alarm or an alarm in single mode if not yet fired.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>alarmP</em>&nbsp;</td><td><b>IN</b> alarm handle, returned by <a class="el" href="oss__specification_8c.html#a9">OSS_AlarmCreate()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error:<ul>
<li><code>ERR_OSS_ALARM_CLR</code> - if alarm not active </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="oss_specification.c::OSS_AlarmCreate"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_AlarmCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>funct</em>)(void *arg), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>arg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_ALARM_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>alarmP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an alarm. 
<p>
Creates the alarm handle, but does not trigger the alarm. To start the cyclic or one-shot alarm, use <a class="el" href="oss__specification_8c.html#a11">OSS_AlarmSet()</a>.<p>
Function <em>funct</em> is installed as alarm routine, which can be activated by a subsequent <a class="el" href="oss__specification_8c.html#a11">OSS_AlarmSet()</a> call:<p>
<div class="fragment"><pre> <span class="keywordtype">void</span> funct(<span class="keywordtype">void</span> *arg)
</pre></div><p>
Argument <em>arg</em> is passed to the alarm routine.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>funct</em>&nbsp;</td><td><b>IN</b> function to be called when alarm is fired </td></tr>
    <tr><td valign=top><em>arg</em>&nbsp;</td><td><b>IN</b> argument to pass to <em>func</em> </td></tr>
    <tr><td valign=top><em>alarmP</em>&nbsp;</td><td><b>OUT</b> will receive created alarm handle. Must be passed to further OSS_AlarmXXX() routines.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="oss_specification.c::OSS_AlarmMask"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSS_ALARM_STATE OSS_AlarmMask </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>oss</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mask alarms. 
<p>
This routine temporarily masks <b>all</b> alarms to occur until <a class="el" href="oss__specification_8c.html#a14">OSS_AlarmRestore()</a> is called. On most platforms, this routine does essentially the same as <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a>.<p>
The return value of <a class="el" href="oss__specification_8c.html#a13">OSS_AlarmMask()</a> is the system's (alarm) state before <a class="el" href="oss__specification_8c.html#a13">OSS_AlarmMask()</a> has been called. <code>OSS_ALARM_STATE</code> is a system specific type that reflects if alarms are masked (or not). The returned value has to be passed to <a class="el" href="oss__specification_8c.html#a14">OSS_AlarmRestore()</a>.<p>
Example alarm masking: <div class="fragment"><pre>  OSS_ALARM_STATE almState;

  almState = <a class="code" href="oss__specification_8c.html#a13">OSS_AlarmMask</a>( osh );

  <span class="comment">// critical code here</span>

  <a class="code" href="oss__specification_8c.html#a14">OSS_AlarmRestore</a>( osh, almState );  
</pre></div><p>
<dl compact><dt><b>Remarks:</b></dt><dd>This function has been added in MDIS4/2003</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>reflects alarm enabled state before alarm is masked. </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="oss_specification.c::OSS_AlarmRemove"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_AlarmRemove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_ALARM_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>alarmP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroys alarm handle. 
<p>
Frees all resources allocated by <a class="el" href="oss__specification_8c.html#a9">OSS_AlarmCreate()</a>. The alarm is automatically deactivated if it was pending.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>alarmP</em>&nbsp;</td><td><b>IN</b> pointer to alarm handle to remove <b>OUT</b> *alarmP set to NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a14" doxytag="oss_specification.c::OSS_AlarmRestore"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_AlarmRestore </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_ALARM_STATE&nbsp;</td>
          <td class="mdname" nowrap> <em>oldState</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unmask alarms. 
<p>
Must be called to restore the alarm enable state to the state before <a class="el" href="oss__specification_8c.html#a13">OSS_AlarmMask()</a> has been called.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>This function has been added in MDIS4/2003</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>oldState</em>&nbsp;</td><td><b>IN</b> value returned by <a class="el" href="oss__specification_8c.html#a13">OSS_AlarmMask()</a>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a11" doxytag="oss_specification.c::OSS_AlarmSet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_AlarmSet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_ALARM_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>alarmP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>msec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>cyclic</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>realMsecP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Activate an installed alarm routine. 
<p>
This routine activates an alarm created with <a class="el" href="oss__specification_8c.html#a9">OSS_AlarmCreate()</a>.<p>
The installed alarm routine is is called depending on the <em>cyclic</em> parameter:<ul>
<li><em>cyclic==1</em>: cyclically with a period of <em>msec</em> </li><li><em>cyclic==0</em>: once after <em>msec</em>.</li></ul>
<p>
Alarm time may be rounded up to the systems minimum ticker resolution. This (rounded) time is retured in <em>*realMsecP</em>.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The result is undefined if <em>msec</em> is passed as 0.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>alarmP</em>&nbsp;</td><td><b>IN</b> alarm handle, returned by <a class="el" href="oss__specification_8c.html#a9">OSS_AlarmCreate()</a> </td></tr>
    <tr><td valign=top><em>msec</em>&nbsp;</td><td><b>IN</b> alarm time in milliseconds </td></tr>
    <tr><td valign=top><em>cyclic</em>&nbsp;</td><td><b>IN</b> alarm mode: 0=single, 1=cyclic </td></tr>
    <tr><td valign=top><em>realMsecP</em>&nbsp;</td><td><b>OUT</b> rounded alarm time [msec]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a50" doxytag="oss_specification.c::OSS_AssignResources"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_AssignResources </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>resNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_RESOURCES&nbsp;</td>
          <td class="mdname" nowrap> <em>res</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign memory, I/O, interrupt resources to a driver. 
<p>
This function is necessary for operating systems like Windows which register all the resources that a driver need. This function should be call before <a class="el" href="oss__specification_8c.html#a41">OSS_MapPhysToVirtAddr()</a>.<p>
Currently, memory, I/O regions and interrupts are supported as resources.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busType</em>&nbsp;</td><td><b>IN</b> <code>OSS_BUSTYPE_xxx</code>: Bustype where device is located. </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> busType specific, e.g. PICI bus number 5 </td></tr>
    <tr><td valign=top><em>resNbr</em>&nbsp;</td><td><b>IN</b> number of resources in <em>res</em> </td></tr>
    <tr><td valign=top><em>res</em>&nbsp;</td><td><b>IN</b> array of resources to assign</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a43" doxytag="oss_specification.c::OSS_BusToPhysAddr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_BusToPhysAddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>physicalAddrP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert bus address to CPU physical address. 
<p>
This routine converts the specified parameters to a CPU local address. It generally does not map the bus address into callers address space or reserves the bus address for caller's use. See <a class="el" href="oss__specification_8c.html#a41">OSS_MapPhysToVirtAddr()</a> and <a class="el" href="oss__specification_8c.html#a50">OSS_AssignResources()</a> for this purpose.<p>
<a class="el" href="oss__specification_8c.html#a43">OSS_BusToPhysAddr()</a> takes a variable number of arguments, depending on <em>busType</em>:<p>
<ul>
<li><code>OSS_BUSTYPE_NONE</code>:<ul>
<li><em>arg3</em> = void *localAddr (it's usually returned unchanged)</li></ul>
</li></ul>
<p>
<ul>
<li><code>OSS_BUSTYPE_VME</code> <ul>
<li><em>arg3</em> = void *vmeBusAddr: VME bus address relative to VME space</li><li><em>arg4</em> = u_int32 vmeSpace: VMEbus space and data width, specified as <code>OSS_VME_A16</code>, <code>OSS_VME_A24</code>, <code>OSS_VME_A32</code> ORed with <code>OSS_VME_D16</code>, <code>OSS_VME_D32</code>.</li><li><em>arg5</em> = u_int32 size: requested size (sometimes ignored) </li></ul>
</li></ul>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd><a class="el" href="oss__specification_8c.html#a44">OSS_MapVmeAddr()</a> (and subsequent <a class="el" href="oss__specification_8c.html#a45">OSS_UnMapVmeAddr()</a>) should be used instead of OSS_BusToPhysAddr(..,OSS_BUSTYPE_VME,..). </dd></dl>
<p>
<ul>
<li><code>OSS_BUSTYPE_PCI</code> <ul>
<li><em>arg3</em> = int32 busNbr (0..255)</li><li><em>arg4</em> = int32 pciDevNbr (0..31)</li><li><em>arg5</em> = int32 pciFunction (0..7)</li><li><em>arg6</em> = int32 addrNbr (0..5) PCI BAR to read</li></ul>
</li></ul>
<p>
<ul>
<li><code>OSS_BUSTYPE_ISA</code> <ul>
<li>???</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busType</em>&nbsp;</td><td><b>IN</b> bus type (see above) </td></tr>
    <tr><td valign=top><em>physicalAddrP</em>&nbsp;</td><td><b>OUT</b> CPU physical address </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="oss_specification.c::OSS_DbgLevelGet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 OSS_DbgLevelGet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>oss</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get debug level of OSS instance. 
<p>
gets the debug level of this OSS instance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>current debug level mask </dd></dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="oss_specification.c::OSS_DbgLevelSet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_DbgLevelSet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>newLevel</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set debug level of OSS instance. 
<p>
Sets the debug level of this OSS instance. Has no effect if the module is not compiled with <code>DBG</code> switch set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>newLevel</em>&nbsp;</td><td><b>IN</b> new debug level mask, a combination of the <code>DBG_xxx</code> constants from <em>MEN/dbg</em>.h, e.g. <code>DBG_ALL</code>, DBG_LEV1... </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a36" doxytag="oss_specification.c::OSS_Delay"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_Delay </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>msec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Let process sleep for specified time. 
<p>
Suspends the calling process/task for at least the specified time. Time may be rounded up according to ticker resolution.<p>
A <em>msec</em> value of &lt;= 0 shall delay the process for the smallest possible time.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>All signals during sleep will be ignored. It does not return before the specified time has elapsed.<p>
Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>msec</em>&nbsp;</td><td><b>IN</b> number of milliseconds to delay </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>actual time slept in milliseconds </dd></dl>
    </td>
  </tr>
</table>
<a name="a18" doxytag="oss_specification.c::OSS_DL_AddTail"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSS_DL_NODE* OSS_DL_AddTail </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_DL_LIST *&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_DL_NODE *&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a node at tail of list. 
<p>
See <a class="el" href="ossdllusage.html">Using OSS Double Linked Lists</a> for more info.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>l</em>&nbsp;</td><td><b>IN</b> pointer to list header </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td><b>IN</b> node to add </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>n </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a15">OSS_DL_NewList</a>, <a class="el" href="oss__specification_8c.html#a16">OSS_DL_Remove</a>, <a class="el" href="oss__specification_8c.html#a17">OSS_DL_RemHead</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="oss_specification.c::OSS_DL_NewList"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSS_DL_LIST* OSS_DL_NewList </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_DL_LIST *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>l</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize list header. 
<p>
Mark list as empty<p>
See <a class="el" href="ossdllusage.html">Using OSS Double Linked Lists</a> for more info.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>l</em>&nbsp;</td><td><b>IN</b> pointer to list structure </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>l </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a16">OSS_DL_Remove</a>, <a class="el" href="oss__specification_8c.html#a17">OSS_DL_RemHead</a>, <a class="el" href="oss__specification_8c.html#a18">OSS_DL_AddTail</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="oss_specification.c::OSS_DL_RemHead"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSS_DL_NODE* OSS_DL_RemHead </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_DL_LIST *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>l</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a node from the head of the list. 
<p>
See <a class="el" href="ossdllusage.html">Using OSS Double Linked Lists</a> for more info.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>l</em>&nbsp;</td><td><b>IN</b> pointer to list header </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>removed node or NULL if list was empty </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a15">OSS_DL_NewList</a>, <a class="el" href="oss__specification_8c.html#a16">OSS_DL_Remove</a>, <a class="el" href="oss__specification_8c.html#a18">OSS_DL_AddTail</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a16" doxytag="oss_specification.c::OSS_DL_Remove"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSS_DL_NODE* OSS_DL_Remove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_DL_NODE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a node from a list. 
<p>
See <a class="el" href="ossdllusage.html">Using OSS Double Linked Lists</a> for more info.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n</em>&nbsp;</td><td><b>IN</b> node to remove </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>n </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a15">OSS_DL_NewList</a>, <a class="el" href="oss__specification_8c.html#a17">OSS_DL_RemHead</a>, <a class="el" href="oss__specification_8c.html#a18">OSS_DL_AddTail</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a55" doxytag="oss_specification.c::OSS_GetPid"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 OSS_GetPid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>oss</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get current task id. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Task ID is invalid if called at interrupt level.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Don't use it. Not all OSes have a task id. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>task ID of calling process </dd></dl>
    </td>
  </tr>
</table>
<a name="a65" doxytag="oss_specification.c::OSS_GetSmbHdl"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_GetSmbHdl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>smbHdlP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get SMB handle. 
<p>
The function requests the smbHdl for the specified SMBus.<p>
The smbHdl is a pointer to a SMB_HANDLE structure (as defined in sysmanagbus2.h) that provides the functions to access the specified SMBus. The smbHdl can be the initialized handle returned from the Smb_&lt;HWName&gt;_Init() function of the common SMB2 library or it can be initialized from a native SW module. The OS specific implementation of the SMBus support is responsible to initialize the smbHdl prior to <a class="el" href="oss__specification_8c.html#a65">OSS_GetSmbHdl()</a> calls.<p>
With the gotten smbHdl, the caller can use the provided SMB functions. Example: SMB_HANDLE *smbH = ((SMB_HANDLE*)*smbHdlP); error = smbH-&gt;WriteByte( smbH, addr, data );<p>
The function returns <code>ERR_OSS_ILL_HANDLE</code> if the requested smbHdl is not available.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The returned smbHdl is no longer valid after the SMB libraries exit function was called. The caller of OSS_GetSmbHdl must not call the SMB libraries exit function. The SMB library is responsible for the synchronisation of the provided SMB library functions. The suggested assignment for the SMBus identifikation is: busNbr=0 : onboard SMBus, busNbr=1 : additional onboard SMBus or plugged SMBus.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> SMBus identifikation (0,1,2,...) </td></tr>
    <tr><td valign=top><em>smbHdlP</em>&nbsp;</td><td><b>OUT</b> smbHdl</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a66">OSS_SetSmbHdl</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="oss_specification.c::OSS_IrqLevelToVector"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_IrqLevelToVector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>irqNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>vectorP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute interrupt vector from interrupt number and bus type. 
<p>
Used by BBIS handler to translate an interrupt level or interrupt number into an interrupt vector.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busType</em>&nbsp;</td><td><b>IN</b> <code>OSS_BUSTYPE_xxx</code> </td></tr>
    <tr><td valign=top><em>irqNbr</em>&nbsp;</td><td><b>IN</b> interrupt number/level to translate </td></tr>
    <tr><td valign=top><em>vectorP</em>&nbsp;</td><td><b>OUT</b> will contain translated vector</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="oss_specification.c::OSS_IrqMask"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_IrqMask </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_IRQ_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>irqHandle</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mask device interrupts (old implementation). 
<p>
This routine masks the processor interrupts. Depending on the OS and platform, it masks either all interrupts or only the interrupt level at which the device would interrupt. For example, under OS-9/68k, when the device interrupts at IRQ level 4, <a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask()</a> would mask IRQ levels 1..4, but level 5..7 interrupts could still occur.<p>
Other implementations mask all processor interrupts.<p>
To indicate which interrupt level to mask, this routine uses the <em>irqHandle</em> structure, which is filled typically by an <em>OSS_IrqInit()</em> routine. This routine does not exist on all implementations. If it does not exist, you can pass <code>NULL</code> to <em>irqHandle</em>.<p>
To re-enable processor interrupts, call <a class="el" href="oss__specification_8c.html#a22">OSS_IrqUnMask()</a>.<p>
This routine should keep track of the nesting level. If <a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask()</a> has been called already without calling <a class="el" href="oss__specification_8c.html#a22">OSS_IrqUnMask()</a> in between, it shall ignore the second call.<p>
For multiprocessor environments spin lock will be released by <a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask()</a>.<p>
With locked interrupts/ spinlocks no system/OSS calls are allowed with the exception of: <a class="el" href="oss__specification_8c.html#a38">OSS_MikroDelay()</a> <a class="el" href="oss__specification_8c.html#a56">OSS_MemCopy()</a> <a class="el" href="oss__specification_8c.html#a57">OSS_MemFill()</a><p>
In general critical sections protected by <a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask()</a> must be as short as possible.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Due to the nesting problems, this routine shall no longer be used. Use <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a> / <a class="el" href="oss__specification_8c.html#a20">OSS_IrqRestore()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>irqHandle</em>&nbsp;</td><td><b>IN</b> IRQ handle, returned by OSS_IrqInit() or <code>NULL</code> if no OSS_IrqInit() exists. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="oss_specification.c::OSS_IrqMaskR"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSS_IRQ_STATE OSS_IrqMaskR </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_IRQ_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>irqHandle</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mask device interrupts. 
<p>
This is the revised version of <a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask()</a>.<p>
This routine masks the processor interrupts. Depending on the OS and platform, it masks either all interrupts or only the interrupt level at which the device would interrupt. For example, under OS-9/68k, when the device interrupts at IRQ level 4, <a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask()</a> would mask IRQ levels 1..4, but level 5..7 interrupts could still occur.<p>
Other implementations mask all processor interrupts.<p>
To indicate which interrupt level to mask, this routine uses the <em>irqHandle</em> structure, which is filled typically by an <em>OSS_IrqInit()</em> routine. This routine does not exist on all implementations. If it does not exist, you can pass <code>NULL</code> to <em>irqHandle</em>.<p>
To re-enable processor interrupts, call <a class="el" href="oss__specification_8c.html#a20">OSS_IrqRestore()</a>.<p>
The return value of <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a> is the system's IRQ state before <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a> has been called. <code>OSS_IRQ_STATE</code> is a system specific type that reflects the interrupt state of the system. The returned value has to be passed to <a class="el" href="oss__specification_8c.html#a20">OSS_IrqRestore()</a>.<p>
Implementations must make sure that <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a> can be called from any context, include from within interrupt and alarm contexts. Nesting calls to <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a>/OSS_IrqRestore() must be also supported<p>
For multiprocessor environments spin lock will be taken by <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a>.<p>
With locked interrupts/ spinlocks no system/OSS calls are allowed with the exception of: <a class="el" href="oss__specification_8c.html#a38">OSS_MikroDelay()</a> <a class="el" href="oss__specification_8c.html#a56">OSS_MemCopy()</a> <a class="el" href="oss__specification_8c.html#a57">OSS_MemFill()</a><p>
In general critical sections protected by <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a> must be as short as possible.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>irqHandle</em>&nbsp;</td><td><b>IN</b> IRQ handle, returned by OSS_IrqInit() or <code>NULL</code> if no OSS_IrqInit() exists. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>reflects IRQ state before interrupt is masked. </dd></dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="oss_specification.c::OSS_IrqRestore"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_IrqRestore </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_IRQ_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>irqHandle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_IRQ_STATE&nbsp;</td>
          <td class="mdname" nowrap> <em>oldState</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unmask device interrupts. 
<p>
Revised version of <a class="el" href="oss__specification_8c.html#a22">OSS_IrqUnMask()</a>.<p>
Must be called to restore the interrupt flag/level to the state before <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a> has been called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>irqHandle</em>&nbsp;</td><td><b>IN</b> IRQ handle, returned by OSS_IrqInit() or <code>NULL</code> if no OSS_IrqInit() exists. </td></tr>
    <tr><td valign=top><em>oldState</em>&nbsp;</td><td><b>IN</b> value returned by <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a22" doxytag="oss_specification.c::OSS_IrqUnMask"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_IrqUnMask </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_IRQ_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>irqHandle</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unmask device interrupts (old implementation). 
<p>
Must be called to restore the interrupt flag/level to the state before <a class="el" href="oss__specification_8c.html#a21">OSS_IrqMask()</a> has been called.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Due to the nesting problems, this routine shall no longer be used. Use <a class="el" href="oss__specification_8c.html#a19">OSS_IrqMaskR()</a> / <a class="el" href="oss__specification_8c.html#a20">OSS_IrqRestore()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>irqHandle</em>&nbsp;</td><td><b>IN</b> IRQ handle, returned by OSS_IrqInit() or <code>NULL</code> if no OSS_IrqInit() exists. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a49" doxytag="oss_specification.c::OSS_IsaGetConfig"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_IsaGetConfig </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>cardVendId</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int16&nbsp;</td>
          <td class="mdname" nowrap> <em>cardProdId</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>devVendId</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int16&nbsp;</td>
          <td class="mdname" nowrap> <em>devProdId</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>devNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>resType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>resNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>valueP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get ISAPNP configuration data. 
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>add full documentation. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>cardVendId</em>&nbsp;</td><td><b>IN</b> card vendor id (3 characters) </td></tr>
    <tr><td valign=top><em>cardProdId</em>&nbsp;</td><td><b>IN</b> card product number (4 hex digits) </td></tr>
    <tr><td valign=top><em>devVendId</em>&nbsp;</td><td><b>IN</b> device vendor id (3 characters) </td></tr>
    <tr><td valign=top><em>devProdId</em>&nbsp;</td><td><b>IN</b> device product number (4 hex digit) </td></tr>
    <tr><td valign=top><em>devNbr</em>&nbsp;</td><td><b>IN</b> device number (decimal 0..9) </td></tr>
    <tr><td valign=top><em>resType</em>&nbsp;</td><td><b>IN</b> resource type (OSS_ISA_...) </td></tr>
    <tr><td valign=top><em>resNbr</em>&nbsp;</td><td><b>IN</b> resource number (decimal 0..9) </td></tr>
    <tr><td valign=top><em>valueP</em>&nbsp;</td><td><b>OUT</b> output value</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a41" doxytag="oss_specification.c::OSS_MapPhysToVirtAddr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_MapPhysToVirtAddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>physAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>addrSpace</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>virtAddrP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Map physical address space to virtual address space. 
<p>
Maps a given physical address <em>physAddr</em> space to the callers virtual address space and returns the mapped address in <em>*virtAddrP</em>.<p>
The additional parameters <em>addrSpace</em>, <em>busType</em> and <em>busNbr</em> are required for some implementations to use the right mapping routine for the specified physical address, although <em>busType</em> and <em>busNbr</em> are ignored in most implementations.<p>
On OSes without MMU or with a 1:1 mapping between physical and virtual addresses, this routine just passes back the supplied <em>physAddr</em>.<p>
Caller should return the mapped address by means of <a class="el" href="oss__specification_8c.html#a42">OSS_UnMapVirtAddr()</a> when the mapping is no longer needed.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>This routine is intended to be used to map hardware registers. Therefore, the mapped page(s) will be setup to have the cache disabled when it is accessed.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>physAddr</em>&nbsp;</td><td><b>IN</b> physical address to map </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to map </td></tr>
    <tr><td valign=top><em>addrSpace</em>&nbsp;</td><td><b>IN</b> either <code>OSS_ADDRSPACE_MEM</code> or <code>OSS_ADDRSPACE_IO</code> </td></tr>
    <tr><td valign=top><em>busType</em>&nbsp;</td><td><b>IN</b> one of <code>OSS_BUSTYPEE_NONE/VME/PCI/ISA</code> </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> bus type specific parameter (e.g. pci bus nbr) </td></tr>
    <tr><td valign=top><em>virtAddrP</em>&nbsp;</td><td><b>OUT</b> mapped virtual address</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error:<ul>
<li><code>ERR_OSS_MAP_FAILED</code>: mapping not possible </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a name="a44" doxytag="oss_specification.c::OSS_MapVmeAddr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_MapVmeAddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int64&nbsp;</td>
          <td class="mdname" nowrap> <em>vmeBusAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>addrMode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDataMode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>locAddrP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>addrWinHdlP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Map VMEbus address space into CPU physical address space. 
<p>
The function maps the VMEbus address space starting at address <em>vmeBusAddr</em> with the size of <em>size</em> bytes into CPU local address space and stores the corresponding local address into <em>locAddrP</em>.<p>
The used VMEbus address space (VMEbus address modifier) must be specified using the <em>addrMode</em> parameter.<br>
 The maximum possible data access size on the VMEbus that should be used for the pointer access with the returned local address must be set to VME_DM_16 or VME_DM_32 through the <em>maxDataMode</em> parameter.<br>
<p>
The VMEbus address remains mapped until <a class="el" href="oss__specification_8c.html#a45">OSS_UnMapVmeAddr()</a> is called with the <em>addrWinHdlP</em> gotten from <a class="el" href="oss__specification_8c.html#a44">OSS_MapVmeAddr()</a>.<p>
If none VMEbus address windows is available for the specified parameters the function returns with error code <code>ERR_OSS_NO_ADDR_WINDOW</code>.<p>
The function's behavior can be altered using the <em>flags</em> parameter (e.g. to specify a HW Swapping Mode or to enable Posted Write Access).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>vmeBusAddr</em>&nbsp;</td><td><b>IN</b> VME bus address relative to VME space. Must be aligned to maxDataMode. </td></tr>
    <tr><td valign=top><em>addrMode</em>&nbsp;</td><td><b>IN</b> address mode. See <a class="el" href="">VME_AM_X address modes </a> </td></tr>
    <tr><td valign=top><em>maxDataMode</em>&nbsp;</td><td><b>IN</b> maximum VMEbus data access size (VME_DM_16 or VME_DM_32) </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to map. Should be aligned to maxDataMode. </td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td><b>IN</b> bitwise OR of any of the following: <br>
 <b>Hardware Swapping Modes</b><br>
 <code>VME_F_HWSWAP_MODE1</code> to use HW swapping mode #1<br>
 <b>Posted Write Access</b><br>
 <code>VME_F_POSTWR</code> use posted write instead of delayed write<br>
 </td></tr>
    <tr><td valign=top><em>locAddrP</em>&nbsp;</td><td><b>IN</b> pointer to variable that receives the local address </td></tr>
    <tr><td valign=top><em>*locAddrP</em>&nbsp;</td><td><b>OUT</b> local address to access the mapped VMEbus address space </td></tr>
    <tr><td valign=top><em>addrWinHdlP</em>&nbsp;</td><td><b>IN</b> pointer to variable that receives the address-window handle </td></tr>
    <tr><td valign=top><em>*addrWinHdlP</em>&nbsp;</td><td><b>OUT</b> address-window handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0=ok, or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="oss_specification.c::OSS_MemChk"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_MemChk </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>addr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if memory block accessible by caller. 
<p>
This function checks if the memory block starting at <em>addr</em> can be accessed by calling routine/process with the attributes specified with <em>mode</em>.<p>
This function is typically used to verify that an address in user land is really owned by the calling process to avoid that the kernel mode driver crashes the system due to incorrectly passed addresses.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>addr</em>&nbsp;</td><td><b>IN</b> address of memory block to check </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to check starting at <em>addr</em> </td></tr>
    <tr><td valign=top><em>mode</em>&nbsp;</td><td><b>IN</b> combination of <code>OSS_READ</code> ORed with <code>OSS_WRITE</code> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_NO_PERM</code> if no permission </dd></dl>
    </td>
  </tr>
</table>
<a name="a56" doxytag="oss_specification.c::OSS_MemCopy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_MemCopy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>dest</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy memory block. 
<p>
Subsitute for C standard library call <em>memcpy()</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to copy </td></tr>
    <tr><td valign=top><em>src</em>&nbsp;</td><td><b>IN</b> source address </td></tr>
    <tr><td valign=top><em>dest</em>&nbsp;</td><td><b>IN</b> destination address </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a57" doxytag="oss_specification.c::OSS_MemFill"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_MemFill </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>adr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int8&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fill data block with byte value. 
<p>
Subsitute for C standard library call <em>memset()</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to fill </td></tr>
    <tr><td valign=top><em>adr</em>&nbsp;</td><td><b>IN</b> start address </td></tr>
    <tr><td valign=top><em>value</em>&nbsp;</td><td><b>IN</b> fill value </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a7" doxytag="oss_specification.c::OSS_MemFree"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_MemFree </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>addr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return memory block. 
<p>
Returns a memory block previously allocated by <a class="el" href="oss__specification_8c.html#a6">OSS_MemGet()</a>.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The result is undefined if an attempt is made to free a block not previously allocated or with a different size.<p>
<a class="el" href="oss__specification_8c.html#a7">OSS_MemFree()</a> should not be used in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>addr</em>&nbsp;</td><td><b>IN</b> address of memory block </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to free </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a6" doxytag="oss_specification.c::OSS_MemGet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* OSS_MemGet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>gotsizeP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates general memory block. 
<p>
<a class="el" href="oss__specification_8c.html#a6">OSS_MemGet()</a> will allocate a memory block with at least the requested <em>size</em>. Depending on the operating system the actual block may be larger; this size is returned in <em>gotsizeP</em>. When the block is returned to free system memory you must return the actual size, not the requested size. The return value of <a class="el" href="oss__specification_8c.html#a6">OSS_MemGet()</a> is a pointer to the first byte of the memory block or <code>NULL</code> if failed.<p>
The memory block allocated has no special attributes, especially it is not guaranteed to be physically contignous (if the system uses virtual addresses) and it is also not safe to use it for DMA. However each OSS implementation guarantees that the allocated memory block is 4 byte aligned.<p>
Typical usage of the routines:<p>
<div class="fragment"><pre>   <span class="keywordtype">void</span> *block;
  u_int32 gotsize;

  <span class="comment">// Allocate 256 bytes of memory</span>
  block = <a class="code" href="oss__specification_8c.html#a6">OSS_MemGet</a>( llHdl-&gt;osHdl, 256, &amp;gotsize );

  <span class="keywordflow">if</span>( block == NULL ) 
      <span class="keywordflow">return</span> ERR_OSS_MEM_ALLOC;
  <span class="comment">// Here the memory can be used</span>
   ....
  <span class="comment">// free the memory</span>
  <a class="code" href="oss__specification_8c.html#a7">OSS_MemFree</a>( llHdl-&gt;osHdl, block, gotsize );
</pre></div><p>
<dl compact><dt><b>Remarks:</b></dt><dd><a class="el" href="oss__specification_8c.html#a6">OSS_MemGet()</a> should not be used in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to allocate </td></tr>
    <tr><td valign=top><em>gotsizeP</em>&nbsp;</td><td><b>OUT</b> actual number of bytes allocated </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to memory block or <code>NULL</code> if memory could not be allocated </dd></dl>
    </td>
  </tr>
</table>
<a name="a38" doxytag="oss_specification.c::OSS_MikroDelay"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_MikroDelay </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>microSec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay execution of a process by using a busy-loop. 
<p>
Delays the calling process for <em>at</em> <em>least</em> <em>usec</em> by wasting CPU time in a busy loop. It can be called from interrupt or alarm context.<p>
<dl compact><dt><b>Remarks:</b></dt><dd><em>usec</em> shall be in range 0..1000 microseconds. <p>
<a class="el" href="oss__specification_8c.html#a37">OSS_MikroDelayInit()</a> must be called before this routine can be used.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>microSec</em>&nbsp;</td><td><b>IN</b> number of microseconds to delay </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a37" doxytag="oss_specification.c::OSS_MikroDelayInit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_MikroDelayInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>oss</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialisation routine for <a class="el" href="oss__specification_8c.html#a38">OSS_MikroDelay()</a>. 
<p>
This routine performs any initialisation required to execute <a class="el" href="oss__specification_8c.html#a38">OSS_MikroDelay()</a>. For example, it might calibrate a delay loop counter.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>MDIS LL drivers don't need to call this routine. It is done by the MDIS kernel.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a46" doxytag="oss_specification.c::OSS_PciGetConfig"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_PciGetConfig </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>pciDevNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>pciFunction</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>which</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>valueP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read a register from PCI configuration space. 
<p>
This function can be used in two forms:<ul>
<li>Read one of the standard configuration registers. In this case <em>which</em> must be one of<ul>
<li><code>OSS_PCI_VENDOR_ID</code> </li><li><code>OSS_PCI_DEVICE_ID</code> </li><li><code>OSS_PCI_COMMAND</code> </li><li><code>OSS_PCI_STATUS</code> </li><li><code>OSS_PCI_REVISION_ID</code> </li><li><code>OSS_PCI_CLASS</code> </li><li><code>OSS_PCI_SUB_CLASS</code> </li><li><code>OSS_PCI_PROG_IF</code> </li><li><code>OSS_PCI_CACHE_LINE_SIZE</code> </li><li><code>OSS_PCI_PCI_LATENCY_TIMER</code> </li><li><code>OSS_PCI_HEADER_TYPE</code> </li><li><code>OSS_PCI_BIST</code> </li><li><code>OSS_PCI_ADDR_0</code> </li><li><code>OSS_PCI_ADDR_1</code> </li><li><code>OSS_PCI_ADDR_2</code> </li><li><code>OSS_PCI_ADDR_3</code> </li><li><code>OSS_PCI_ADDR_4</code> </li><li><code>OSS_PCI_ADDR_5</code> </li><li><code>OSS_PCI_CIS</code> </li><li><code>OSS_PCI_SUBSYS_VENDOR_ID</code> </li><li><code>OSS_PCI_SUBSYS_ID</code> </li><li><code>OSS_PCI_EXPROM_ADDR</code> </li><li><code>OSS_PCI_INTERRUPT_PIN</code> </li><li><code>OSS_PCI_INTERRUPT_LINE</code> </li></ul>
</li></ul>
<p>
Example: <div class="fragment"><pre>     error = <a class="code" href="oss__specification_8c.html#a46">OSS_PciGetConfig</a>( oss, bus, dev, func, OSS_PCI_CLASS, &amp;value );
</pre></div><p>
<ul>
<li>Read an arbitrary configuration register. In this case, <em>which</em> is composed of an access width specifier ORed with the register offset. Possible access widths:<ul>
<li><code>OSS_PCI_ACCESS_8</code> </li><li><code>OSS_PCI_ACCESS_16</code> </li><li><code>OSS_PCI_ACCESS_32</code> </li></ul>
</li></ul>
<p>
Example: <div class="fragment"><pre>     error = <a class="code" href="oss__specification_8c.html#a46">OSS_PciGetConfig</a>( oss, bus, dev, func, 
                                 OSS_PCI_ACCESS_32 | 0x40, &amp;value );
</pre></div><p>
<dl compact><dt><b>Remarks:</b></dt><dd>If an attempt is made to access a non existant PCI device, no error is returned, but <em>*valueP</em> will contain <code>0xFFFFFFFF</code>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> PCI bus number (0..255) </td></tr>
    <tr><td valign=top><em>pciDevNbr</em>&nbsp;</td><td><b>IN</b> PCI device number (0..31) </td></tr>
    <tr><td valign=top><em>pciFunction</em>&nbsp;</td><td><b>IN</b> PCI function number (0..7) </td></tr>
    <tr><td valign=top><em>which</em>&nbsp;</td><td><b>IN</b> see text above </td></tr>
    <tr><td valign=top><em>valueP</em>&nbsp;</td><td><b>OUT</b> value read from config space. Must be a pointer a 32 bit value in any case. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_PCI_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a47" doxytag="oss_specification.c::OSS_PciSetConfig"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_PciSetConfig </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>pciDevNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>pciFunction</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>which</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write to a register in PCI configuration space. 
<p>
This function can be used in two forms:<ul>
<li>Write one of the standard configuration registers. In this case <em>which</em> must be one of<ul>
<li><code>OSS_PCI_VENDOR_ID</code> </li><li><code>OSS_PCI_DEVICE_ID</code> </li><li><code>OSS_PCI_COMMAND</code> </li><li><code>OSS_PCI_STATUS</code> </li><li><code>OSS_PCI_REVISION_ID</code> </li><li><code>OSS_PCI_CLASS</code> </li><li><code>OSS_PCI_SUB_CLASS</code> </li><li><code>OSS_PCI_PROG_IF</code> </li><li><code>OSS_PCI_CACHE_LINE_SIZE</code> </li><li><code>OSS_PCI_PCI_LATENCY_TIMER</code> </li><li><code>OSS_PCI_HEADER_TYPE</code> </li><li><code>OSS_PCI_BIST</code> </li><li><code>OSS_PCI_ADDR_0</code> </li><li><code>OSS_PCI_ADDR_1</code> </li><li><code>OSS_PCI_ADDR_2</code> </li><li><code>OSS_PCI_ADDR_3</code> </li><li><code>OSS_PCI_ADDR_4</code> </li><li><code>OSS_PCI_ADDR_5</code> </li><li><code>OSS_PCI_CIS</code> </li><li><code>OSS_PCI_SUBSYS_VENDOR_ID</code> </li><li><code>OSS_PCI_SUBSYS_ID</code> </li><li><code>OSS_PCI_EXPROM_ADDR</code> </li><li><code>OSS_PCI_INTERRUPT_PIN</code> </li><li><code>OSS_PCI_INTERRUPT_LINE</code> </li></ul>
</li></ul>
<p>
Example: <div class="fragment"><pre>     error = <a class="code" href="oss__specification_8c.html#a47">OSS_PciSetConfig</a>( oss, bus, dev, func, OSS_PCI_CLASS, value );
</pre></div><p>
<ul>
<li>Write an arbitrary configuration register. In this case, <em>which</em> is composed of an access width specifier ORed with the register offset. Possible access widths:<ul>
<li><code>OSS_PCI_ACCESS_8</code> </li><li><code>OSS_PCI_ACCESS_16</code> </li><li><code>OSS_PCI_ACCESS_32</code> </li></ul>
</li></ul>
<p>
Example: <div class="fragment"><pre>     error = <a class="code" href="oss__specification_8c.html#a47">OSS_PciSetConfig</a>( oss, bus, dev, func, 
                                 OSS_PCI_ACCESS_32 | 0x40, value );
</pre></div><p>
<dl compact><dt><b>Remarks:</b></dt><dd>If an attempt is made to access a non existant PCI device, no error is returned, the value is written into nirwanha.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> PCI bus number (0..255) </td></tr>
    <tr><td valign=top><em>pciDevNbr</em>&nbsp;</td><td><b>IN</b> PCI device number (0..31) </td></tr>
    <tr><td valign=top><em>pciFunction</em>&nbsp;</td><td><b>IN</b> PCI function number (0..7) </td></tr>
    <tr><td valign=top><em>which</em>&nbsp;</td><td><b>IN</b> see text above </td></tr>
    <tr><td valign=top><em>value</em>&nbsp;</td><td><b>IN</b> value to write to config space.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_PCI_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a48" doxytag="oss_specification.c::OSS_PciSlotToPciDevice"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_PciSlotToPciDevice </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>mechSlot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>pciDevNbrP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert mechanical slot number to PCI device number. 
<p>
The main purpose of this function is to determine the PCI device number of a PCI card in slot <em>mechSlot</em>.<p>
Typically used by BBIS drivers, such as the driver for D201 board family.<p>
Mechanical slots are numbered from 1..17. On CompactPCI, 1 is the CPU itsself, 2 the slot next to the CPU.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> the PCI bus number in question </td></tr>
    <tr><td valign=top><em>mechSlot</em>&nbsp;</td><td><b>IN</b> mechanical slot to convert (1..17) </td></tr>
    <tr><td valign=top><em>pciDevNbrP</em>&nbsp;</td><td><b>OUT</b> PCI device number (0..31)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="oss_specification.c::OSS_SemCreate"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SemCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>semType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>initVal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SEM_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>semP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a semaphore. 
<p>
Creates a binary or counting semaphore.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>semType</em>&nbsp;</td><td><b>IN</b> semaphore type<ul>
<li><code>OSS_SEM_BIN</code>: binary semaphore</li><li><code>OSS_SEM_COUNT</code>: counting semaphore </li></ul>
</td></tr>
    <tr><td valign=top><em>initVal</em>&nbsp;</td><td><b>IN</b> initial semaphore value<ul>
<li>0..1 (for <code>OSS_SEM_BIN</code>)</li><li>0..+n (for <code>OSS_SEM_COUNT</code>) </li></ul>
</td></tr>
    <tr><td valign=top><em>semP</em>&nbsp;</td><td><b>OUT</b> will receive created semaphore handle. Must be passed to further OSS_SemXXX() routines.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a29" doxytag="oss_specification.c::OSS_SemRemove"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SemRemove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SEM_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>semP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy semaphore handle. 
<p>
Frees all resources allocated by <a class="el" href="oss__specification_8c.html#a28">OSS_SemCreate()</a>.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>semP</em>&nbsp;</td><td><b>IN</b> pointer to semaphore handle to remove <b>OUT</b> *semP set to NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="oss_specification.c::OSS_SemSignal"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SemSignal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SEM_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal semaphore. 
<p>
The function increments the semaphores value by <code>1</code> and wakes up the next queued process waiting for the event.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>sem</em>&nbsp;</td><td><b>IN</b> semaphore handle, returned by <a class="el" href="oss__specification_8c.html#a28">OSS_SemCreate()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a30" doxytag="oss_specification.c::OSS_SemWait"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SemWait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SEM_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>msec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for semaphore. 
<p>
The function waits with a given timeout until the semaphore value is larger than zero and decrements the event value.<p>
Error <code>ERR_OSS_TIMEOUT</code> is returned if the semaphore was not released within the timeout period.<p>
Error <code>ERR_OSS_TIMEOUT</code> is returned if <code>OSS_SEM_NOWAIT</code> specified and semaphore was not available.<p>
Error <code>ERR_OSS_SIG_OCCURED</code> is returned if a deadly signal occured while waiting.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Only some OSes may abort a semaphore wait with a signal, currently OS-9 and Linux.</dd></dl>
Given timeout <em>msec</em> will be rounded up to system ticks<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>sem</em>&nbsp;</td><td><b>IN</b> semaphore handle, returned by <a class="el" href="oss__specification_8c.html#a28">OSS_SemCreate()</a> </td></tr>
    <tr><td valign=top><em>msec</em>&nbsp;</td><td><b>IN</b> wait timeout:<ul>
<li>0 no wait, just take sem (<code>OSS_SEM_NOWAIT</code>)</li><li>-1 endless timeout (<code>OSS_SEM_WAITFOREVER</code>)</li><li>&gt;0 timeout [msec]</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a66" doxytag="oss_specification.c::OSS_SetSmbHdl"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SetSmbHdl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>smbHdl</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set SMB handle. 
<p>
The function sets the smbHdl for the specified SMBus.<p>
The smbHdl is a pointer to a initialized SMB_HANDLE structure (as defined in sysmanagbus2.h) that provides the functions to access the specified SMBus. The smbHdl can be the initialized handle returned from the Smb_&lt;HWName&gt;_Init() function of the common SMB2 library or it can be initialized from a native SW module.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The returned smbHdl is no longer valid after the SMB libraries exit function was called.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> SMBus identifikation (0,1,2,...) </td></tr>
    <tr><td valign=top><em>smbHdl</em>&nbsp;</td><td><b>OUT</b> smbHdl</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a65">OSS_GetSmbHdl</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="oss_specification.c::OSS_SigCreate"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SigCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>signal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SIG_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>sigP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create signal handle. 
<p>
This creates an OS specific handle to store an identifier for the calling task. To send the signal, use <a class="el" href="oss__specification_8c.html#a34">OSS_SigSend()</a>.<p>
This routine must be called in the context of the process/task that wishes to receive the signal.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>signal</em>&nbsp;</td><td><b>IN</b> signal code to install </td></tr>
    <tr><td valign=top><em>sigP</em>&nbsp;</td><td><b>OUT</b> will receive created signal handle. Must be passed to further OSS_SigXXX() routines.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a35" doxytag="oss_specification.c::OSS_SigInfo"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SigInfo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SIG_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>sig</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>signalP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>pidP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get info about signal. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Don't use it. Not all OSes have a process ID.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>sig</em>&nbsp;</td><td><b>IN</b> signal handle, returned by <a class="el" href="oss__specification_8c.html#a32">OSS_SigCreate()</a> </td></tr>
    <tr><td valign=top><em>signalP</em>&nbsp;</td><td><b>OUT</b> signal code </td></tr>
    <tr><td valign=top><em>pidP</em>&nbsp;</td><td><b>OUT</b> process id </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="oss_specification.c::OSS_SigRemove"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SigRemove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SIG_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>sigP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy signal handle. 
<p>
Frees all resources allocated by <a class="el" href="oss__specification_8c.html#a32">OSS_SigCreate()</a>. The function fails if the calling process id is not equal to the installing process.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>sigP</em>&nbsp;</td><td><b>IN</b> pointer to signal handle to remove <b>OUT</b> *sigP set to NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="oss_specification.c::OSS_SigSend"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SigSend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SIG_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>sig</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send signal to a process. 
<p>
Sends the signal previously created by <a class="el" href="oss__specification_8c.html#a32">OSS_SigCreate()</a> to the process that called <a class="el" href="oss__specification_8c.html#a32">OSS_SigCreate()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>sig</em>&nbsp;</td><td><b>IN</b> signal handle, returned by <a class="el" href="oss__specification_8c.html#a32">OSS_SigCreate()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a26" doxytag="oss_specification.c::OSS_SpinLockAcquire"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SpinLockAcquire </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SPINL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>spinl</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire spin lock. 
<p>
The method spins until the specified spin lock has been acquired.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>spinl</em>&nbsp;</td><td><b>IN</b> spin lock handle, returned by <a class="el" href="oss__specification_8c.html#a24">OSS_SpinLockCreate()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="oss_specification.c::OSS_SpinLockCreate"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SpinLockCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SPINL_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>spinlP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a spin lock. 
<p>
This routine must be called before any other OSS_SpinLockXXX() routines.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>spinlP</em>&nbsp;</td><td><b>OUT</b> will receive created spin lock handle. Must be passed to further OSS_SpinLockXXX() routines.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="oss_specification.c::OSS_SpinLockRelease"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SpinLockRelease </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SPINL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>spinl</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release spin lock. 
<p>
The method releases the spin lock gotten by previously calling OSS_SpinLockAcquire.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>spinl</em>&nbsp;</td><td><b>IN</b> spin lock handle, returned by <a class="el" href="oss__specification_8c.html#a24">OSS_SpinLockCreate()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="oss_specification.c::OSS_SpinLockRemove"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_SpinLockRemove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SPINL_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>spinlP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy spin lock handle. 
<p>
Frees all resources allocated by <a class="el" href="oss__specification_8c.html#a24">OSS_SpinLockCreate()</a>.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Don't use in IRQ or Alarm routines.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>spinlP</em>&nbsp;</td><td><b>IN</b> pointer to spin lock handle to remove <b>OUT</b> *spinlP set to NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a63" doxytag="oss_specification.c::OSS_Sprintf"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_Sprintf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>str</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print to string using variable number of arguments. 
<p>
Subsitute for C standard library call <em>sprintf()</em>.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Implementations don't need to support floating point formats.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>str</em>&nbsp;</td><td><b>IN</b> destination buffer, will contain formatted string. </td></tr>
    <tr><td valign=top><em>fmt</em>&nbsp;</td><td><b>IN</b> printf()-like format string </td></tr>
    <tr><td valign=top><em>...</em>&nbsp;</td><td><b>IN</b> arguments</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>number of characters written to string (excluding \0) </dd></dl>
    </td>
  </tr>
</table>
<a name="a60" doxytag="oss_specification.c::OSS_StrCmp"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_StrCmp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>str1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>str2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare two strings. 
<p>
Subsitute for C standard library call <em>strcmp()</em>.<p>
Compares str1 and str2 lexicographicaly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>str1</em>&nbsp;</td><td><b>IN</b> pointer to 1st string </td></tr>
    <tr><td valign=top><em>str2</em>&nbsp;</td><td><b>IN</b> pointer to 2nd string </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><br>
<ul>
<li>0 if equal</li><li>&gt;0 if str1[x] &gt; str2[x] ( first different char )</li><li>&lt;0 if str1[x] &lt; str2[x] ( first different char ) </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a name="a58" doxytag="oss_specification.c::OSS_StrCpy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void OSS_StrCpy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>from</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy string. 
<p>
Subsitute for C standard library call <em>strcpy()</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>from</em>&nbsp;</td><td><b>IN</b> source string </td></tr>
    <tr><td valign=top><em>to</em>&nbsp;</td><td><b>IN</b> destination string </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a59" doxytag="oss_specification.c::OSS_StrLen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 OSS_StrLen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>string</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the length of a string. 
<p>
Subsitute for C standard library call <em>strlen()</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>string</em>&nbsp;</td><td><b>IN</b> start address of string </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a61" doxytag="oss_specification.c::OSS_StrNcmp"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_StrNcmp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>str1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>str2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrOfBytes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare a limited number of characters of two strings. 
<p>
Subsitute for C standard library call <em>strncmp()</em>.<p>
Compares at most <em>nbrOfBytes</em> characters of str1 and str2 lexicographicaly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>str1</em>&nbsp;</td><td><b>IN</b> pointer to 1st string </td></tr>
    <tr><td valign=top><em>str2</em>&nbsp;</td><td><b>IN</b> pointer to 2nd string </td></tr>
    <tr><td valign=top><em>nbrOfBytes</em>&nbsp;</td><td><b>IN</b> max. number of bytes to compare </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><br>
<ul>
<li>0 if equal</li><li>&gt;0 if str1[x] &gt; str2[x] ( first different char )</li><li>&lt;0 if str1[x] &lt; str2[x] ( first different char ) </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a name="a62" doxytag="oss_specification.c::OSS_StrTok"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* OSS_StrTok </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>separator</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>lastP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Break string into tokens. 
<p>
Subsitute for C standard library call <em>strtok()</em>, but <a class="el" href="oss__specification_8c.html#a62">OSS_StrTok()</a> is reentrant.<p>
For the first call, pass <em>*lastP</em> as NULL. In this case, <a class="el" href="oss__specification_8c.html#a62">OSS_StrTok()</a> searches from the beginning of <em>string</em> for the separator string <em>separator</em>. The separator string must be found completely in <em>string</em>.<p>
If a separator was found, the first char of the separator occurrance within <em>string</em> is replaced by a '\0'. The variable pointed to by <em>*lastP</em> is used to save the search start point within <em>string</em> for the next call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>string</em>&nbsp;</td><td><b>IN</b> string to break into tokens. Can be NULL for for second and subsequent calls. </td></tr>
    <tr><td valign=top><em>separator</em>&nbsp;</td><td><b>IN</b> separator string </td></tr>
    <tr><td valign=top><em>lastP</em>&nbsp;</td><td><b>IN/OUT</b> start of next separator search. Should be passed as NULL for the first call. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to token or NULL if separator not found </dd></dl>
    </td>
  </tr>
</table>
<a name="a52" doxytag="oss_specification.c::OSS_Swap16"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int16 OSS_Swap16 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int16&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>word</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Swap bytes in 16-bit word. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>word</em>&nbsp;</td><td><b>IN</b> word to swap </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>swapped word </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a0">OSS_SWAP16</a>, <a class="el" href="oss__specification_8c.html#a53">OSS_Swap32</a>, <a class="el" href="oss__specification_8c.html#a54">OSS_Swap64</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a53" doxytag="oss_specification.c::OSS_Swap32"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 OSS_Swap32 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dword</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Swap bytes in 32-bit word. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dword</em>&nbsp;</td><td><b>IN</b> double word to swap </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>swapped double word </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a1">OSS_SWAP32</a>, <a class="el" href="oss__specification_8c.html#a52">OSS_Swap16</a>, <a class="el" href="oss__specification_8c.html#a54">OSS_Swap64</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a54" doxytag="oss_specification.c::OSS_Swap64"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 OSS_Swap64 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int64&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>qword</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Swap bytes in 64-bit word. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>qword</em>&nbsp;</td><td><b>IN</b> quad word to swap </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>swapped quad word </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="oss__specification_8c.html#a2">OSS_SWAP64</a>, <a class="el" href="oss__specification_8c.html#a52">OSS_Swap16</a>, <a class="el" href="oss__specification_8c.html#a53">OSS_Swap32</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a39" doxytag="oss_specification.c::OSS_TickGet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 OSS_TickGet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>oss</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current system tick. 
<p>
The OSS tick is a 32 bit value that is incremented at a rate determined by <a class="el" href="oss__specification_8c.html#a40">OSS_TickRateGet()</a>. The counter always uses the full 32 bits and wraps from 0xffffffff to 0x00000000.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>If interrupts are masked, the tick may no longer be incremented.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>current system tick value. </dd></dl>
    </td>
  </tr>
</table>
<a name="a40" doxytag="oss_specification.c::OSS_TickRateGet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_TickRateGet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>oss</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the tick rate. 
<p>
Get the rate at which the OSS tick is incremented in ticks per seconds.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>this function shall return a value between 50 and 1000000; i.e. 20ms to 1us.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>tick rate in Hz </dd></dl>
    </td>
  </tr>
</table>
<a name="a51" doxytag="oss_specification.c::OSS_UnAssignResources"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_UnAssignResources </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>busNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>resNbr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_RESOURCES&nbsp;</td>
          <td class="mdname" nowrap> <em>res</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release resources assigned by <a class="el" href="oss__specification_8c.html#a50">OSS_AssignResources()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>busType</em>&nbsp;</td><td><b>IN</b> <code>OSS_BUSTYPE_xxx</code>: Bustype where device is located. </td></tr>
    <tr><td valign=top><em>busNbr</em>&nbsp;</td><td><b>IN</b> busType specific, e.g. PICI bus number 5 </td></tr>
    <tr><td valign=top><em>resNbr</em>&nbsp;</td><td><b>IN</b> number of resources in <em>res</em> </td></tr>
    <tr><td valign=top><em>res</em>&nbsp;</td><td><b>IN</b> array of resources to release</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a42" doxytag="oss_specification.c::OSS_UnMapVirtAddr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_UnMapVirtAddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>virtAddrP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>addrSpace</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unmap virtual address space. 
<p>
Unmaps virtual address space previously mapped by <a class="el" href="oss__specification_8c.html#a41">OSS_MapPhysToVirtAddr()</a>.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The result is undefined if an attempt is made to unmap a virtual address not previously mapped or with a different size.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>virtAddrP</em>&nbsp;</td><td><b>IN</b> *virtAddrP = virtual address to unmap. <br>
 <b>OUT</b> *virtAddrP set to NULL. </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> number of bytes to unmap </td></tr>
    <tr><td valign=top><em>addrSpace</em>&nbsp;</td><td><b>IN</b> either <code>OSS_ADDRSPACE_MEM</code> or <code>OSS_ADDRSPACE_IO</code> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or <code>ERR_OSS_xxx</code> error code on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a45" doxytag="oss_specification.c::OSS_UnMapVmeAddr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_UnMapVmeAddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>addrWinHdl</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unmap VMEbus address space. 
<p>
The function unmaps an <a class="el" href="oss__specification_8c.html#a44">OSS_MapVmeAddr()</a> mapped VMEbus address space, specified by the corresponding <em>addrWinHdl</em> .<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>addrWinHdl</em>&nbsp;</td><td><b>IN</b> Address-window handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0=ok, or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a64" doxytag="oss_specification.c::OSS_Vsprintf"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 OSS_Vsprintf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>oss</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>str</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>va_list&nbsp;</td>
          <td class="mdname" nowrap> <em>arg</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print to string using <em>va_list</em>. 
<p>
Subsitute for C standard library call <em>vsprintf()</em>.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Implementations don't need to support floating point formats.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oss</em>&nbsp;</td><td><b>IN</b> OSS handle, returned by <a class="el" href="oss_8c.html#a66">OSS_Init()</a> </td></tr>
    <tr><td valign=top><em>str</em>&nbsp;</td><td><b>IN</b> destination buffer, will contain formatted string. </td></tr>
    <tr><td valign=top><em>fmt</em>&nbsp;</td><td><b>IN</b> printf()-like format string </td></tr>
    <tr><td valign=top><em>arg</em>&nbsp;</td><td><b>IN</b> arguments</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>number of characters written to string (excluding \0) </dd></dl>
    </td>
  </tr>
</table>

	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for OSS module for Linux/RTAI using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2012 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

