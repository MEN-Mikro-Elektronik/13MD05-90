<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - Linux native Driver for 16Z077/87 Ethernet IP cores - men_16z077_eth.c File Reference</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;"></a>
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Linux native Driver for 16Z077/87 Ethernet IP cores &nbsp; </h1>
	<h3>men_16z077_eth.c File Reference</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>men_16z077_eth.c File Reference</h1>driver for IP core 16Z087 (Ethernet cores). supports kernel 2.6 and 3.x  
<a href="#_details">More...</a>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structz77__private.html">z77_private</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z077_private: main data struct for the driver <br>
 this struct keeps all data for a per-IP-core instance of 16Z077/87 </em> <a href="structz77__private.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a56">z77_open</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_open - open the ethernet device for first usage Open/initialize the Ethernet device. This routine should set everything up anew at each open, even registers that should only need to be set once at boot, so that there is non-reboot way to recover if something goes wrong. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a57">z77_send_packet</a> (struct sk_buff *skb, struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">send a ready made ethernet frame The OpenCore MAC Spec states about transmitting: </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>irqreturn_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a58">z77_irq</a> (int irq, void *dev_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">central IRQ handler </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a59">z77_close</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The inverse routine to <a class="el" href="men__16z077__eth_8c.html#a56">z77_open()</a>. </em> <a href="#a59"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>net_device_stats *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a60">z77_get_stats</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current statistics. </em> <a href="#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a61">z77_tx_timeout</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timeout handler when no scheduled ETH irq arrived. </em> <a href="#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a62">z77_rx_err</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">net_rx_err - irq context handler to report Errors </em> <a href="#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a63">z77_tx_err</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">net_tx_err - irq context handler to report Errors </em> <a href="#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a66">z77_phy_reset</a> (struct net_device *dev, u8 phyAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_phy_reset This routine send a Reset command to the PHY specified in the parameter phyaddr. </em> <a href="#a66"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a67">z77_phy_identify</a> (struct net_device *dev, u8 phyAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_phy_identify - probe the PHY device This routine probes the PHY device by reading its PHY Identifier Register </em> <a href="#a67"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a68">z77_phy_init</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_phy_init - initialize and configure the PHY devices This routine scans, initializes and configures PHY devices. </em> <a href="#a68"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a69">z77_init_phymode</a> (struct net_device *dev, u8 phyAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_init_phymode - Set Phy Mode and Flags according to given mode </em> <a href="#a69"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a70">z77_pass_packet</a> (struct net_device *dev, unsigned int idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_pass_packet - packet passing function for one ETH frame </em> <a href="#a70"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a73">z77_reset</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_reset - reset device with asynchronous global Reset Register 0x54 </em> <a href="#a73"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a74">z77_ioctl</a> (struct net_device *dev, struct ifreq *ifr, int cmd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ioctl function - interface to applications </em> <a href="#a74"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a90">z77_set_rx_mode</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle multicast and promiscuous mode set. </em> <a href="#a90"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a107">z77_bd_setup</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_bd_setup - perform initialization of buffer descriptors this initializes the buffer descriptors such that PCI DMA - ready memory chunks are allocated </em> <a href="#a107"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a108">z77_setup</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_setup - perform initialization of buffer descriptors this acts as wrapper that calls the adequate setup function depending on normal DMA use (ethernet frames sent to CPU memory by DMA from IP core) or non DMA use (currently only P511) </em> <a href="#a108"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a109">z77_do_autonegotiation</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do the complete Autonegotiation for the used Ethernet PHY. </em> <a href="#a109"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a110">cleanup_card</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">remove the NIC from Kernel </em> <a href="#a110"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int __init&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a111">probe_z77</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for a network adapter of this type, and return '0' if one exists. </em> <a href="#a111"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a112">z77_reset_task</a> (struct work_struct *work)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timeout handler when no scheduled ETH irq arrived. </em> <a href="#a112"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a113">z77_process_rx</a> (struct net_device *dev, int weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_process_rx - process each nonempty Rx BD Without Rx position info determining oldest Rx frame is complicated, several basic situations are possible: </em> <a href="#a113"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a114">chipset_init</a> (struct net_device *dev, u32 donegotiate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the IP core Registers setup the necessary Registers like MODER, BDNUM (used on Z77 only) ans others such that the NIC can completely be restarted if needed. </em> <a href="#a114"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a115">z77_tx</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The interrupt context Tx packet handler Called from within main ISR context. unmaps allocated PCI transfer memory region and updates stats info. No spin_lock here because main irq routine does local Eth core IRQ disabling already. </em> <a href="#a115"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a116" doxytag="men_16z077_eth.c::z77_drop_rxbuffers"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a116">z77_drop_rxbuffers</a> (struct net_device *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop Rx buffers in case of BUSY interrupt (context: IRQ) in case we get a BUSY interrupt, throw away all packets (if this IRQ occurs we have some serious network flooding or CPU performance problem) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a117">z77_retrieve_fpga_name</a> (struct net_device *dev, CHAMELEON_UNIT_T *chamUnit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">z77_retrieve_fpga_name - get FPGA name of 'this' Z87 </em> <a href="#a117"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a118">men_16z077_probe</a> (CHAMELEON_UNIT_T *chu)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">men_16z077_probe - PNP function for ETH </em> <a href="#a118"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a119">men_16z077_remove</a> (CHAMELEON_UNIT_T *chu)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PNP function to remove the unit driver. </em> <a href="#a119"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a120" doxytag="men_16z077_eth.c::men_16z077_cleanup"></a>
void __exit&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a120">men_16z077_cleanup</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drivers cleanup routine <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int __init&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a121">men_16z077_init</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">module init function </em> <a href="#a121"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a53" doxytag="men_16z077_eth.c::z77_ethtool_ops"></a>
ethtool_ops&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__16z077__eth_8c.html#a53">z77_ethtool_ops</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure provides the interface functions to the standard ethtool. <br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
driver for IP core 16Z087 (Ethernet cores). supports kernel 2.6 and 3.x 
<p>
<dl compact><dt><b>Author:</b></dt><dd><a href="mailto:thomas.schnuerer@men.de">thomas.schnuerer@men.de</a> <dl compact><dt><b>Date</b></dt><dd>2014/07/16 19:30:45 </dd></dl>
<dl compact><dt><b>Revision</b></dt><dd>1.45 </dd></dl>
</dd></dl>
<p>
Switches: NIOS_II defined for build on Nios II based systems CONFIG_MENEM1 defined for build with MEN EM01A/N CONFIG_MENEM9 defined for build with MEN EM09 CONFIG_MENEP05 defined for build with MEN EP05/6/7 NO_PHY defined for specific PHY-less HW MEN_MM1 defined for build with MEN MM1<p>
DESCRIPTION<p>
The driver supports the IP core 16Z087 derived from Opencores ETH MAC ( www.opencores.org )<p>
<div class="fragment"><pre>
 * Description of Registers:
 *
 * Name          Address     Width   Access  Description
 * -------------------------------------------------------------------------
 * MODER         0x00        32      RW      Mode Register
 * INT_SOURCE    0x04        32      RW      Interrupt Source Register
 * INT_MASK      0x08        32      RW      Interrupt Mask Register
 * IPGT          0x0C        32      RW      Back to Back Inter Packet
 *                                           GapRegister
 * IPGR1         0x10        32      RW      Non Back to Back Inter Packet
 *                                           Gap Register 1
 * IPGR2         0x14        32      RW      Non Back to Back Inter Packet
 *                                           Gap Register 2
 * PACKETLEN     0x18        32      RW      Packet Length (minimum and
 *                                           maximum) Register
 * COLLCONF      0x1C        32      RW      Collision and Retry Configuration
 * TX_BD_NUM     0x20        32      RW      Transmit Buffer Descriptor Number
 * CTRLMODER     0x24        32      RW      Control Module Mode Register
 * MIIMODER      0x28        32      RW      MII Mode Register
 * MIICOMMAND    0x2C        32      RW      MII Commend Register
 * MIIADDRESS    0x30        32      RW      MII Address Register Contains
 *                                           the PHY address and the register
 *  										 within the PHY address
 * MIITX_DATA    0x34        32      RW      MII Transmit Data The data to
 *                                           be transmitted to the PHY
 * MIIRX_DATA    0x38        32      RW      MII Receive Data The data
 *                                           received from the PHY
 * MIISTATUS     0x3C        32      RW      MII Status Register
 *
 * MAC_ADDR0     0x40        32      RW      MAC Individual Address0 The LSB
 *                                           four bytes of the MAC address
 * MAC_ADDR1     0x44        32      RW      MAC Individual Address1 The MSB
 *                                           two bytes of the MAC
 * ETH_HASH0_ADR 0x48        32      RW      HASH0 Register
 * ETH_HASH1_ADR 0x4C        32      RW      HASH1 Register
 * ETH_TXCTRL    0x50        32      RW      Transmit Control Register
 *
 *
 * original ETH OpenCore:  BDs start at Z077_BD_OFFS (0x400) after ChamBase.
 *
 * Z077_BDBASE  = ChamBase + 0x400
 * Z077_BD_OFFS = 0x400
 * +--------------+
 * |			  |
 * |--------------|- Rx BD Start
 * |   	   	   	  |
 * |--------------|- TX Bd  Start (= Z077_BDBASE + Z077_BD_OFFS )
 * |XXXXXXXXXXXXXX|  Ctrl Regs
 * +--------------+- Chameleon Base Address
 *
 *
 * New Core: BDs reside in RAM, Address must be 10bit-aligned
 *
 * Z077_BDBASE  = pDrvCtrl-&gt;bdBase;
 * Z077_BD_OFFS = 0
 *
 * +--------------+
 * |			  |
 * |--------------|- Tx BD Start
 * |   	   	   	  |
 * +--------------+- Rx Bd  Start (= Z077_BDBASE + Z077_BD_OFFS )
 *
 *
 *</pre></div>For tests with RAM based images do route add -net 192.168.1.0 netmask 255.255.255.0 dev eth0 gw 192.1.1.22<hr><h2>Function Documentation</h2>
<a name="a114" doxytag="men_16z077_eth.c::chipset_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int chipset_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>donegotiate</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the IP core Registers setup the necessary Registers like MODER, BDNUM (used on Z77 only) ans others such that the NIC can completely be restarted if needed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
    <tr><td valign=top><em>donegotiate</em>&nbsp;</td><td><b>IN</b> nonzero if Autoneg. shall be performed</td></tr>
  </table>
</dl>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a110" doxytag="men_16z077_eth.c::cleanup_card"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void cleanup_card </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
remove the NIC from Kernel 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a121" doxytag="men_16z077_eth.c::men_16z077_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int __init men_16z077_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
module init function 
<p>
We are a chameleon unit driver rather than a true standalone Ethernet driver, so all Z77 detection, negotiation and stuff is done at its probe() routine<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code from men_chameleon_register_driver </dd></dl>
    </td>
  </tr>
</table>
<a name="a118" doxytag="men_16z077_eth.c::men_16z077_probe"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int men_16z077_probe </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CHAMELEON_UNIT_T *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>chu</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
men_16z077_probe - PNP function for ETH 
<p>
This gets called when the chameleon PNP subsystem starts and is called for each Eth unit. probe() is called when a 16Z077/87 instance was found<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>chu</em>&nbsp;</td><td><b>IN</b> wdt unit found </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative linux error number </dd></dl>
    </td>
  </tr>
</table>
<a name="a119" doxytag="men_16z077_eth.c::men_16z077_remove"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int men_16z077_remove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CHAMELEON_UNIT_T *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>chu</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
PNP function to remove the unit driver. 
<p>
The netdev struct is kept in struct CHAMELEON_UNIT_Ts private driver data pointer so any number of found netdevs can be freed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>chu</em>&nbsp;</td><td><b>IN</b> IP core unit to remove</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative linux error number </dd></dl>
    </td>
  </tr>
</table>
<a name="a111" doxytag="men_16z077_eth.c::probe_z77"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int __init probe_z77 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check for a network adapter of this type, and return '0' if one exists. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a107" doxytag="men_16z077_eth.c::z77_bd_setup"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_bd_setup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_bd_setup - perform initialization of buffer descriptors this initializes the buffer descriptors such that PCI DMA - ready memory chunks are allocated 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a59" doxytag="men_16z077_eth.c::z77_close"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The inverse routine to <a class="el" href="men__16z077__eth_8c.html#a56">z77_open()</a>. 
<p>
The network interfaces resources are deallocated here<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>error code or 0 on sucess </dd></dl>
    </td>
  </tr>
</table>
<a name="a109" doxytag="men_16z077_eth.c::z77_do_autonegotiation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_do_autonegotiation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do the complete Autonegotiation for the used Ethernet PHY. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a60" doxytag="men_16z077_eth.c::z77_get_stats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct net_device_stats * z77_get_stats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current statistics. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to device status struct </dd></dl>
    </td>
  </tr>
</table>
<a name="a69" doxytag="men_16z077_eth.c::z77_init_phymode"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_init_phymode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>phyAddr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_init_phymode - Set Phy Mode and Flags according to given mode 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
    <tr><td valign=top><em>phyAddr</em>&nbsp;</td><td><b>IN</b> PHY Chip address, one of 0 to 31. Is 1 at EM01</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a74" doxytag="men_16z077_eth.c::z77_ioctl"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_ioctl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct ifreq *&nbsp;</td>
          <td class="mdname" nowrap> <em>ifr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cmd</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
ioctl function - interface to applications 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
    <tr><td valign=top><em>ifr</em>&nbsp;</td><td><b>IN</b> interface request struct </td></tr>
    <tr><td valign=top><em>cmd</em>&nbsp;</td><td><b>IN</b> command</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative linux error number </dd></dl>
    </td>
  </tr>
</table>
<a name="a58" doxytag="men_16z077_eth.c::z77_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> irqreturn_t z77_irq </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
central IRQ handler 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>irq</em>&nbsp;</td><td><b>IN</b> INTB interrupt </td></tr>
    <tr><td valign=top><em>dev_id</em>&nbsp;</td><td><b>IN</b> unique identifier </td></tr>
    <tr><td valign=top><em>regs</em>&nbsp;</td><td><b>IN</b> ancient stuff for register pushing/popping</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>if IRQ was handled or not </dd></dl>
    </td>
  </tr>
</table>
<a name="a56" doxytag="men_16z077_eth.c::z77_open"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_open - open the ethernet device for first usage Open/initialize the Ethernet device. This routine should set everything up anew at each open, even registers that should only need to be set once at boot, so that there is non-reboot way to recover if something goes wrong. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code</dd></dl>
    </td>
  </tr>
</table>
<a name="a70" doxytag="men_16z077_eth.c::z77_pass_packet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_pass_packet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_pass_packet - packet passing function for one ETH frame 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
    <tr><td valign=top><em>idx</em>&nbsp;</td><td><b>IN</b> Rx BD index, 0..Z077_RBD_NUM</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>-ENOMEM if packet squeeze or 0 on success </dd></dl>
    </td>
  </tr>
</table>
<a name="a67" doxytag="men_16z077_eth.c::z77_phy_identify"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_phy_identify </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>phyAddr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_phy_identify - probe the PHY device This routine probes the PHY device by reading its PHY Identifier Register 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
    <tr><td valign=top><em>phyAddr</em>&nbsp;</td><td><b>IN</b> Address of used PHY, currently 1</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>zero if Phy found, otherwise nonzero </dd></dl>
    </td>
  </tr>
</table>
<a name="a68" doxytag="men_16z077_eth.c::z77_phy_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_phy_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_phy_init - initialize and configure the PHY devices This routine scans, initializes and configures PHY devices. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a66" doxytag="men_16z077_eth.c::z77_phy_reset"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_phy_reset </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>phyAddr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_phy_reset This routine send a Reset command to the PHY specified in the parameter phyaddr. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
    <tr><td valign=top><em>phyAddr</em>&nbsp;</td><td><b>IN</b> Address of used PHY, currently 1</td></tr>
  </table>
</dl>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 always </dd></dl>
    </td>
  </tr>
</table>
<a name="a113" doxytag="men_16z077_eth.c::z77_process_rx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_process_rx </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>weight</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_process_rx - process each nonempty Rx BD Without Rx position info determining oldest Rx frame is complicated, several basic situations are possible: 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct of this interface </td></tr>
    <tr><td valign=top><em>weight</em>&nbsp;</td><td><b>IN</b> allowed # of packets to process in a call</td></tr>
  </table>
</dl>
<p>
<div class="fragment"><pre>
 * &lt;-- BD fill direction of Z87 core -----
 * 63      RX1      32 31       RX0      0
 *  --------------------------------------
 * |                  |             oXXXXX|
 *  -------------------------------------^
 * |              oXXX|XXXXXXXXXXXXXX     |
 *  --------------------------------^-----
 * |       oXXXXXXX   |                   |
 *  --------------^-----------------------
 * |XXXXXXX           |                  o|
 *  ------^-------------------------------
 * |XX                |             oXXXXX|
 *  -^------------------------------------
 * |XXXXXXXXXXXXXXXXXX|XX              oXX|
 *  --------------------^-----------------
 * |XX            oXXX|XXXXXXXXXXXXXXXXXXX|
 *  -^------------------------------------
 *
 * ^ = oldest Rx frame in this cycle, which is to be passed to stack first
 * o = position available from new Rx count register 0x70
 *
 * Assumption made: always only one connected region of full BDs ('x') exists
 *
 * simplified Algorithm: 1. skip from Rx BD63 backwards until first full-empty
 *                          transition found. This is oldest Rx BD (startpos)
 *                       2. from startpos skip up and pass every nonempty BD
 *                          to network stack
 * </pre></div><p>
PS: should ever Rx BD organisation change, this needs to be reworked. Code in here implies 64 Rx BDs in 2x32bit Registers!.     </td>
  </tr>
</table>
<a name="a73" doxytag="men_16z077_eth.c::z77_reset"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void z77_reset </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_reset - reset device with asynchronous global Reset Register 0x54 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a112" doxytag="men_16z077_eth.c::z77_reset_task"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void z77_reset_task </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct work_struct *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>work</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Timeout handler when no scheduled ETH irq arrived. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>work</em>&nbsp;</td><td><b>IN</b> handle of work_struct</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>- </dd></dl>
    </td>
  </tr>
</table>
<a name="a117" doxytag="men_16z077_eth.c::z77_retrieve_fpga_name"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_retrieve_fpga_name </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>CHAMELEON_UNIT_T *&nbsp;</td>
          <td class="mdname" nowrap> <em>chamUnit</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_retrieve_fpga_name - get FPGA name of 'this' Z87 
<p>
called to obtain the FPGA filename so special cases like F218 and P511 can be handled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> network device </td></tr>
    <tr><td valign=top><em>chu</em>&nbsp;</td><td><b>IN</b> chameleon unit found</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or -1 on error </dd></dl>
    </td>
  </tr>
</table>
<a name="a62" doxytag="men_16z077_eth.c::z77_rx_err"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void z77_rx_err </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
net_rx_err - irq context handler to report Errors 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a57" doxytag="men_16z077_eth.c::z77_send_packet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_send_packet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct sk_buff *&nbsp;</td>
          <td class="mdname" nowrap> <em>skb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct net_device *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
send a ready made ethernet frame The OpenCore MAC Spec states about transmitting: 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
    <tr><td valign=top><em>skb</em>&nbsp;</td><td><b>IN</b> struct skbuf with data to transmit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 or error code</dd></dl>
<p>
4.2.3 Frame Transmission To transmit the first frame, the RISC must do several things, namely: Store the frame to the memory. Associate the Tx BD in the Ethernet MAC core with the packet written to the memory ( length, pad, crc, etc.).<p>
Enable the TX part of the Ethernet Core by setting the TXEN bit to 1. As soon as the Ethernet IP Core is enabled, it continuously reads the first BD. Immediately when the descriptor is marked as ready, the core reads the pointer to the memory storing the associated data and starts then reading data to the internal FIFO. Atthe moment the FIFO is full, transmission begins. At the end of the transmission, the transmit status is written to the buffer descriptor andan interrupt might be generated (when enabled). Next, two events might occur (according to the WR bit (wrap) in the descriptor):<p>
o If the WR bit has not been set, the BD address is incremented, the next descriptor isloaded, and the process starts all over again (if next BD is marked as ready). o If the WR bit has been set, the first BD address (base) is loaded again. As soon as the BD is marked as ready, transmission will start.     </td>
  </tr>
</table>
<a name="a90" doxytag="men_16z077_eth.c::z77_set_rx_mode"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void z77_set_rx_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Handle multicast and promiscuous mode set. 
<p>
The set_multi entry point is called whenever the multicast address list or the network interface flags are updated. This routine is responsible for configuring the hardware for proper multicast, promiscuous mode, and all-multi behavior.<p>
reminder for the flags: IFF_UP 0x1 interface is up IFF_BROADCAST 0x2 broadcast address valid IFF_DEBUG 0x4 turn on debugging IFF_LOOPBACK 0x8 is a loopback net IFF_POINTOPOINT 0x10 interface is has p-p link IFF_NOTRAILERS 0x20 avoid use of trailers IFF_RUNNING 0x40 interface RFC2863 OPER_UP IFF_NOARP 0x80 no ARP protocol IFF_PROMISC 0x100 receive all packets IFF_ALLMULTI 0x200 receive all multicast packets IFF_MASTER 0x400 master of a load balancer IFF_SLAVE 0x800 slave of a load balancer IFF_MULTICAST 0x1000 Supports multicast IFF_PORTSEL 0x2000 can set media type IFF_AUTOMEDIA 0x4000 auto media select active IFF_DYNAMIC 0x8000 dialup device with changing addresses IFF_LOWER_UP 0x10000 driver signals L1 up IFF_DORMANT 0x20000 driver signals dormant IFF_ECHO 0x40000 echo sent packets<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a108" doxytag="men_16z077_eth.c::z77_setup"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int z77_setup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
z77_setup - perform initialization of buffer descriptors this acts as wrapper that calls the adequate setup function depending on normal DMA use (ethernet frames sent to CPU memory by DMA from IP core) or non DMA use (currently only P511) 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a115" doxytag="men_16z077_eth.c::z77_tx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void z77_tx </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The interrupt context Tx packet handler Called from within main ISR context. unmaps allocated PCI transfer memory region and updates stats info. No spin_lock here because main irq routine does local Eth core IRQ disabling already. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>- </dd></dl>
    </td>
  </tr>
</table>
<a name="a63" doxytag="men_16z077_eth.c::z77_tx_err"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void z77_tx_err </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
net_tx_err - irq context handler to report Errors 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a61" doxytag="men_16z077_eth.c::z77_tx_timeout"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void z77_tx_timeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct net_device *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dev</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Timeout handler when no scheduled ETH irq arrived. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dev</em>&nbsp;</td><td><b>IN</b> net_device struct for this NIC</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>- </dd></dl>
    </td>
  </tr>
</table>

	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for Linux native Driver for 16Z077/87 Ethernet IP cores using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2014 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

