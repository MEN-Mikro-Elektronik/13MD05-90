<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - VME4L API - Accessing VME spaces</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;">
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">VME4L API &nbsp; </h1>
	<h3>Accessing VME spaces</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a name="vme4laccvme">Accessing VME spaces</a>
</h1>To access other boards on the VMEbus, you can either<ul>
<li><a class="el" href="vme4laccvme.html#vme4lmap">Map parts of VME space into user space</a></li><li><a class="el" href="vme4laccvme.html#vme4lapiacc">Use API functions to exchange data with VME</a></li></ul>
<h2><a name="vme4lmap"></a>
Map parts of VME space into user space</h2>
You can map parts of the VME address space into your applications space. This mapped address can then be accessed by normal pointer accesses. The following maps VME standard space addresses 0x10000..0x107FF into the application space and writes 0xAAAA to VME address 0x10004:<p>
<div class="fragment"><pre>  <span class="keywordtype">int</span> spaceFd;
  u16_t *vmeP;

  spaceFd = <a class="code" href="vme4l__api_8c.html#a2">VME4L_Open</a>( VME4L_SPC_A24_D16 );
  <span class="keywordflow">if</span>( spaceFd &lt; 0 ) exit(1);

  <span class="keywordflow">if</span>( <a class="code" href="vme4l__api_8c.html#a13">VME4L_Map</a>( spaceFd, 0x10000, 0x800, &amp;vmeP) &lt; 0 ) exit(1);

  vmeP[2] = 0xaaaa; 
</pre></div><p>
This method is the fastest way to access VME space, since it does not introduce any overhead to switch context to kernel mode (as it would when using the <a class="el" href="vme4l__api_8c.html#a11">VME4L_Read()</a> and <a class="el" href="vme4l__api_8c.html#a12">VME4L_Write()</a> functions).<p>
You should do <a class="el" href="vme4l__api_8c.html#a14">VME4L_UnMap()</a> when you no longer need to access this region. This is automatically done when you perform <a class="el" href="vme4l__api_8c.html#a3">VME4L_Close()</a> or when the program exits.<p>
Note that with <a class="el" href="vme4l__api_8c.html#a13">VME4L_Map()</a> you cannot access the block transfer spaces, you must use the <a class="el" href="vme4l__api_8c.html#a11">VME4L_Read()</a> or <a class="el" href="vme4l__api_8c.html#a12">VME4L_Write()</a> API functions.<p>
Another restriction of this mode is that you will not immediately know whether your VME access was OK or if a VME bus error has occurred. On reads from VME, the data received by the program is just garbage. However, you can install a signal for bus errors, see <a class="el" href="vme4laccvme.html#vme4lberr">Bus error handling during master accesses</a>.<h3><a name="vme4lmapswp"></a>
Swapping on little-endian systems for mapped regions</h3>
On X86 systems, a problem can arise due to the different endian mode of the X86 CPU (little-endian) and the VMEbus. For example if you want to access a byte on VME address 0x10000 in a 16-bit VME space, your program must invert the low-order address bit to the virtual address:<p>
<div class="fragment"><pre>  <span class="keywordtype">int</span> spaceFd;
  u8_t *vmeP;

  <span class="comment">// Error checking omitted in this example</span>
  spaceFd = <a class="code" href="vme4l__api_8c.html#a2">VME4L_Open</a>( VME4L_SPC_A24_D16 );

  <a class="code" href="vme4l__api_8c.html#a13">VME4L_Map</a>( spaceFd, 0x10000, 0x800, &amp;vmeP);

  vmeP[1] = 0xaa; <span class="comment">// Would access VME address 0x10000</span>
  vmeP[0] = 0x55; <span class="comment">// Would access VME address 0x10001 </span>
</pre></div><p>
You can however, use the hardware byte-swapping circuit of the VME bridge in this case. The hardware byte-swapping circuit would correct the address swapping in the above case:<p>
<div class="fragment"><pre>  <span class="keywordtype">int</span> spaceFd;
  u8_t *vmeP;

  <span class="comment">// Error checking omitted in this example</span>
  spaceFd = <a class="code" href="vme4l__api_8c.html#a2">VME4L_Open</a>( VME4L_SPC_A24_D16 );

  <a class="code" href="vme4l__api_8c.html#a5">VME4L_SwapModeSet</a>( spaceFd, VME4L_HW_SWAP1 );
  <a class="code" href="vme4l__api_8c.html#a13">VME4L_Map</a>( spaceFd, 0x10000, 0x800, &amp;vmeP);

  vmeP[0] = 0xaa; <span class="comment">// Would access VME address 0x10000</span>
  vmeP[1] = 0x55; <span class="comment">// Would access VME address 0x10001 </span>
</pre></div><p>
N.B.: The byte-swapping circuit will also swap byte lanes of all 16- and 32-bit accesses to the VMEbus. See <a class="el" href="vme4laccvme.html#vme4lapiswp">Swapping on little-endian systems for API functions</a> .<p>
Note that swapping modes cannot be set (and are not required) on PowerPC.<p>
<dl compact><dt><b>Notes for VME-bridge on A17/A19/A20:</b></dt><dd>TSI148 VME bridge does not support hardware swapping! User application has to care for swapping by its own!</dd></dl>
<h2><a name="vme4lapiacc"></a>
Use API functions to exchange data with VME</h2>
Instead of <a class="el" href="vme4l__api_8c.html#a13">VME4L_Map()</a>, you can also use <a class="el" href="vme4l__api_8c.html#a11">VME4L_Read()</a> or <a class="el" href="vme4l__api_8c.html#a12">VME4L_Write()</a> to transfer data between the VME space and user space.<p>
Using the API functions is necessary whenever you need to access VME block transfer spaces (spaces ending with <code>_BLT</code>).<p>
In addition, these calls report whether a VMEbus error has occurred or not.<p>
But for non-BLT spaces these functions are relatively slow compared to accesses done from regions mapped by <a class="el" href="vme4l__api_8c.html#a13">VME4L_Map()</a> due to additional bus error checking after each access.<p>
The following example reads a data block from VME standard space, address 0x20000 to the user buffer using programmed I/O (i.e. non-DMA):<p>
<div class="fragment"><pre>  uint8_t buf[0x800];
  <span class="keywordtype">int</span> spaceFd;

  <span class="comment">// Error checking omitted in this example</span>
  spaceFd = <a class="code" href="vme4l__api_8c.html#a2">VME4L_Open</a>( VME4L_SPC_A24_D16 );

  <span class="comment">// Transfer width=2 bytes</span>
  <a class="code" href="vme4l__api_8c.html#a11">VME4L_Read</a>( spaceFd, 0x20000, 2, 0x800, buf, VME4L_RW_NOFLAGS); 
</pre></div><h3><a name="vme4lapiswp"></a>
Swapping on little-endian systems for API functions</h3>
On X86 systems, the same endian problems arise as described above for regions mapped via <a class="el" href="vme4l__api_8c.html#a13">VME4L_Map()</a>.<p>
However, you can use either<ul>
<li>the hardware byte-swapping circuit of the VME bridge or (<a class="el" href="group__VME4L__SWAPMODE.html#a1">VME4L_HW_SWAP1</a>)</li><li>software address swapping (<a class="el" href="group__VME4L__SWAPMODE.html#a2">VME4L_SW_ADR_SWAP</a>).</li></ul>
<p>
Pass these flags to <a class="el" href="vme4l__api_8c.html#a5">VME4L_SwapModeSet()</a>.<p>
<code>VME4L_SW_ADR_SWAP</code>: Corrects the address offsets for byte accesses.<p>
<code>VME4L_HW_SWAP1</code>: Same effect as <code>VME4L_SW_ADR_SWAP</code> but also swaps byte-lanes of all 16- and 32-bit accesses.<p>
The <code>VME4L_HW_SWAP1</code> flag is also used for DMA transfers; the <code>VME4L_SW_ADR_SWAP</code> however has no effect on DMA, since DMA always accesses the VME space with its maximum possible witdth.<h2><a name="vme4la32"></a>
Restrictions in VME extended (A32) space</h2>
Since the VME A32 space occupies 4GB, only a part of this space is accessible by the CPU at any given time.<p>
Functions <a class="el" href="vme4l__api_8c.html#a11">VME4L_Read()</a>/VME4L_Write() and <a class="el" href="vme4l__api_8c.html#a13">VME4L_Map()</a> program a hardware address window according to the specified parameters and then lock this hardware address window. Locking a hardware address window does not mean that it is reserved and therefore cannot be used by other processes. It simply means the hardware address window cannot be altered by other processes. Therefore, multiple processes can map different address ranges in the same hardware address window as long as the current settings of that hardware address window are acceptable to all the processes using it.<p>
If none of the already locked hardware address windows is usable for the specified parameters and if no more unlocked hardware address windows are available, the functions return with <em>errno</em> set to <code>EBUSY</code>.<p>
<dl compact><dt><b>Notes for VME-bridge on A13/A15:</b></dt><dd>The A32 windows map 512MB of VME space into the PCI space, therefore you can address different VME devices in A32 space as long as the upper three bits of each VME address are identical.</dd></dl>
<h2><a name="vme4lberr"></a>
Bus error handling during master accesses</h2>
When an application calls <a class="el" href="vme4l__api_8c.html#a11">VME4L_Read()</a> or <a class="el" href="vme4l__api_8c.html#a12">VME4L_Write()</a>, bus errors are reported by return value and <em>errno</em> is set to <code>EIO</code>.<p>
<dl compact><dt><b>Notes for VME-bridge on A17/A19/A20:</b></dt><dd>Since posted writes cannot be disabled, it's not guaranted to detect bus errors at <a class="el" href="vme4l__api_8c.html#a12">VME4L_Write()</a>.</dd></dl>
However, whenever direct accesses through mapped VME space (either in userland or kernel) are performed, the calling application will not know that a bus error has ocurred.<p>
The userland program, however can check if a bus error has occurred using <a class="el" href="vme4l__api_8c.html#a23">VME4L_BusErrorGet()</a> or it can install a signal (using <a class="el" href="vme4l__api_8c.html#a15">VME4L_SigInstall()</a>) that is sent on VME bus errors.<p>
<b>But N.B.</b>: The bus error information is global for the entire VME bridge, you will not know which process or which kernel module has produced the bus error!<p>
More than one process can install a signal for bus errors. If any bus error occurs, all registered processes will be informed. The bus error signal will be suppressed when the bus error was caused by a <a class="el" href="vme4l__api_8c.html#a11">VME4L_Read()</a> or <a class="el" href="vme4l__api_8c.html#a12">VME4L_Write()</a> call (in PIO or DMA mode).<h2><a name="vme4lpostwr"></a>
Posted Write Mode</h2>
Writes to VMEbus can be performed in two modes:<ul>
<li>Delayed write mode (default): PCI access will wait for VME transfer to finish.</li><li>Posted write mode: PCI access will finish immediately after passing data to the VME bridge.</li></ul>
<p>
This mode influences only access from memory-mapped regions (either in userland or kernel). VME4_Write() always disables posted writes temporarily.<p>
Posted write mode can be enabled or disabled by calling <a class="el" href="vme4l__api_8c.html#a27">VME4L_PostedWriteModeSet()</a>.<p>
The posted write mode will speed up writes to VMEbus, but this can be dangerous, since you don't know exactly when the actual VME transfer is performed.<p>
The write mode is a global setting for all address spaces of the VME bridge, so enabling posted write mode can also influence the behavior of kernel drivers that access the VMEbus.<p>
<b>Do not enable posted write mode unless you are absolutely sure what you are doing!</b><p>
<dl compact><dt><b>Notes for VME-bridge on A17/A19/A20:</b></dt><dd>Posted writes cannot be disabled at TSI148 (see chapter "PCI Transactions" in "Tsi148 PCI/X-to-VME Bus Bridge User Manual").</dd></dl>
<h2><a name="vme4lreq"></a>
Controlling VME requester</h2>
VMEbus request mode can be controlled by <a class="el" href="vme4l__api_8c.html#a25">VME4L_RequesterModeSet()</a>. The requester can be set to Release-when-done or Release-on-Request. 
	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for VME4L API using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2019 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

