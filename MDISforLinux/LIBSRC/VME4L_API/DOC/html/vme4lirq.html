<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - VME4L API - VME interrupt handling in user space</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;">
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">VME4L API &nbsp; </h1>
	<h3>VME interrupt handling in user space</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a name="vme4lirq">VME interrupt handling in user space</a>
</h1>With VME4L, it is possible to handle interrupts from VMEbus in Linux userland. VMEbus interrupts are forwarded as Linux signals from the VME4L driver to the userland process.<p>
The handling depends on the interrupt release mode used for that interrupt:<ul>
<li><b>Release on register access (RORA)</b><br>
 In this mode, which is the default, the VME4L driver masks the corresponding interrupt level and sends the signal to the userland process. The userland process' signal handler must clear the interrupt by writing to a device-specific register and must then re-enable the interrupt level.</li><li><b>Release on acknowledge (ROAK)</b><br>
 In this mode, the interrupt is implicitly cleared by the VMEbus IACK cycle. Therefore the VME4L driver will not mask this level before it sends the signal to the process.</li></ul>
<p>
To install a signal for a VME interrupt, you call <a class="el" href="vme4l__api_8c.html#a15">VME4L_SigInstall()</a>.<p>
You have to pass information on the interrupt release mode to the VME4L driver by setting or clearing the <a class="el" href="group__VME4L__IRQFLAGS.html#a1">VME4L_IRQ_ROAK</a> flag in the <em>flags</em> parameter of <a class="el" href="vme4l__api_8c.html#a15">VME4L_SigInstall()</a>.<p>
The VMEbus interrupt level is automatically enabled by <a class="el" href="vme4l__api_8c.html#a15">VME4L_SigInstall()</a>, when <a class="el" href="group__VME4L__IRQFLAGS.html#a2">VME4L_IRQ_ENBL</a> is passed to the <em>flags</em> parameter, otherwise the level must be explicitly enabled by calling <a class="el" href="vme4l__api_8c.html#a17">VME4L_IrqEnable()</a>.<p>
Example to install and handle VME interrupts: <div class="fragment"><pre>  <span class="comment">// Error checking omitted in this example</span>
<span class="preprocessor">  #include &lt;stdio.h&gt;</span>
<span class="preprocessor">  #include &lt;stdlib.h&gt;</span>
<span class="preprocessor">  #include &lt;string.h&gt;</span>
<span class="preprocessor">  #include &lt;stdint.h&gt;</span>
<span class="preprocessor">  #include &lt;signal.h&gt;</span>
<span class="preprocessor">  #include &lt;errno.h&gt;</span>
<span class="preprocessor">  #include &lt;unistd.h&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="vme4l_8h.html">MEN/vme4l.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="vme4l__api_8h.html">MEN/vme4l_api.h</a>&gt;</span>

  <span class="keywordtype">int</span> G_fd;
  <span class="keyword">volatile</span> uint8_t *G_map;

  <span class="keyword">static</span> <span class="keywordtype">void</span> IrqSigHandler( <span class="keywordtype">int</span> sigNum ) {
      G_map[0x80] = 0x20; <span class="comment">// Service interrupt (device specific)</span>

      <a class="code" href="vme4l__api_8c.html#a17">VME4L_IrqEnable</a>( G_fd, 3 ); <span class="comment">// Re-enable interrupt level</span>
  }

  <span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )
  {
      G_fd = <a class="code" href="vme4l__api_8c.html#a2">VME4L_Open</a>( VME4L_SPC_A24_D16 );


      <a class="code" href="vme4l__api_8c.html#a13">VME4L_Map</a>( G_fd, 0x10000, vmeOff + 0x800, (<span class="keywordtype">void</span> **)&amp;G_map );

      <span class="comment">// Instruct VME4L to send signal 33 on interrupt</span>
      signal( 33, IrqSigHandler );

      <span class="comment">// Install vector 121, level 3</span>
      <a class="code" href="vme4l__api_8c.html#a15">VME4L_SigInstall</a>( G_fd, 121, 3, 33, VME4L_IRQ_NOFLAGS );

      <span class="comment">// Prepare your device for interrupts...</span>
      ...

      <a class="code" href="vme4l__api_8c.html#a17">VME4L_IrqEnable</a>( G_fd, 3 );       <span class="comment">// enable interrupt level</span>

      <span class="comment">// Let signals come in</span>
      <span class="keywordflow">while</span>(1)
          sleep(10);

  } 
</pre></div><p>
Notes and Restrictions:<ul>
<li>The same VME vector shall not be shared between userland process and kernel modules.</li><li>The same VME level shall not be shared between userland process and kernel modules (as it may result in long delays for the kernel modules' interrupt handler).</li><li>The same signal can be installed for the same process for different vectors. </li></ul>

	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for VME4L API using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2019 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

