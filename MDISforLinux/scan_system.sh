#!/bin/bash
############################################################################
#
# scan_system.sh   script to generate an automatic MDIS configuration
#                  when doing a selfhosted project
#
#                  The script checks which CPU we are on. The SMB2 drivers
#                  are always added to the CPU to provide BMC and watchdog
#                  drivers.
#
#                  Some simplifications were made to make generating the
#                  system.dsc easier:
#                  - BBIS instances are numbered in straight ascending order.
#                    E.g. if 2xF208, 2xF210 are present they are not labeled
#                    like by MDIS wizard: f208_1, f208_2, f210_1, f210_2
#                    but instead: f208_1,f208_2,f210_3,f210_4.
#                  - the same is done with MDIS devices.
#
# parameters:
# $1    MEN_LIN_DIR   path to MDIS installation, passed by mdiswizard
#                     (if script is run manually it must be passed)
# $2    verbosity     if "1" then additional debug info is dumped
# $3    PCI drytest   if passed as alternative PCI devices temp file the
#                     default file /tmp/men_pci_devs is not written. Used to
#                     test system.dsc generation with predefined test data.
############################################################################
# Copyright 2013-2020, MEN Mikro Elektronik GmbH
############################################################################

##########
# DEFINES
readonly CREATION_NOTE="Generated by scan_system.sh script version: "
#            <commit_id>
#            <date>

# where the linux kernel sources/headers are expected
LIN_SRC_DIR=/usr/src/linux
# where are the SMBus controller drivers located?
MOD_DIR=/lib/modules/$(uname -r)

#default path for Makefile/system.dsc creation
OUTPUT_DIR_PATH=$(pwd)
# currently detected CPU boards. ADD NEW BOARDS HERE!
# also take care for special (native) driver adding etc.
CPU_KNOWN_BOARDS="CB70 SC25 SC24 SC31 F011 F11S F14- F014 F15- F015 F17- F017 F075 F75P F19P F19C F019 F21P F22P F23P F21C F021 F026 XM01 MM01 G20- G22- G022 G22A G23- G23A G25- G25A G025 A025"

# which SMB adresses to scan for CPU ID eeproms
ID_EEPROM_ADRESSES="0x57 0x55"
# the generated example system dsc
DSC_FILE=system.dsc  #.example
# the generated example Makefile
MAKE_FILE=Makefile   #.example
# the generated example Makefile
TMP_MAKE_FILE=/tmp/Makefile   #.example
# temporary BBIS section file to add BBIS data first, then DEVICE_IDV2_x data
TMP_BBIS_DSC=/tmp/bbis.dsc.tmp
# temporary PCI device file to iterate through
TMP_PCIDEVS=/tmp/men_pci_devs.tmp
# temporary chameleon table file to scan IPcore IDs
TMP_CHAM_TBL=/tmp/men_cham_tbl.tmp
# temporaty F205 devices file
TMP_F205_DSC=/tmp/men_f205.dsc.tmp
# fpga_load to use (32/64 bit)
# (Mind: without ia32 lib 32bit programs cant run under 64bit)
FPGA_LOAD=fpga_load
# mm_ident to use
MM_IDENT=mm_ident
# debugging/verbosity: 0=none, 1=verbose 2=verbose+function arguments
VERBOSE_PRINT=0
# run drytest with test PCI device list ?
PCI_DRYTEST=""


# really writing pcitree/temp. cham table or use simulation data ?
# 0 = normal operation, scan and write PCI devices
# 1 = use predefined /tmp/men_pci_devs.tmp file to run tests
SCAN_SIM=0

# for simulation add here which SMBus and CPU shall be assumed
SCAN_SIM_SMBUS=0
SCAN_SIM_CPU="MM01"

#########
# GLOBALS

# MDIS instance label
G_mdisInstanceCount=1

# CPU on which we run, detected in ID EEprom on SMbus <G_SmBusNumber>
G_cpu=""
G_SmBusNumber=0
G_SmbDeviceSlotNumber=0 
# PCI_BUS_xxx entries for all MDIS devs within one chameleon BBIS device.
G_bus_slot_count=0
G_primPciPath=0

# counting PCI_BUS_SLOT number for cPCI Standard cards like F210. Begins per
# default at 2 (1 = system slot)
G_cPciRackSlotStandard=2

# counting PCI_BUS_SLOT number for cPCI Serial cards like G215
# default at 2 (1 = system slot)
G_cPciRackSlotSerial=2

# number of detected F205 like carrier boards
G_cF205=0

# lists for driver/library/program mak files
G_makefileLlDriver=""
G_makefileLlTool=""
G_makefileBbisDriver=""
G_makefileNatDriver=""
G_makefileUsrLibs=""
G_makefileCommonTools=""
G_mdisExtraDefs=""
# DEVICE_IDV2_xx list
G_deviceIdV2=""
# SMB device list 
G_smbDeviceList=""
# list of all used makefiles so far
G_makefileUniqList=""

### @brief M-Module specification map
declare -A mmodSpecList
### @brief M-Moudle instance counters
declare -A mModuleInstances=()
### @brief IP Core ID to XML file map
declare -A ipcoreFileList
### @brief IP Core specification map list
declare -a ipcoreSpecList=()
### @brief MDIS driver specification map list
declare -A mdisDriverSpecList
### @brief MDIS VME driver specification map list
declare -A mdisVMESpecList

### @brief script usage --help
scan_system_usage () {
    echo "scan_system.sh - generate MDIS configuration for a selfhosted project"
    echo ""
    echo "USAGE"
    echo "    scan_system.sh -h | --help"
    echo "    scan_system.sh <DIRECTORY>"
    echo "    scan_system.sh <DIRECTORY> [-y] [-p PATH] [--verbose LEVEL] [--drytest FILE]"
    echo "                   [--buildtools] [--internal-submodules]"
    echo "    scan_system.sh --prerequisites"
    echo ""
    echo "DESCRIPTION"
    echo "    scan_system.sh scans the system to detect all MDIS hardware. The"
    echo "    configuration is then written to system.dsc and Makefile files."
    echo ""
    echo "OPTIONS"
    echo "    DIRECTORY"
    echo "        Path to MDIS installation directory. The default is /opt/menlinux"
    echo ""
    echo "    -y, --yes, --assume-yes"
    echo "        Scan without user interaction. Answer 'yes' for all questions."
    echo ""
    echo "    -p PATH, --path=PATH"
    echo "        Overwrite default path for Makefile and system.dsc creation"
    echo ""
    echo "    --mdiswiz"
    echo "        Used by mdiswiz only!"
    echo ""
    echo "    --verbose LEVEL"
    echo "        Print additional debug info. Possible values for LEVEL are:"
    echo "        1 - verbose output"
    echo "        2 - verbose and function arguments output"
    echo ""
    echo "    --buildtools"
    echo "        Build mm_ident and fpga_load tools from source"
    echo ""
    echo "    --drytest FILE"
    echo "        Run dry test with test PCI device list if passed as alternative PCI"
    echo "        devices temporary file. The default file /tmp/men_pci_devs is not"
    echo "        written. Used to test system.dsc generation with predefined test data."
    echo ""
    echo "    --prerequisites"
    echo "        Check if all prerequisites are met"
    echo ""
    echo "    --internal-swmodules"
    echo "        Also add internal software modules"
    echo ""
    echo "    -h, --help"
    echo "        Print this help"
    echo ""
    echo "IMPORTANT"
    echo "    1. Following tools must be available in the system: i2cdump, setpci, lspci,"
    echo "       libelf-dev or libelf-devel"
    echo "    2. /usr/src/linux has to point to valid kernel headers directory"
}

############################################################################
# get absolute path from relative path
#
# parameters: $1 relative path
# return absolute path
get_abs_path () {
    local path="${1}"
    pathStart=""
    case "${path}" in "~/"*)
        pathStart="${HOME}/"
        path="${path/"~/"/}"
    esac
    path="$(realpath -m "${pathStart}""${path}")"
    echo "${path}"
}

############################################################################
# verbose debug outputs if VERBOSE_PRINT is 1 or 2
#
# parameters: $1 text to print
#
debug_print () {
    if [ "${VERBOSE_PRINT}" == "1" ]; then
        echo "${1}"
    elif [ "${VERBOSE_PRINT}" == "2" ]; then
        echo "${1}"
    fi
}

############################################################################
# verbose debug outputs if VERBOSE_PRINT is 2
#
# parameters: $1 text to print
#
debug_args () {
    if [ "${VERBOSE_PRINT}" == "2" ]; then
        echo "${1}"
    fi
}

############################################################################
# determine if an ID EEprom content is really a MEN CPU. A check if the
# characters are ASCII isnt enough because from DDC ports or other bitbang
# interfaces any char salad might be returned. Save approach: check
# explicitely for our CPU names
#
# parameters: $1     found string
#
check_if_men_cpu () {
    local detectedCpu=${1}
    for i in ${CPU_KNOWN_BOARDS};
    do
    debug_print "\$i = ${i}  detectedCpu = ${detectedCpu}"
    if [ "${i}" == "${detectedCpu}" ]; then
        G_cpu=$i;
        debug_print "found matching CPU: ${i}"
        break
    else
        G_cpu="";
    fi
    done
}

############################################################################
# scan for production data EEPROM to find out who we are
#
# parameters: N/A
#
detect_board_id () {
    echo "Scanning for MEN ID EEProm"
    # these can be safely assumed to exist on any recent distribution.
    modprobe i2c-dev   # for i2cdetect
    modprobe i2c-i801  # F1x SMB controllers

    # these might not exist on all Distros
    if [ -e "${MOD_DIR}/kernel/drivers/i2c/busses/i2c-isch.ko" ]; then
        modprobe i2c-isch
    fi
    if [ -e "${MOD_DIR}/kernel/drivers/i2c/busses/i2c-piix4.ko" ]; then
        modprobe i2c-piix4 # SC24 SMB controller. Use 13SC24-90 modified driver!
    fi

    G_cpu=""
    for adrs in ${ID_EEPROM_ADRESSES}; do
        for dev in /dev/i2c-*; do
            smbus=$(echo "${dev}" | awk '{print substr($1,10,2)}')
            # scan for ID EEprom 0x55 at every present bus
            debug_print "scan SMBus: bus ${smbus} SMB addr ${adrs}"
            RES=$(i2cdump -r 9-12 -y "${smbus}" "${adrs}" b | tail -n 1 | awk '{print $6}')

            check_if_men_cpu "${RES}"

            if [[ "${SCAN_SIM}" == "1" && "${smbus}" == "${SCAN_SIM_SMBUS}" ]]; then
                G_cpu=${SCAN_SIM_CPU}
                debug_print "- simulating CPU ${G_cpu} on bus ${smbus}"
                break
            fi
            # board found ? break inner loop
            if [ "${G_cpu}" != "" ]; then
                break
            fi
        done;

    # board found ? break outer loop
    if [ "${G_cpu}" != "" ]; then
        break
    fi
    done

    if [ "${G_cpu}" == "" ]; then
        echo "*** could not find CPU type or no ID EEprom present!"
    exit 1
    fi
}


############################################################################
# Map SC24 FPGA (in case old BIOS is present)
# the IRQ settings are switched on loading BBIS driver
#
# parameters: N/A
#
map_sc24_fpga () {
    echo "SC24 detected, mapping FPGA"
    # PCI location is fixed (inside AMD chipset)
    setpci -s 00:14.3 0x48.B=0x27
    setpci -s 00:14.3 0x60.B=0x00
    setpci -s 00:14.3 0x61.B=0xe0
    setpci -s 00:14.3 0x62.B=0x01
    setpci -s 00:14.3 0x63.B=0xe0
}


############################################################################
# write the smb section for the cpu in the system.dsc
#
# parameters:
# $1    DSC template directory
# $2    SM Bus number
# $3    SMB driver, e.g. SMBPCI_ICH
# $4    SMB bus IF nr "cpu,0' or "cpu,1" etc
#
create_entry_dsc_smb_type () {
    debug_print "Writing CPU SMB BBIS section"
    #echo " _WIZ_MODEL = $3, SM Bus nr. = $2  SM Bus IF nr. = $4 "
    < "${1}/smb.tpl" sed "s/SCAN_SMBDRV/${3}/g; s/SCAN_SMBNR/$(printf 0x%x "${2}")/g; s/SCAN_SMBUSIF/${4}/g;" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
}

############################################################################
# write the smb devices list into smb section for the cpu
#
# parameters:
# None
#
fill_entry_dsc_smb_scan_list () {
    debug_print "fill smb devices scan list into system.dsc file"
    local dscTmpFile
    local formattedSmbDeviceList
    dscTmpFile=$(<"${OUTPUT_DIR_PATH}/${DSC_FILE}")
    formattedSmbDeviceList=$(echo "${G_smbDeviceList}" | sed ':a;N;$!ba;s/\n/\\n/g' )
    dscTmpFile=$(echo -e "${dscTmpFile}" | sed "s/SCAN_LIST_OF_SMB_DEVICES/${formattedSmbDeviceList}/g")
    echo "${dscTmpFile}" > "${OUTPUT_DIR_PATH}/${DSC_FILE}"
}

############################################################################
# add smb single device into list of smb devices
#
# parameters:
# $1    DSC template directory
# $2    SMB device number
# $3    SMB device name 
#
add_device_smb_scan_list () {
    debug_print "add_device_smb_scan_list"
    local tmpSmbDeviceList
    tmpSmbDeviceList=$(<"${1}/smb_device.tpl" sed "s/SCAN_SMB_DEV_NUMBER/${2}/g;s/SCAN_SMB_DEV_NAME/${3}/g")
    # new line is not required for the first device    
    if [ "${2}" == "0" ]; then
        G_smbDeviceList+="${tmpSmbDeviceList}"
    else
        G_smbDeviceList+="\n${tmpSmbDeviceList}"
    fi
}

############################################################################
# write the smb section for the cpu in the system.dsc
#
# parameters:
# $1    DSC template directory
# $2    SCAN_MDIS_INSTANCE nr of found PP04
# $3    SCAN_BBIS_INSTANCE carrier boards instance
#
create_entry_dsc_pp04 () {
    debug_print "Writing PP04 MDIS driver section"
    #echo " _WIZ_MODEL = $3, SM Bus nr. = $2  SM Bus IF nr. = $4 "
    < "${1}/pp04.tpl" sed "s/SCAN_MDIS_INSTANCE/${2}/g;s/SCAN_BBIS_INSTANCE/${3}/g" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
    if [ "${2}" == "1" ]; then
        add_mdis_drivers "PP04"
    fi
}

############################################################################
# write a SMB driver section
#
# parameters:
# $1    DSC template directory
# $2    SM Bus number
# $3    MDIS device name, e.g. xm01bc_1 or smb2_2
# $4    HW_TYPE, e.g. XM01BC (not always the capitalized MDIS dev. type
# $5    WIZ_MODEL
#
create_entry_dsc_smb_drv () {
    debug_print "creating CPU SMB driver section: _WIZ_MODEL = ${3}, SM Bus nr. = ${2} at DEVICE_SLOT = ${6}"

    if [ "${3}" == "smb2_1" ]; then
        < "${1}/smb_drv_no_addr.tpl" \
        sed "s/SCAN_DEVNAME/${3}/g;s/SCAN_HWTYPE/${4}/g;s/SCAN_WIZMODEL/${5}/g;s/SCAN_SMBNR/$(printf 0x%x "${2}")/g;s/SCAN_DEVICE_SLOT/$(printf 0x%x "${6}")/g" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
    else
        < "${1}/smb_drv.tpl" \
        sed "s/SCAN_DEVNAME/$3/g;s/SCAN_HWTYPE/${4}/g;s/SCAN_WIZMODEL/${5}/g;s/SCAN_SMBNR/$(printf 0x%x "${2}")/g;s/SCAN_DEVICE_SLOT/$(printf 0x%x "${6}")/g" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
    fi
}

############################################################################
# write the cpu section of the system.dsc file
#
# parameters:
# $1    DSC template directory
# $2    _WIZ_MODEL
#
create_entry_dsc_cpu_type () {
    debug_print "Writing system.dsc cpu section: _WIZ_MODEL = ${2}"
    < "${1}/cpu.tpl" sed "s/SCAN_CPU/${2}/g" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
}


############################################################################
# write a chameleon BBIS section
#
# parameters:
# $1 DSC template directory
# $2 BBIS instance number  (subst. SCAN_BBIS_INSTANCE )
# $3 _WIZ_MODEL, e.g. F210 (subst. SCAN_WIZ_MODEL   )
# $4 PCI bus number        (subst. SCAN_PCI_BUS_NR  )
# $5 PCI device nr..       (subst. SCAN_PCI_DEV_NR  )
# $6 DEVICE_IDV2_x array of found IP cores inside this BBIS device
#
# Addendum 05/2015: With the new unified generic mezz_cham carrier we must check
# if its a cPCI Serial card (G2xx, e.g. G215) or a parallel cPCI card like F2xx.
# Based on this the position can be rougly estimated on the FPGA file name:
#  
#  Example entries for a hybrid backplane: 
#
#  standard cPCI slots          cPCI Serial slots
#   
# cpu,1 cpu,1 cpu,1 cpu,1       cpu,2 cpu,3 cpu,4 cpu,5      <- _WIZ_BUSIF = STRING ...  
#   5     4     3     2    SYS    2     3     4     5        <- PCI_BUS_SLOT = U_INT32 ...
#  ---   ---   ---   ---   ---   
#  | |   | |   | |   | |   | | 
#  | |   | |   | |   | |   | | 
#  | |   | |   | |   | |   | | 
#  | |   | |   | |   | |   | |  
#  | |   | |   | |   | |   | |   ----  ----  ----  ----
#  | |   | |   | |   | |   | |   |  |  |  |  |  |  |  |
#  ---   ---   ---   ---   ---   ----  ----  ----  ----  
#
#  This results in the following algorithm described below. In this script we can 
#  not detect the true physical slots, so we assign just incrementing slots according to
#  each card type (cPCI serial, standard cPCI)
#
create_entry_dsc_bbis_cham () {
    echo "create chameleon BBIS device - based on lspci data"
    debug_args " \$1 = ${1}  \$2 = ${2}  \$3 = ${3}  \$4 = ${4}  \$5 = ${5}  \$6 = ${6} \$7 = ${7}"

    local pci_vd
    local pci_dev
    local pci_devnr=${3}
    local pci_subv
    local tpl_dir=${5}
    local pci_busnr=${6}
    local wiz_mod="MEZZ_CHAM"
    local lspci_device_ident
    local lspci_device_verbose_data
    local is_pcie
    local mezz_cham_instance=${7}
    pci_vd="${1//0x/}"
    pci_dev="${2//0x/}"
    pci_subv="${4//0x/}"

    # it is assumed that devices with the same Ven ID, Dev ID and SubVen ID
    # are the same type (cPCI or cPCI-serial)
    if ! lspci_device_ident=$(lspci -d "${pci_vd}":"${pci_dev}" -m 2>/dev/null)
    then
        echo "*** error: lspci -d ${pci_vd}:${pci_dev} -m 2>/dev/null"
        exit 1
    fi

    lspci_device_ident=$(echo "${lspci_device_ident}" | grep "${pci_subv}" | cut -f 1 -d " "| awk NR==1)
    if ! lspci_device_verbose_data=$(lspci -s "${lspci_device_ident}" -v 2>/dev/null)
    then
        echo "*** error: lspci -s ${lspci_device_ident} -v 2>/dev/null"
        exit 1
    fi

    is_pcie=$(echo "${lspci_device_verbose_data}" | grep "Capabilities.*Express Legacy Endpoint")

    debug_args "${lspci_device_verbose_data}"
    if [ -z "${is_pcie}" ]; then
        debug_print "Device: ${pci_vd}:${pci_dev} PCI subvendor: ${pci_subv} is CPCI device"
        local pcibus_slot=${G_cPciRackSlotStandard}
        # for standard cPCI always
        local bus_if="cpu,1"
        # count to next stndard cPCI slot nr
        G_cPciRackSlotStandard=$((G_cPciRackSlotStandard + 1))
    else
        debug_print "Device: ${pci_vd}:${pci_dev} PCI subvendor: ${pci_subv} is CPCI serial device"
        local pcibus_slot=${G_cPciRackSlotSerial}
        # on cPCI serial the businterface nr. is equal to its slot
        # what about boards that are connected to CPU board?
        local bus_if="cpu,"${G_cPciRackSlotSerial}
        # count to next cPCI serial slot nr.
        G_cPciRackSlotSerial=$((G_cPciRackSlotSerial + 1))
    fi

    # no support for "MM01-IC..."
    local tpl_name=mezz_cham.tpl

    # TODO generate the long filter commands dynamically..
    < "${tpl_dir}/${tpl_name}" sed "s/SCAN_BBIS_INSTANCE/${mezz_cham_instance}/g;s/SCAN_WIZ_MODEL/${wiz_mod}/g;s/SCAN_WIZ_BUSIF/${bus_if}/g;s/SCAN_PCI_BUS_NR/$(printf 0x%x "${pci_busnr}")/g;s/SCAN_PCI_BUS_SLOT/$(printf 0x%x "${pcibus_slot}")/g;s/SCAN_PCI_DEV_NR/$(printf 0x%x "${pci_devnr}")/g" > "${TMP_BBIS_DSC}"
}

############################################################################
# write all MDIS device sections for the detected BBIS entry (cham device)
#
# The scan of IPcore entries per chameleon device is done 2 times, first to
# just collect DEVICE_IDV2 data to write the BBIS section in system dsc,
# then also to generate every MDIS device section. The BBIS section
#
# parameters:
# $1  DSC template directory
# $2  FPGA file name, e.g. 'F210'
# $3  BBIS board instance number ( x as in f210_x)
# $4  0: just get DEVICE_IDV2 data (to complete BBIS dsc entry)
#     1: also write MDIS dsc data  (to add device sections below BBIS entry)
# $5  PCI device
#
scan_cham_table () {
    debug_args "\$1 = ${1} \$2 = ${2} \$3 = ${3} \$4 = ${4} "
    local fpga_file=${2}
    local bbis_instance=${3}
    local do_parse=0
    local write_mdis_dsc=${4}
    local ipcoreId
    local ipcoreXml
    local ipcoreType
    local ipcoreName
    local ipcoreHwName
    local ipcoreSettings
    local -i listSize
    local -i listItem
    local -a listChoice
    local -i i
    local listName
    local listEntry
    local listPrompt
    local itemMatch
    local hwName

    while read -r devline <&3; do
    if [ "${do_parse}" == "1" ]; then
        ipcore=$(echo "${devline}" | awk '{print $3}')
        devid=$(echo "${devline}" | awk '{print $2}' | awk '{print substr($1,5,2)}')
        inst_raw=$(echo "${devline}" | awk '{print $5}')
        instance=$(printf "%02x" "${inst_raw}")

        makeIpCoreFileMap
        ipcoreId="$((16#${devid}))"
        ipcoreXml="${ipcoreFileList["${ipcoreId}"]}"
        if [ "${ipcoreXml}" == "" ]; then
             debug_print "is_cham_dev=0"
        fi

        if [ "${ipcoreXml}" != "" ] ; then
            G_deviceIdV2+=" 0x${devid}${instance}"
            if [ "${write_mdis_dsc}" == "1" ]; then
                makeIpCoreOutputData "${ipcoreId}"
                listItem="0"
                listChoice=()
                listSize="${#ipcoreSpecList[@]}"
                if [ "${listSize}" -gt "1" ]; then
                    itemMatch=""
                    for (( i=0; i<listSize; i++ )); do
                        listName="${ipcoreSpecList[${i}]}"
                        hwName="$(mapGet "${listName}" "hwname")"
                        if [ "${hwName}" == "${ipcore}" ]; then
                            if [ "${itemMatch}" == "" ]; then
                                itemMatch="${i}"
                            else
                                itemMatch=""
                                break
                            fi
                        fi
                    done
                    if [ "${itemMatch}" != "" ]; then
                        listItem="${itemMatch}"
                    else
                        for (( i=0; i<listSize; i++ )); do
                            listName="${ipcoreSpecList[${i}]}"
                            listEntry="$(mapGet "${listName}" "hwname")"
                            listEntry+=" - $(mapGet "${listName}" "description")"
                            listChoice+=("${listEntry}")
                        done
                        listPrompt="There are ${listSize} drivers matching IP core ${ipcore} #${inst_raw} on PCI device ${5}"
                        listPrompt+=$'\n'
                        listPrompt+="Which one would you like to use?"
                        displayQuestion "${listPrompt}" "${listChoice[@]}"
                        listItem="${?}"
                    fi
                fi
                if [ "${listItem}" -ge "${listSize}" ]; then
                    echo "*** Aborted by user"
                    exit "1"
                fi

                listName="${ipcoreSpecList[${listItem}]}"
                bbis_name=$(echo "${fpga_file}" | awk '{print tolower($1)}')
                ipcoreType="$(mapGet "${listName}" "devnameprefix")"
                ipcoreHwName="$(mapGet "${listName}" "hwname")"
                ipcoreName="$(mapGet "${listName}" "name")"
                if [ "${ipcoreName}" == "" ]; then
                    ipcoreName="$(mapGet "${listName}" "swname")"
                fi
                ipcoreSettings="$(mapGet "${listName}" "settings")"
                if [ "${ipcoreSettings}" != "" ]; then
                    ipcoreSettings="${ipcoreSettings//$'\n'/\\n}"
                fi

                debug_print "Writing ${ipcoreType,,}_${G_mdisInstanceCount} section to system.dsc"

                < "${1}/16zX.tpl" sed "s/SCAN_MDIS_INSTANCE/${G_mdisInstanceCount}/g;s/SCAN_BBIS_NAME/${bbis_name}/g;s/USCORESCAN_BBIS_INSTANCE/_${bbis_instance}/g;s/SCAN_DEV_SLOT/$(printf 0x%x "${G_bus_slot_count}")/g;s/SCAN_IPCORE_TYPE/${ipcoreType,,}/g;s/SCAN_IPCORE_NAME/${ipcoreName^^}/g;s/SCAN_WIZMODEL_NAME/${ipcoreHwName}/g;s/SCAN_DEVICE_SETTINGS/${ipcoreSettings}/g;" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"

                G_bus_slot_count=$((G_bus_slot_count + 1))
                G_mdisInstanceCount=$((G_mdisInstanceCount + 1))

                G_makefileNatDriver+=" $(mapGet "${listName}" "Native_Driver")"
                G_makefileLlDriver+=" $(mapGet "${listName}" "Low_Level_Driver")"
                G_makefileLlTool+=" $(mapGet "${listName}" "Driver_Specific_Tool")"
                G_makefileUsrLibs+=" $(mapGet "${listName}" "User_Library")"

                for (( i=0; i<listSize; i++ )); do
                    mapDelete "${ipcoreSpecList[${i}]}"
                done
            fi
        fi
    fi # do_parse

    # skip to begin of IP cores table
    delimiter=$(echo "${devline}" | awk '{print $1}')
    if [ "${delimiter}" == "---" ]; then
        do_parse=1
    elif [ "${delimiter}" == "" ]; then
        do_parse=0
    fi

    done 3< ${TMP_CHAM_TBL}
}


############################################################################
# check if a PCI device is a MEN chameleon device
#
# if a chameleon device is found ( valid chameleon table could be dumped)
# the table is parsed, BBIS name and wizard model extracted.
# After scanning the IP cores the DEVICE_IDV2_x = U_INT32 0x.... entry is
# added.
#
# example:
#  8 0x0022 16Z034_GPIO      0    0   0   9  63   0 0x00000a00 0x91100a00
#  9 0x0022 16Z034_GPIO      0    1   0   9  63   0 0x00000b00 0x91100b00
# 10 0x0022 16Z034_GPIO      0    2   0   9  63   0 0x00000c00 0x91100c00
#  is converted into:
#  DEVICE_IDV2_0 = U_INT32 0x2200
#  DEVICE_IDV2_1 = U_INT32 0x2201
#  DEVICE_IDV2_2 = U_INT32 0x2202
#
# parameters:
# $1  MEN linux dir (/opt/menlinux)
# $2  PCI vendor
# $3  PCI device id
# $4  PCI device nr.
# $5  PCI subvendor
# $6  instance count
# $7  pci primary path
# $8  pci bus nr.
#
check_for_cham_devs () {
    debug_args "MEN_LIN_DIR:${1} pcivend:${2} pcidevid:${3} pcidevnr:${4} pcisubvend:${5} count_instance_f2xx:${6} pcibus:${7}"
    local cham_file=""
    local device_id_count=0
    local CmdResult

    # check if we find a chameleon table
    "${1}/BIN/${FPGA_LOAD}" "${2}" "${3}" "${5}" 0 -t > /dev/null
    CmdResult=$?
    if [[ ${CmdResult} == "0" || "${SCAN_SIM}" == "1" ]]; then
        # store temp. cham table ( '>' to start new file!)
        if [ "${SCAN_SIM}" == "0" ]; then
            "${1}/BIN/${FPGA_LOAD}" "${2}" "${3}" "${5}" 0 -t > "${TMP_CHAM_TBL}"
        fi

        # extract board name from 'file='
        # cham_file=`fgrep "file=" $TMP_CHAM_TBL | awk '{print substr($1,6,4)}'`
        # ts: new generic chameleon carrier is named mezz_cham_<instance>
        cham_file="mezz_cham"
        debug_print "cham_file = ${cham_file} (= _WIZ_MODEL)"
        inst_count=${6}

        G_bus_slot_count=0 # in next BBIS carrier PCI_BUS_SLOT starts at 0 again
        G_deviceIdV2=""    # clear list of IDs for next BBIS

        # gather DEVICE_IDV2 data for this BBIS first
        scan_cham_table "${DSC_TPL_DIR}" "${cham_file}" "${inst_count}" 0 "${7}:${4}:0"

        # Now add the found device IDs to temporary BBIS desc file
        create_entry_dsc_bbis_cham "${2}" "${3}" "${4}" "${5}" "${DSC_TPL_DIR}" "${7}" "${6}"
        for id in ${G_deviceIdV2}; do
            # format data into a DEVICE_IDV2 entry and add same scan tag in next line
            idv2line="    DEVICE_IDV2_${device_id_count} = U_INT32 ${id}\n#SCAN_NEXT_DEVID"
            sed -i.bak "s/#SCAN_NEXT_DEVID/${idv2line}/g" ${TMP_BBIS_DSC}
            device_id_count=$((device_id_count + 1))
        done
        # BBIS dsc section now complete. append it to $DSC_FILE
        cat ${TMP_BBIS_DSC} >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"

        # all F2xx BBIS are supported by chameleon PCI table driver..
        G_makefileBbisDriver+=" CHAMELEON/DRIVER/COM/driver_pcitbl.mak"

        # create MDIS dev entries under this BBIS device
        G_bus_slot_count=0
        G_deviceIdV2=""    # clear list of IDs for next BBIS
        scan_cham_table "${DSC_TPL_DIR}" "${cham_file}" "${inst_count}" 1 "${7}:${4}:0"
    fi
}

############################################################################
# create a f223_x BBIS section plus 1 gpio driver on it.
# The assigned gpio driver instance number is equal to
# the BBIS instance (instance of found F223) so on f223_1
# theres pi7c9_gpio_1, on f223_2 theres pi7c9_gpio_2 etc.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI bus number (subst. SCAN_PCI_BUS_NR tag)
# $4  PCI device number (subst. SCAN_PCI_DEV_NR tag)
#
create_entry_dsc_f223 () {
    debug_print "Writing f223_${2} section to system.dsc "
    debug_args " \$1 = ${1}   \$2 = ${2}    \$3 = ${3}    \$4 = ${4}  "
    < "${1}/f223.tpl" sed "s/SCAN_BBIS_INSTANCE/${2}/g;s/SCAN_MDIS_INSTANCE/${2}/g;s/SCAN_PCI_BUS_NR/$(printf 0x%x "${3}")/g;s/SCAN_PCI_DEV_NR/$(printf 0x%x "${4}")/g" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
}

############################################################################
# create a f207_x BBIS section.
# F207 section is added when a PP04 was found.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI_BUS primary path (subst. SCAN_PCIPATH_PRIM tag)
# $4  PCI_BUS sec. path (subst. SCAN_PCIPATH_SEC tag)
#
create_entry_dsc_f207 () {
    debug_print "Writing f207_${2} section to system.dsc "
    debug_args " \$1 = ${1} \$2 = ${2}  \$3 = ${3}  \$4 = ${4} "
    < "${1}/f207.tpl" sed "s/SCAN_BBIS_INSTANCE/${2}/g;s/SCAN_PCIPATH_PRIM/$(printf 0x%x "${3}")/g;s/SCAN_PCIPATH_SEC/$(printf 0x%x "${4}")/g" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
}

############################################################################
# create a d203_x BBIS section.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI_BUS slot (subst. SCAN_SMBUSIF tag)
# $4  PCI_BUS number (subst. SCAN_PCI_BUS_NR tag)
# $5  board name (subst. SCAN_BBIS_NAME tag)
# $6  PCI device number (subst. SCAN_PCI_DEV_NR tag)
# $7  DSC output file
#
create_entry_dsc_d203 () {
    debug_print "Writing d203_${2} section to system.dsc "
    debug_args " \$1 = ${1} \$2 = ${2}  \$3 = ${3}  \$4 = ${4}  \$5 = ${5}  \$6 = ${6} "
    < "${1}/d203.tpl" sed "s/SCAN_BBIS_INSTANCE/${2}/g;s/SCAN_SMBUSIF/${3}/g;s/SCAN_PCI_BUS_NR/$(printf 0x%x "${4}")/g;s/SCAN_BBIS_NAME/${5}/g;s/SCAN_PCI_DEV_NR/$(printf 0x%x "${6}")/g" >> "${7}"
    if [ "${2}" == "1" ]; then
        G_makefileBbisDriver+=" D203/DRIVER/COM/driver.mak"
    fi
    scan_for_mmodules "${1}" "${2}" d203 "${4}" "${6}" 0 "A08/D16" "${7}"
}

############################################################################
# create a d203_a24_x BBIS section.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI_BUS slot (subst. SCAN_SMBUSIF tag)
# $4  PCI_BUS number (subst. SCAN_PCI_BUS_NR tag)
# $5  board name (subst. SCAN_BBIS_NAME tag)
# $6  PCI device number (subst. SCAN_PCI_DEV_NR tag)
# $7  DSC output file
#
create_entry_dsc_d203_a24 () {
    debug_print "Writing d203_a24_${2} section to system.dsc "
    debug_args " \$1 = ${1} \$2 = ${2} \$3 = ${3} \$4 = ${4} \$5 = ${5} \$6 = ${6} "
    < "${1}/d203_a24.tpl" sed "s/SCAN_BBIS_INSTANCE/${2}/g;s/SCAN_SMBUSIF/$3/g;s/SCAN_PCI_BUS_NR/$(printf 0x%x "${4}")/g;s/SCAN_BBIS_NAME/${5}/g;s/SCAN_PCI_DEV_NR/$(printf 0x%x "${6}")/g" >> "${7}"
    if [ "$2" == "1" ]; then
        G_makefileBbisDriver+=" D203/DRIVER/COM/driver_a24.mak"
    fi
    scan_for_mmodules "${1}" "${2}" d203_a24 "${4}" "${6}" 0 "A24/D32" "${7}"
}

############################################################################
# add the xm01bc LL driver, tool to LL driver and LL tool list. Some
# F-Cards have a BMC, some dont (F21P). bundle necessary mak file adding here
#
add_z001_io_support () {
    G_makefileNatDriver+=" DRIVERS/Z001_SMB/driver_g2x.mak DRIVERS/CHAMELEON/driver.mak"
}

############################################################################
# add mdis drivers from files in mdisDriverSpecList
#
# parameters:
# $1 swmodule name
add_mdis_drivers () {
    local mdisDriverName=${1}
    debug_args "add_mdis_drivers ${1}"
    makeMdisDriverOutputData "${mdisDriverName}"
    if [ "${mdisDriverSpecList["name"]}" == "" ]; then
        echo "add_mdis_drivers: No valid data"
        return 1
    fi
    if [ "${mdisDriverSpecList["Low Level Driver"]}" != "" ]; then
        for xMakefile in ${mdisDriverSpecList["Low Level Driver"]}; do
            debug_args "Low Level Driver: ${xMakefile}"
            G_makefileLlDriver+=" ${xMakefile}"
        done
    fi
    if [ "${mdisDriverSpecList["Driver Specific Tool"]}" != "" ]; then
        for xMakefile in ${mdisDriverSpecList["Driver Specific Tool"]}; do
            debug_args "Driver Specific Tool: ${xMakefile}"
            G_makefileLlTool+=" ${xMakefile}"
        done
    fi
    if [ "${mdisDriverSpecList["User Library"]}" != "" ]; then
        for xMakefile in ${mdisDriverSpecList["User Library"]}; do
            debug_args "User Library: ${xMakefile}"
            G_makefileUsrLibs+=" ${xMakefile}"
        done
    fi
}

############################################################################
# add mdis VME drivers from files in mdisVMESpecList
#
# parameters:
# $1 swmodule name
add_vme_drivers () {
    local mdisVMEName=${1}
    debug_args "add_mdis_drivers ${1}"
    makeVMEDriverOutputData "${mdisVMEName}"
    if [ "${mdisVMESpecList["name"]}" == "" ]; then
        echo "add_mdis_drivers: No valid data"
        return 1
    fi
    if [ "${mdisVMESpecList["Low Level Driver"]}" != "" ]; then
        for xMakefile in ${mdisVMESpecList["Low Level Driver"]}; do
            debug_args "Low Level Driver: ${xMakefile}"
            G_makefileLlDriver+=" ${xMakefile}"
        done
    fi
    if [ "${mdisVMESpecList["Driver Specific Tool"]}" != "" ]; then
        for xMakefile in ${mdisVMESpecList["Driver Specific Tool"]}; do
            debug_args "Driver Specific Tool: ${xMakefile}"
            G_makefileLlTool+=" ${xMakefile}"
        done
    fi
    if [ "${mdisVMESpecList["User Library"]}" != "" ]; then
        for xMakefile in ${mdisVMESpecList["User Library"]}; do
            debug_args "User Library: ${xMakefile}"
            G_makefileUsrLibs+=" ${xMakefile}"
        done
    fi
    if [ "${mdisVMESpecList["Common Tool"]}" != "" ]; then
        for xMakefile in ${mdisVMESpecList["Common Tool"]}; do
            debug_args "Common Tool: ${xMakefile}"
            G_makefileCommonTools+=" ${xMakefile}"
        done
    fi
    if [ "${mdisVMESpecList["Native Driver"]}" != "" ]; then
        for xMakefile in ${mdisVMESpecList["Native Driver"]}; do
            debug_args "Native Driver: ${xMakefile}"
            if ! grep -c "pldz002" <<< "${xMakefile}" > /dev/null
            then
                G_makefileNatDriver+=" ${xMakefile}"
            fi
        done
    fi
}


############################################################################
# For some MEN CPU boards memory regions are disabled by default while
# booting from UEFI mode.
# This function checks and enable all required memory regions on MEN
# G204/F204/F205 boards
#
enable_memory_regions () {
    local pciDevLineNr
    local pciBusHex
    local pciDevNrHex
    local pciDevFunHex
    local pciVend
    local pciDevId
    local pciSubVend
    local memPciDevDisable
    pciDevLineNr=$(grep -nh "Nr.| dom|bus|dev" ${TMP_PCIDEVS} | cut -f1 -d:)
    pciDevLineNr=$((pciDevLineNr+1))

    while read -r line <&4; do
        # Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
        #  25   0   5  15   0   0x12d8   0xe110    0x0000
        pciBusHex="$(printf "%x" "$(echo "${line}" | awk '{print $3}')")"
        pciDevNrHex="$(printf "%x" "$(echo "${line}" | awk '{print $4}')")"
        pciDevFunHex="$(printf "%x" "$(echo "${line}" | awk '{print $5}')")"
        pciVend="$(echo "${line}" | awk '{print $6}')"
        pciDevId="$(echo "${line}" | awk '{print $7}')"
        pciSubVend="$(echo "${line}" | awk '{print $8}')"
        memPciDevDisable="$(lspci -s "${pciBusHex}":"${pciDevNrHex}"."${pciDevFunHex}" -v | grep -c 'Memory at.*disabled')"

        if [ "${memPciDevDisable}" -gt 0 ]; then
            if [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0x203d" ] && [ "${pciSubVend}" == "0x00b9" ]; then
                echo "Found G204 board with 1 M-Module A24 with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            elif [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0xd203" ] && [ "${pciSubVend}" == "0xff00" ]; then
                echo "Found F204/F205 board with 1 or 2 M-Modules A08 with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            elif [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0x203d" ] && [ "${pciSubVend}" == "0xff00" ]; then
                echo "Found F204/F205 board with 1 or 2 M-Modules A24 with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            elif [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0x4d45" ] || [ "${pciVend}" == "0x1a88" ]; then
                echo "Found F2xx/G2xx carrier with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            else
                echo "Memory disabled on device ${pciBusHex}:${pciDevNrHex}.${pciDevFunHex}"
                echo "This is not valid board to enable memory regions, skipping"
            fi
        fi
    done 4< <(tail -n "+${pciDevLineNr}" "${TMP_PCIDEVS}")
}

############################################################################
# Set COMMAND register bits.
# Function reads current COMMAND register value and sets specified bits
# Bits that are set don't change.
#
# parameters:
# $1    PCI_BUS_NR (Hex)
# $2    PCI_DEV_NR (Hex)
# $3    PCI_DEV_FUN_NR (Hex)
# $4    COMMAND register value(Hex)
#
set_command_register () {
    local pciBusHex=${1}
    local pciDevNrHex=${2}
    local pciDevFunHex=${3}
    local pciCommandRegBits=${4}
    echo "Enabling memory via setpci cmd"
    pciCommandRegValue="$(printf "%x" "$(setpci -s "${pciBusHex}:${pciDevNrHex}.${pciDevFunHex}" COMMAND)")"
    pciCommandRegValue="$(( 0x${pciCommandRegValue} | 0x${pciCommandRegBits} ))"
    setpci -s "${pciBusHex}":"${pciDevNrHex}"."${pciDevFunHex}" COMMAND=0x${pciCommandRegValue}
}

############################################################################
# check if F223 board is in the system


############################################################################
# scan the generated PCI list tmp file for known devices. read the PCI list
# linewise to find multiple cards etc. Parse the generated temporary file for
# F2xx cards.
# For F223 the search is performed in a state machine like manner. A F223 is
# identified by a Pericom PCI bridge with 4 USB bridges directly after it.
# PP04 cards are identified by a TI cPCI bride + PP04 FPGA directly after it.
#
# parameters:
# $1    WIZ_BUS_PATH_PRIM primary PCI bus path of CPU
#
scan_for_pci_devs () {
    local state_check_f223=0
    local state_check_pp04=0
    local count_usb_devs=0
    local count_pp04_devs=0
    local count_instance_f223=0 # handled separately
    local count_instance_f207=0
    local count_instance_f2xx=0 # any other F2xx cham. carrier
    local count_instance_d203=0
    local count_instance_d203_a24=0
    local bus_path_prim=$1
    local bus_path_sec=0
    local bus_num_f223=0
    local dev_num_f223=0
    local reverse_enum_f205=0

    while read -r line <&4; do
    # Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
    #  25   0   5  15   0   0x12d8   0xe110    0x0000
        pcibus=$(echo "${line}" | awk '{print $3}')
        pcidevnr=$(echo "${line}" | awk '{print $4}')
        pcivend=$(echo "${line}" | awk '{print $6}')
        pcidevid=$(echo "${line}" | awk '{print $7}')
        pcisubvend=$(echo "${line}" | awk '{print $8}')
        debug_print "Vendor: ${pcivend} Device: ${pcidevid} PCI bus: ${pcibus} PCI devnr. ${pcidevnr} "

        ###################
        # state actions
        if [ "${state_check_f223}" == "1" ]; then
            # previous line was a Pericom bridge. Are now 4 subsequent USB bridges following?
            if [ "${pcivend}" == "0x12d8" ] && [ "${pcidevid}" == "0x400a" ]; then
                count_usb_devs=$((count_usb_devs + 1))
            # wait for first USB bridge, there might be other board(s) between
            # PCI bridge 12d8:e110 and USB bridges 13d8:400a
            elif [ "${count_usb_devs}" == "0" ]; then
                debug_print "device ${pcivend} ${pcidevid} between PCI - USB bridge"
            else # other device showed up in between USB bridges -> its no F223
                state_check_f223=0
                count_usb_devs=0
            fi

            if [ "${count_usb_devs}" == "1" ] && [ "${pcidevid}" == "0x400a" ]; then
                bus_num_f223=${pcibus}
                dev_num_f223=${pcidevnr}
            fi

            if [ "${count_usb_devs}" == "4" ] && [ "$pcidevid" == "0x400a" ]; then
                count_instance_f223=$((count_instance_f223 + 1))
                echo " -> F223 nr. ${count_instance_f223} found, adding to system descriptor"
                count_usb_devs=0
                state_check_f223=0
                if [ "${count_instance_f223}" == "1" ]; then
                    G_makefileBbisDriver+=" PCI/DRIVER/COM/driver.mak"
                    add_mdis_drivers "PI7C9_GPIO"
                fi
                create_entry_dsc_f223 "${DSC_TPL_DIR}" "${count_instance_f223}" \
                  "${bus_num_f223}" "${dev_num_f223}"
            fi
        fi

        # does a PP04 show up ?
        if [ "${state_check_pp04}" == "1" ]; then
            # previous line was a F207. Do we find a PP04 now? PP04 has V0 cham table.
            if [ "${pcivend}" == "0x1172" ] && [ "${pcidevid}" == "0x000c" ] && [ "${pcisubvend}" == "0x4d45" ]; then
                echo "Found PP04 MVB card. adding dsc entries for F207 and PP04"
                count_pp04_devs=$((count_pp04_devs + 1))
                create_entry_dsc_f207 "${DSC_TPL_DIR}" "${count_instance_f207}" "${bus_path_prim}" "${bus_path_sec}"
                create_entry_dsc_pp04 "${DSC_TPL_DIR}" "${count_pp04_devs}" "${count_instance_f207}"
            else # other device showed up in between -> its no F223.
                state_check_pp04=0
            fi
        fi

        ############################
        # state events

        # check if a F223 starts here
        if [ "${pcivend}" == "0x12d8" ] && [ "${pcidevid}" == "0xe110" ]; then
            echo "Found Pericom PCI bridge. Keep looking if F223 appears"
            state_check_f223=1
        fi

         # check if TI Bridge (=F207), if so check if a PP04 follows next
        if [ "${pcivend}" == "0x104c" ] && [ "${pcidevid}" == "0xac28" ]; then
            echo "Found TI2050 PCI bridge, possibly F207. Keep looking if PP04 appears"
            # store PCI devnr. in case its a F223
            bus_path_sec=${pcidevnr}
            count_instance_f207=$((count_instance_f207 + 1))
            state_check_pp04=1
        fi

        # any other F2xx/G2xx carrier (mezzanine chameleon) ?
        if [ "${pcivend}" == "0x1172" ] && [ "${pcidevid}" == "0x4d45" ] || [ "${pcivend}" == "0x1a88" ]; then
            count_instance_f2xx=$((count_instance_f2xx + 1))
            echo "Found possible MEN chameleon device(s), checking"
            check_for_cham_devs "${MEN_LIN_DIR}" \
                "${pcivend}" "${pcidevid}" "${pcidevnr}" "${pcisubvend}" \
                "${count_instance_f2xx}" "${pcibus}"
        fi

        if [ "${pcivend}" == "0x1172" ] && [ "${pcidevid}" == "0x203d" ] && [ "${pcisubvend}" == "0x00b9" ]; then
            echo "Found G204 board with 1 M-Module A24"
            pcibusslot=${G_cPciRackSlotSerial}
            count_instance_d203_a24=$((count_instance_d203_a24 + 1))
            G_cPciRackSlotSerial=$((G_cPciRackSlotSerial + 1))
            create_entry_dsc_d203_a24 "${DSC_TPL_DIR}" "${count_instance_d203_a24}" "${pcibusslot}" \
                "${pcibus}" "G204_A24" "${pcidevnr}" "${OUTPUT_DIR_PATH}/${DSC_FILE}"
        fi

        # support for F204/F205 carrier board with A08 M-Module access boards
        if [ "${pcivend}" == "0x1172" ] && [ "${pcidevid}" == "0xd203" ] && [ "${pcisubvend}" == "0xff00" ]; then
            echo "Found F204/F205 board with 1 or 2 M-Modules A08"
            pcibusslot=${G_cPciRackSlotStandard}
            busif="1"     # for standard cPCI always "cpu,1"
            if [ $reverse_enum_f205 == 0 ]; then
                cat /dev/null > "${TMP_F205_DSC}"
                cat /dev/null > "${TMP_F205_DSC}.tmp"
                reverse_enum_f205=1
                G_cPciRackSlotStandard=$((G_cPciRackSlotStandard + 1 + (15 - pcidevnr)))
            else
                reverse_enum_f205=$((reverse_enum_f205 + 1))
        fi
        count_instance_d203=$((G_cF205 + 1 - reverse_enum_f205))
        debug_print "Found d203 no. ${count_instance_d203}"
        create_entry_dsc_d203 "${DSC_TPL_DIR}" "${count_instance_d203}" "${busif}" "${pcibus}" "F205" "${pcidevnr}" "${TMP_F205_DSC}.tmp"
        if [ -e "${TMP_F205_DSC}.tmp" ]; then
            if [ -e "${TMP_F205_DSC}" ]; then
                cat "${TMP_F205_DSC}" >> "${TMP_F205_DSC}.tmp"
            fi
            mv "${TMP_F205_DSC}.tmp" "${TMP_F205_DSC}"
        fi
            boardPosition=$(get_board_outermost_position "0x1172" "0xd203" "0xff00" "${pcibus}")
        if [ "${pcidevnr}" == "${boardPosition}" ]; then
            if [ -e "${TMP_F205_DSC}" ]; then
                cat "${TMP_F205_DSC}" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
            fi
            reverse_enum_f205=0
        fi
    fi

    # support for F204/F205 carrier board with A24 M-Module access boards
    if [ "${pcivend}" == "0x1172" ] && [ "${pcidevid}" == "0x203d" ] && [ "${pcisubvend}" == "0xff00" ]; then
        echo "Found F204/F205 board with 1 or 2 M-Modules A24"
        pcibusslot=${G_cPciRackSlotStandard}
        busif="1"     # for standard cPCI always "cpu,1"
        count_instance_d203_a24=$((count_instance_d203_a24 + 1))
        create_entry_dsc_d203_a24 "${DSC_TPL_DIR}" "${count_instance_d203_a24}" "${busif}" "${pcibus}" "F205_A24" "${pcidevnr}" "${OUTPUT_DIR_PATH}/${DSC_FILE}"
    fi

    done 4<  ${TMP_PCIDEVS}
}

### @brief Create M-Module section
###
### @param $1 DSC template directory
### @param $2 M-Module name
### @param $3 Board instance number
### @param $4 Board name
### @param $5 DSC output file
create_entry_dsc_mmodule () {
    local tplDir
    local boardNum
    local boardName
    local outFile
    local mModule
    local xMakefile
    local wizModelName

    tplDir="${1}"
    boardNum="${2}"
    boardName="${3}"
    outFile="${4}"

    mModule="${mmodSpecList["hwname"]}"

    if [ "${mModule}" == "" ] || \
        [ "${mmodSpecList["hwname"]}" == "" ] || \
        [ "${mmodSpecList["name"]}" == "" ]; then
        return 22
    fi

    if [ "${mModuleInstances["${mModule}"]}" == "" ]; then
        mModuleInstances["${mModule}"]="1"
    else
        mModuleInstances["${mModule}"]="$((mModuleInstances["${mModule}"]+=1))"
    fi

    echo "Found ${mModule^^} M-Module" #(${mmodSpecList["mmoduleid"]}) on ${boardName}_${boardNum}"
    # Check if M-Module has its modelname
    if [ "${mmodSpecList["modelname"]}" != "" ]; then
        wizModelName="${mmodSpecList["modelname"]^^}"
    else
        wizModelName="${mmodSpecList["hwname"]^^}"
    fi

    local chars=""
    local mModuleDevNo=1
    local mModuleSubDevOffset=()
    local mModuleDevParam=""
    if [ "${mmodSpecList["subdevofftbl"]}" != "" ]; then
        debug_print "mmodSpecList[\"subdevofftbl\"]: ${mmodSpecList["subdevofftbl"]}"
        chars=( {a..x} )
        mModuleDevNo="$(echo "${mmodSpecList["subdevofftbl"]}" | tr , '\n' | wc -l)"
        for (( subDev=0; subDev<mModuleDevNo; subDev++ ))
        do
            subDevOffset="$(echo "${mmodSpecList["subdevofftbl"]}" | awk -v subDev="$((subDev+1))" -F',' '{print $subDev}')"
            mModuleSubDevOffset+=("    SUBDEVICE_OFFSET_0 = U_INT32 0x${subDevOffset}\n")
            debug_print "Create subdevice: ${mModule,,}_${mModuleInstances["${mModule}"]}${chars[subDev]} with offset: 0x${subDevOffset}"
        done
    else
        mModuleSubDevOffset=("")
    fi
    # Add M-Module settings
    if [ "${mmodSpecList["settingno"]}" != "" ]; then
        for (( setNo=1; setNo<=mmodSpecList["settingno"]; setNo++ ))
        do
          if [ "${mmodSpecList["settingname${setNo}"]}" != "" ]; then
              mModuleDevParam+="    ${mmodSpecList["settingname${setNo}"]} = ${mmodSpecList["settingtype${setNo}"]} ${mmodSpecList["settingvalue${setNo}"]}\n"
              debug_print "Add ${mModule,,} M-Module required parameter:"
              debug_print "${mmodSpecList["settingname${setNo}"]}=${mmodSpecList["settingtype${setNo}"]} ${mmodSpecList["settingvalue${setNo}"]}"
          fi
        done
    fi

    for (( devCnt=0; devCnt<mModuleDevNo; devCnt++ ))
    do
        debug_print "Writing ${mModule,,}_${mModuleInstances["${mModule}"]}${chars[devCnt]} section to system.dsc"
        < "${tplDir}/mX.tpl" sed "s/SCAN_MMODULE_INSTANCE/${mModuleInstances["${mModule}"]}${chars[devCnt]}/g;s/SCAN_BBIS_NAME/${boardName}/g;s/USCORESCAN_BBIS_INSTANCE/_${boardNum}/g;s/SCAN_DEV_SLOT/$(printf 0x%x "${mm_device_slot}")/g;s/SCAN_MMODULE_NAMELCASE/${mmodSpecList["hwname"],,}/g;s/SCAN_MMODULE_NAME/${mmodSpecList["name"]^^}/g;s/SCAN_WIZMODEL_NAME/${wizModelName}/g;s/SUBDEVICE_OFFSET/${mModuleSubDevOffset[devCnt]}/g;s/DEVICE_PARAMETERS/${mModuleDevParam}/g" >> "${outFile}"
    done

    if [ "${mModuleInstances["${mModule}"]}" == "1" ]; then
        if [ "${mmodSpecList["Low Level Driver"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["Low Level Driver"]}; do
                G_makefileLlDriver+=" ${xMakefile}"
            done
        fi
        if [ "${mmodSpecList["Native Driver"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["Native Driver"]}; do
                G_makefileNatDriver+=" ${xMakefile}"
            done
        fi
        if [ "${mmodSpecList["Driver Specific Tool"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["Driver Specific Tool"]}; do
                G_makefileLlTool+=" ${xMakefile}"
            done
        fi
        if [ "${mmodSpecList["User Library"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["User Library"]}; do
                G_makefileUsrLibs+=" ${xMakefile}"
            done
        fi
    fi
}

### @brief Get M-Module ID
### @param $1 M-Module address
### @return M-Module ID is echoed
### @return Empty string is echoed on error
getMmodId() {
    local mmAddress
    local mmId
    local mmMagic
    local mmIdent

    mmAddress="${1}"

    mmMagic="$("${MEN_LIN_DIR}"/BIN/"${MM_IDENT}" "${mmAddress}" | grep "MAGIC:" | head -n 1)"
    if [[ "${mmMagic}" =~ ^MAGIC:[[:space:]]0x([[:xdigit:]]{4})$ ]]; then
        mmMagic="${BASH_REMATCH[1]}"
        mmIdent="$("${MEN_LIN_DIR}"/BIN/"${MM_IDENT}" "${mmAddress}" | grep "ID:" | head -n 1)"
        if [[ "${mmIdent}" =~ [[:space:]]ID:[[:space:]]0x([[:xdigit:]]{4}), ]]; then
            mmIdent="${BASH_REMATCH[1]}"
            mmId="0x${mmMagic}${mmIdent}"
        fi
    fi

    echo "${mmId}"
}

############################################################################
# scan for M-Modules on specific board
#
# parameters:
# $1  DSC template directory
# $2  board instance number
# $3  board name
# $4  PCI bus number to scan (decimal)
# $5  PCI device number to scan (decimal)
# $6  PCI device function to scan (decimal)
# $7  carrier board type (A24/D32 or A08/D16)
# $8  DSC output file
#
scan_for_mmodules () {
    local mm_a08d16xx="0x0000200 0x0000600 0x0000a00 0x0000e00"
    local mm_a24d32x0="0x0000000 0x1000000 0x1fffd00 0x1fffe00"
    local mm_a24d32x1="0x2000000 0x3000000 0x3fffd00 0x3fffe00"
    local mm_a24d32x2="0x4000000 0x5000000 0x5fffd00 0x5fffe00"
    local mm_a24d32x3="0x6000000 0x7000000 0x7fffd00 0x7fffe00"
    local mm_device_slot=0
    local mm_pci_bus
    local mm_pci_dev
    local mm_pci_fun
    local bar_address
    mm_pci_bus=$(printf "%x" "${4}")
    mm_pci_dev=$(printf "%x" "${5}")
    mm_pci_fun=$(printf "%x" "${6}")
    bar_address=$(lspci -s "${mm_pci_bus}":"${mm_pci_dev}"."${mm_pci_fun}" -v | grep 'Memory at' | head -n 1 | awk '{print $3}')
    if [ "${7}" == "A08/D16" ]; then
        for mm_offset in ${mm_a08d16xx}; do
            mm_address=$(printf "0x%x" $((0x${bar_address} + mm_offset)))
            mm_id="$(getMmodId "${mm_address}")"
            if [ "${mm_id}" != "" ]; then
                makeMmodFileMap
                makeMmodOutputData "${mm_id}"
                create_entry_dsc_mmodule "${1}" "${2}" "${3}" "${8}"
            fi
            mm_device_slot=$((mm_device_slot + 1))
        done
    elif [ "$7" == "A24/D32" ]; then
        mm_a24d32xx="mm_a24d32x0 mm_a24d32x1 mm_a24d32x2 mm_a24d32x3"
        for mm_a24d32 in ${mm_a24d32xx}; do
            for mm_offset in ${!mm_a24d32}; do
                mm_address=$(printf "0x%x" $((0x${bar_address} + mm_offset)))
                mm_id="$(getMmodId "${mm_address}")"
                if [ "${mm_id}" != "" ]; then
                    makeMmodFileMap
                    makeMmodOutputData "${mm_id}"
                    if create_entry_dsc_mmodule "${1}" "${2}" "${3}" "${8}"; then
                        break
                    fi
                fi
            done
            mm_device_slot=$((mm_device_slot + 1))
        done
    fi
}

############################################################################
# count f205 like carrier boards
#
#   Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
#     .
#     .
#     .
#    15|  0   4  13   0   0x1172   0xd203    0xff00
#    16|  0   4  15   0   0x1172   0xd203    0xff00
#     .
#     .
#     .
#
count_f205_boards () {
    G_cF205=$( < "${TMP_PCIDEVS}" awk '{if ($6 == "0x1172" && $7 == "0xd203" && $8 == "0xff00") print $1}' | wc -l)
}

############################################################################
# Check Compact PCI board outermost dev position on bus
#
#   Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
#     .
#
#    15|  0   4  13   0   0x1172   0x203d    0xff00
#    16|  0   4  15   0   0x1172   0x203d    0xff00
#
# parameters:
# $1 Ven ID
# $2 Dev ID
# $3 SubVen ID
# $4 Bus number
#
get_board_outermost_position () {
    local PciDevNrLast=0
    local DeviceNr
    local PciBus
    local PciDevNr
    local DeviceNr
    DeviceNr=$(grep -c "${1} * ${2} * ${3}" ${TMP_PCIDEVS})
    if [ "${DeviceNr}" -eq "0" ]; then
        echo "No device found: ${1} ${2} ${3} "
    fi

    for i in $(seq 1 "${DeviceNr}")
    do
        PciBus=$(grep "${1} * ${2} * ${3}" ${TMP_PCIDEVS} | awk NR=="${i}"'{print $3}')
        PciDevNr=$(grep "${1} * ${2} * ${3}" ${TMP_PCIDEVS} | awk NR=="${i}"'{print $4}')
        if [ "${PciBus}" -eq "${4}" ] && [ "${PciDevNrLast}" -lt "${PciDevNr}" ]; then
                PciDevNrLast=${PciDevNr}
        fi
    done
    echo "${PciDevNrLast}"
}

############################################################################
# check if .mak should be added into main Makefile
#
check_makefile () {
    local singleMak=${1}
    local duplicateCnt
    duplicateCnt=$(echo "${G_makefileUniqList}" | grep -c "${singleMak}") 

    if [ "${duplicateCnt}" -ne 0 ]; then
        return 1
    else
        G_makefileUniqList+=${singleMak}
        G_makefileUniqList+="\n"
        return 0
    fi
}

############################################################################
# create MDIS Makefile from collected driver data
#
#   Makefile.tpl is completed by replacing following tags
#   with real driver/library/program.mak references:
#
#   #SCAN_LIN_KERNEL_DIR   -> LIN_KERNEL_DIR
#   #SCAN_NEXT_LL_DRIVER   -> ALL_LL_DRIVERS
#   #SCAN_NEXT_BB_DRIVER   -> ALL_BB_DRIVERS
#   #SCAN_NEXT_USR_LIB     -> ALL_USR_LIBS
#   #SCAN_NEXT_LL_TOOL     -> ALL_LL_TOOLS
#   #SCAN_NEXT_NAT_DRIVER  -> ALL_NATIVE_DRIVERS
#
#   Also check .mak files to really exist in the MEN_LIN_DIR folder.
#   The xml files contain also MEN internal test tools
#
create_makefile () {
    debug_print "creation of Makefile..."
    local subs=""

    # start with the template
    cat "${DSC_TPL_DIR}/Makefile.tpl" > ${TMP_MAKE_FILE}
    # Add cretion note into Makefile
    sed -i "s/CREATION_NOTE/ ${CREATION_NOTE}\n# ${COMMIT_ID}\n# ${DATE}/g" ${TMP_MAKE_FILE}

    # write library installation directory
    local LIB_INSTALL_DIR="/usr/local/lib"
    local LIN_DISTRO_NAME
    LIN_DISTRO_NAME="$(grep -oPs "(?<=^NAME=\")[^\"]+(?=\")" /etc/os-release)"
    if [ "${LIN_DISTRO_NAME}" == "CentOS Linux" ]; then
        LIB_INSTALL_DIR="/usr/lib"
    elif [[ "${LIN_DISTRO_NAME}" =~ Yocto ]]; then
        LIB_INSTALL_DIR="/usr/lib"
    fi
    local lib_dir
    lib_dir="$(echo "${LIB_INSTALL_DIR}" | sed "s/\//@/g")"
    sed -i.bak "s/SCAN_LIB_INSTALL_DIR/${lib_dir}/g" ${TMP_MAKE_FILE}

    # write linux kernel directory
    kern_dir=$(echo "${LIN_SRC_DIR}" | sed "s/\//@/g")
    sed -i.bak "s/SCAN_LIN_KERNEL_DIR/${kern_dir}/g" ${TMP_MAKE_FILE}

    # insert all collected Mdis Extra Defs into Makefile
    local EXTRA_DEFS=""
    for i in ${G_mdisExtraDefs}; do
        echo "Add Mdis Extra Define: ${i}"
        EXTRA_DEFS=$(printf "%s %s" ${EXTRA_DEFS} ${i})
    done
    if [ ! -z "${EXTRA_DEFS}" ]
    then
        sed -i.bak "/^DEVNODE_INSTALL_DIR.*/a MDIS_EXTRA_DEFS = ${EXTRA_DEFS}" ${TMP_MAKE_FILE}
    fi 
    # insert all collected BBIS drivers into Makefile
    for i in ${G_makefileBbisDriver}; do
    debug_print "checking bbis driver: ${i}"
        if [ -f "${MEN_LIN_DIR}"/DRIVERS/BBIS/"${i}" ]; then
            debug_print "bbis driver: ${i}"
            check_makefile "${i}"
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=$(printf "\t%s" "${i}" | sed "s/\//@/g")
                sed -i.bak "s/#SCAN_NEXT_BB_DRIVER/${subs}\n#SCAN_NEXT_BB_DRIVER/g" ${TMP_MAKE_FILE}
            fi
        else
        debug_print "BB driver '${i}' not found in MDIS tree, skipping"
        fi
    done
    if [ ! -z "${subs}" ]
    then
        sed -i.bak "s/${subs}/#LAST_BBIS_DRIVER/g" ${TMP_MAKE_FILE}
        subs="${subs//".mak"/".lastmak"}"
    fi
    sed -i.bak "s/#LAST_BBIS_DRIVER/${subs}\n/g" ${TMP_MAKE_FILE}
    sed -i.bak "s/#SCAN_NEXT_BB_DRIVER//g" ${TMP_MAKE_FILE}
    subs=""

    # insert all collected LL drivers into Makefile
    for i in ${G_makefileLlDriver}; do
    debug_print "checking LL driver: ${i}"
        if [ -f "${MEN_LIN_DIR}"/DRIVERS/MDIS_LL/"${i}" ]; then
            debug_print "ll driver: ${i} "
            check_makefile "${i}"
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=$(printf "\t%s" "${i}" | sed "s/\//@/g")
                sed -i.bak "s/#SCAN_NEXT_LL_DRIVER/${subs}\n#SCAN_NEXT_LL_DRIVER/g" ${TMP_MAKE_FILE}
            fi
        else
            debug_print "skipping LL driver '${i}'"
        fi
    done
    if [ ! -z "${subs}" ]
    then
        sed -i.bak "s/${subs}/#LAST_LL_DRIVER/g" ${TMP_MAKE_FILE}
        subs="${subs//".mak"/".lastmak"}"
    fi
    sed -i.bak "s/#LAST_LL_DRIVER/${subs}\n/g" ${TMP_MAKE_FILE}
    sed -i.bak "s/#SCAN_NEXT_LL_DRIVER//g" ${TMP_MAKE_FILE}
    subs=""

    # insert all collected LL Tools into Makefile
    for i in ${G_makefileLlTool}; do
        if [ -f "${MEN_LIN_DIR}"/DRIVERS/MDIS_LL/"${i}" ]; then
            debug_print "ll tool: ${i}"
            check_makefile "${i}"
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=$(printf "\t%s" "${i}" | sed "s/\//@/g")
                sed -i.bak "s/#SCAN_NEXT_LL_TOOL/${subs}\n#SCAN_NEXT_LL_TOOL/g" ${TMP_MAKE_FILE}
            fi
        else
            debug_print "skipping LL tool '${i}'"
        fi
    done
    if [ ! -z "${subs}" ]
    then
        sed -i.bak "s/${subs}/#LAST_LL_TOOL/g" ${TMP_MAKE_FILE}
        subs="${subs//".mak"/".lastmak"}"
    fi
    sed -i.bak "s/#LAST_LL_TOOL/${subs}\n/g" ${TMP_MAKE_FILE}
    sed -i.bak "s/#SCAN_NEXT_LL_TOOL//g" ${TMP_MAKE_FILE}
    subs=""

    # insert all collected native drivers into Makefile
    for i in ${G_makefileNatDriver}; do
        if [ -f "${MEN_LIN_DIR}"/"${i}" ]; then
            debug_print "native driver: ${i}"
            check_makefile "${i}"
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=$(printf "\t%s" "${i}" | sed "s/\//@/g")
                sed -i.bak "s/#SCAN_NEXT_NAT_DRIVER/${subs}\n#SCAN_NEXT_NAT_DRIVER/g" ${TMP_MAKE_FILE}
            fi
        else
            echo "native driver '$i' not found in MDIS tree, skipping"
        fi
    done
    if [ ! -z "${subs}" ]
    then
        sed -i.bak "s/${subs}/#LAST_NAT_DRIVER/g" ${TMP_MAKE_FILE}
        subs="${subs//".mak"/".lastmak"}"
    fi
    sed -i.bak "s/#LAST_NAT_DRIVER/${subs}\n/g" ${TMP_MAKE_FILE}
    sed -i.bak "s/#SCAN_NEXT_NAT_DRIVER//g" ${TMP_MAKE_FILE}
    subs=""

    for i in ${G_makefileUsrLibs}; do
        if [ -f "${MEN_LIN_DIR}"/LIBSRC/"${i}" ]; then
            debug_print "usr lib: ${i}"
            check_makefile "${i}"
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=$(printf "\t%s" "${i}" | sed "s/\//@/g")
                sed -i.bak "s/#SCAN_NEXT_USR_LIB/${subs}\n#SCAN_NEXT_USR_LIB/g" ${TMP_MAKE_FILE}
            fi
        else
            echo "user lib not found in MDIS tree, skipping"
        fi
    done
    if [ ! -z "${subs}" ]
    then
        sed -i.bak "s/${subs}/#LAST_USR_LIB/g" ${TMP_MAKE_FILE}
        subs="${subs//".mak"/".lastmak"}"
    fi
    sed -i.bak "s/#LAST_USR_LIB/${subs}\n/g" ${TMP_MAKE_FILE}
    sed -i.bak "s/#SCAN_NEXT_USR_LIB//g" ${TMP_MAKE_FILE}
    subs=""

    for i in ${G_makefileCommonTools}; do
        if [ -f "${MEN_LIN_DIR}"/TOOLS/"${i}" ]; then
            debug_print "usr lib: ${i}"
            check_makefile "${i}"
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=$(printf "\t%s" "${i}" | sed "s/\//@/g")
                sed -i.bak "s/#SCAN_NEXT_COM_TOOL/${subs}\n#SCAN_NEXT_COM_TOOL/g" ${TMP_MAKE_FILE}
            fi
        else
            echo "user common tool not found in MDIS tree, skipping"
        fi
    done
    if [ ! -z "${subs}" ]
    then
        sed -i.bak "s/${subs}/#LAST_COM_TOOL/g" ${TMP_MAKE_FILE}
        subs="${subs//".mak"/".lastmak"}"
    fi
    sed -i.bak "s/#LAST_COM_TOOL/${subs}\n/g" ${TMP_MAKE_FILE}
    sed -i.bak "s/#SCAN_NEXT_COM_TOOL//g" ${TMP_MAKE_FILE}
    subs=""

    # add '\' behind every .mak that is not last and replace @ with '/'
    sed -i.bak "s/@/\//g;s/\.mak/\.mak \\\/g" ${TMP_MAKE_FILE} 
    sed -i.bak "s/\.lastmak/\.mak/g" ${TMP_MAKE_FILE}

    # add path to mdis sources
    sed -i.bak "/.*MEN_LIN_DIR =.*/c MEN_LIN_DIR = ${MEN_LIN_DIR}" ${TMP_MAKE_FILE}

    # finally replace ##REPLNEWLINExxx tags with LF (after
    # removing all doublette line no linefeeds would be left
    # making the Makefile looking ugly...)
    sed -i.bak "s/##REPLNEWLINE...//g" ${TMP_MAKE_FILE}
    cat -s "${TMP_MAKE_FILE}" > "${OUTPUT_DIR_PATH}/${MAKE_FILE}"
}

### @brief Compile mm_ident tool
compile_mm_ident () {
    echo "compiling mm_ident"
    if [ -d "${MEN_LIN_DIR}TOOLS/mm_ident" ]; then
        make clean -C "${MEN_LIN_DIR}TOOLS/mm_ident" &> "${MEN_LIN_DIR}TOOLS/mm_ident/make_clean.log"
        make -C "${MEN_LIN_DIR}TOOLS/mm_ident" &> "${MEN_LIN_DIR}TOOLS/mm_ident/make_mm_ident.log"
        local CmdResult=$?
        if [ ${CmdResult} -ne "0" ]; then
            echo "mm_ident compilation failed, see log: "
            echo "${MEN_LIN_DIR}TOOLS/mm_ident/make_mm_ident.log"
        else
            echo "mm_ident compilation succeed, see log:"
            echo "${MEN_LIN_DIR}TOOLS/mm_ident/make_mm_ident.log"
            rm "${MEN_LIN_DIR}TOOLS/mm_ident/make_clean.log"
        fi
    else
        echo "mm_ident tool not found in MDIS - error "
    fi

    return ${CmdResult}
}

### @brief Compile fpga_load tool
compile_fpga_tools () {
    echo "compiling fpga_tools, and other requried libraries like pciutils..."
    if [ -d "${MEN_LIN_DIR}TOOLS/FPGA_LOAD" ]; then
        make clean -C "${MEN_LIN_DIR}TOOLS/FPGA_LOAD" &> "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_clean.log"
        make -C "${MEN_LIN_DIR}TOOLS/FPGA_LOAD" &> "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_fpga_load.log"
        local CmdResult=$?
        if [ ${CmdResult} -ne "0" ]; then
            echo "fpga_tools compilation failed, see log: "
            echo "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_fpga_load.log"
        else
            echo "fpga_tools compilation succeed"
            echo "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_fpga_load.log"
            rm "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_clean.log"
        fi
    else
        echo "fpga_tools tool not found in MDIS - error "
    fi

    return ${CmdResult}
}

### @brief check if passed argument is valid directory in system
check_if_mdis_path () {
    local DirPath=${1}
    debug_print "DirPath: ${DirPath}"
    local CmdResult=$?

    if [ ${CmdResult} -ne 0 ]; then
        return 0
    fi

    if [ -d "${DirPath}" ]; then
        return 1
    else
        echo "Wrong MDIS INSTALL path"
        echo "PATH: ${DirPath} does not exists"
        return 2
    fi
}

### @brief check if all system prerequisites are met
### return 0 if success
check_scan_system_prerequisites () {
    local prerequisites_result=0
    local have_i2ctools
    have_i2ctools=$(which i2cdump)
    if [ "${have_i2ctools}" == "" ]; then
        echo "*** error: please install i2c-tools. Examples: Ubuntu: apt-get install i2c-tools, Fedora: yum install i2c-tools"
        prerequisites_result=1
    fi

    local have_pciutils1
    local have_pciutils2
    have_pciutils1=$(which setpci)
    have_pciutils2=$(which lspci)
    if [[ "${have_pciutils1}" == "" || \
          "${have_pciutils2}" == "" ]]; then
        echo "*** error: please install pciutils. Ubuntu: apt-get install pciutils, Fedora: yum install pciutils"
        prerequisites_result=2
    fi

    # check if /usr/src/linux/ exists and if its a valid kernel src/header folder
    debug_print "checking if /usr/src/linux/ points to valid kernel headers..."
    find ${LIN_SRC_DIR}/include/ -name "autoconf.h" > /dev/null 2>&1
    local linux_src_link=$?
    if [ "${linux_src_link}" == "0" ]; then
        debug_print "/usr/src/linux/ points to valid kernel headers: PASSED"
    else
        echo "*** error: please set a symlink /usr/src/linux to the headers of your current running kernel:"
        echo "           e.g.   ln -s /usr/src/linux-headers.x.y.z /usr/src/linux"
        prerequisites_result=3
    fi
    return ${prerequisites_result}
}

### @brief display question 'arg1' 
### @input: arg1 message to print
###       check for y/n/q
### @returns: 0="y"
###           1="n"
###           2="q"
get_ynq_answer() {
    while true
    do
        echo -e -n "${1}" '(y/n/q): '
        read -r answer
        case ${answer} in
        [Yy]) return 0;;
        [Nn]) return 1;;
        [Qq]) return 2;;
        esac
    done
}

### @brief Display question and obtain answer,
### @input: {1} - Question
###         {2} - Array of possible answers
### @returns: choosen index of array (starting from 0)
###
### Example use:
### readonly questionMsg="Would you like to select the default driver for this device? (y)
### Otherwise please choose the proper driver number"
###
### array=("one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten")
### displayQuestion "${questionMsg}" "${array[@]}"
### value=$?
### echo "Use driver idx: ${value}"
displayQuestion() {
    local question=${1}
    shift
    local arr=("$@")
    local argLimit=${#arr[@]}
    local i=0
    local arrIterator=0
    local answer
    question+="\n"

    for i in "${arr[@]}";
    do
        if [ ${arrIterator} -eq 0 ]; then
            question+="[y/0] ${i} - default\n"
        else
            question+="[${arrIterator}] ${i}\n"
        fi
        arrIterator=$((arrIterator+1))
    done

    if [ "${ASSUME_YES}" -eq 0 ]; then
        echo -e "${question}"
        while true
        do
            read -r answer
            case ${answer} in
            [Yy]) return 0;;
            [Qq]) echo "*** Aborted by user"
                  exit 1;;
            *)    if [[ "${answer}" =~ ^[0][0-9]+$ ]] || ! [[ "${answer}" =~ ^[0-9]+$ ]]; then
                      echo -e "${question}"
                  else
                      if ((0<=answer && answer<argLimit)); then
                          return "${answer}"
                      else
                          echo -e "${question}"
                      fi
                  fi;;
            esac
        done
    else
        return 0
    fi
}

### @brief display mcb mcb_pci blacklist warning if mcb/mcb_pci is available
blacklist_warning_message() {
    local mcb_available=0
    if modinfo mcb > /dev/null 2>&1; then
        mcb_available=1
    fi

    if modinfo mcb_pci > /dev/null 2>&1; then
        mcb_available=1
    fi

    if [[ "${mcb_available}" -eq 1 ]]; then
        echo ""
        echo "The kernel modules mcb/mcb_pci are available at your system and must be"
        echo "blacklisted to avoid inconveniences which could lead to a kernel panic."
        echo "Please refer to the MDIS User Manual 21md05-90.pdf for details."
        echo ""
    fi


}

############################################################################
############################################################################
## main
##

PCI_DRYTEST=""
BUILD_TOOLS=""
MEN_LIN_DIR=""
ASSUME_YES=0
INTERNAL_SWMODULES="0"

if [ $# -lt 1 ] || [ "${1}" == "--help" ] || [ "${1}" == "-h" ]; then
    scan_system_usage
    exit 1
fi

echo "============================================================"
echo "MDIS System Scan - generate initial system.dsc / Makefile"
echo "============================================================"
echo ""
echo "In case of warning: \"Cannot use CONFIG_STACK_VALIDATION=y\""
echo "please install libelf-dev, libelf-devel or elfutils-libelf-devel"
echo ""

check_if_mdis_path "${1}"
CmdResult=$?
if [ ${CmdResult} -eq 0 ]; then
    echo "${1} :is not path"
    exit 1
elif [ ${CmdResult} -eq 1 ]; then
    MEN_LIN_DIR=${1}
    MEN_LIN_DIR=$(get_abs_path "${MEN_LIN_DIR}")
    shift
else
    echo "$1 :invalid path"
    exit 1
fi

# Check if exist and import required sources
source "${MEN_LIN_DIR}/SCAN_SYSTEM_SCRIPTS/map.sh" || \
      { echo "SCAN_SYSTEM/map.sh not found - exit"; exit 1; }
source "${MEN_LIN_DIR}/SCAN_SYSTEM_SCRIPTS/xml_parser.sh" || \
      { echo "SCAN_SYSTEM/xml_parser.sh not found - exit "; exit 1; }

# read parameters
while test $# -gt 0 ; do
    # This 'check_if_mdis_path' part is necessary to make scan_system.sh script
    # compatible with previous versions
    case "$1" in
        -h|--help)
            scan_system_usage
            exit 1
            ;;
        --buildtools)
            shift
            BUILD_TOOLS="1"
            echo "Build mm_ident and fpga_load tool"
            ;;
        --mdiswiz|-y|--yes|--assume-yes)
            shift
            ASSUME_YES=1
            echo "Automatic yes to prompts; assume \"yes\" as answer"
            echo "to all prompts and run non-interactively"
            ;;
        -p)
            shift
            if test $# -gt 0; then
                OUTPUT_DIR_PATH=${1}
                OUTPUT_DIR_PATH=$(get_abs_path "${OUTPUT_DIR_PATH}")
            else
                echo "no path specified"
                exit 1
            fi
            shift
            ;;
        --path*)
            OUTPUT_DIR_PATH=$(echo "${1}" | sed -e 's/^[^=]*=//g')
            OUTPUT_DIR_PATH=$(get_abs_path "${OUTPUT_DIR_PATH}")
            shift
            ;;
        --verbose)
            shift
            if test $# -gt 0; then
                VERBOSE_PRINT=${1}
                echo "Verbose option: ${VERBOSE_PRINT}"
            else
                echo "VERBOSE_PRINT unspecified"
                exit 1
            fi
            shift
            ;;
        --drytest)
            shift
            if test $# -gt 0; then
                PCI_DRYTEST=${1}
                echo "drytest option: ${PCI_DRYTEST}"
            else
                echo "PCI_DRYTEST unspecified"
                exit 1
            fi
            shift
            ;;
        --prerequisites)
            shift
            check_scan_system_prerequisites
            exit 1
            ;;
        --internal-swmodules)
            shift
            INTERNAL_SWMODULES="1"
            echo "Internal sw modules will also be added"
            ;;
        *)
            echo "No valid parameters"
            break
            ;;
        esac
done

if [ ${UID} != 0 ]; then
    echo "*** error: only root can run this script"
    echo "*** if you are running this script via mdiswiz, please run mdiswiz as root"
    exit 1
fi

if [[ ! -d ${OUTPUT_DIR_PATH} ]]; then
    echo "Directory: ${OUTPUT_DIR_PATH} does not exists"
    echo "Creating directory ${OUTPUT_DIR_PATH}"
    mkdir -p "${OUTPUT_DIR_PATH}"
    CmdResult=$?
    if [ "${CmdResult}" != "0" ]; then
        echo "*** error while creating directory"
        exit "${CmdResult}"
    fi
fi

DSC_TPL_DIR="${MEN_LIN_DIR}/BUILD/MDIS/TPL/DSC"
debug_print "MEN_LIN_DIR = ${MEN_LIN_DIR}"

##
# prerequisites
#
check_scan_system_prerequisites
CmdResult=$?
if [ "${CmdResult}" != "0" ]; then
    echo "*** error: prerequisites are not met, see help"
    exit 1
fi

if [[ -e "${OUTPUT_DIR_PATH}/${DSC_FILE}" && ${SCAN_SIM} == 0 ]]; then
    echo "Backing up system.dsc"
    mv "${OUTPUT_DIR_PATH}/${DSC_FILE}" "${OUTPUT_DIR_PATH}/${DSC_FILE}.bak"
fi
if [[ -e "${MAKE_FILE}" && ${SCAN_SIM} == 0 ]]; then
    echo "Backing up Makefile"
    mv "${MAKE_FILE}" "${MAKE_FILE}.bak"
fi


if [ "$PCI_DRYTEST" == "" ]; then
    # write PCI devices into tmp file for further analysis
    if [[ -e ${TMP_PCIDEVS} && ${SCAN_SIM} == 0 ]]; then
        rm ${TMP_PCIDEVS}
    fi
    if [ ${SCAN_SIM} == 0 ]; then
    "${MEN_LIN_DIR}/BIN/${FPGA_LOAD}" -s > "${TMP_PCIDEVS}"
    count_f205_boards
    fi

else
    echo "PCI_DRYTEST set, using file ${PCI_DRYTEST}"
    TMP_PCIDEVS=${PCI_DRYTEST}
fi

# check target architecture, for non -x86 target system rebuild tools:
# fpga_load, mm_ident tool
CPU_ARCHITECTURE=$(arch | grep "86")
if [ "${BUILD_TOOLS}" == "1" ] || [ "${CPU_ARCHITECTURE}" == "" ]; then
    compile_mm_ident
    CmdResult=$?
    echo "compile_mm_ident=${CmdResult}"

    if [ "${CmdResult}" == "0" ]; then
        # Rewrite mm_ident binary in MDIS installed sources
        cp "${MEN_LIN_DIR}TOOLS/mm_ident/mm_ident" "${MEN_LIN_DIR}BIN/mm_ident"
        echo "mm_ident tool copied into ${MEN_LIN_DIR}BIN/"
    fi

    compile_fpga_tools
    CmdResult=$?
    echo "compile_fpga_tools=${CmdResult}"
    if [ "${CmdResult}" == "0" ]; then
        # Rewrite mm_ident binary in MDIS installed sources
        cp "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/fpga_load" "${MEN_LIN_DIR}BIN/fpga_load"
        echo "fpga_load tool copied into ${MEN_LIN_DIR}BIN/"
    fi
fi

# all ok, let the games begin...
# check on which CPU we are running

detect_board_id
G_SmBusNumber=${smbus}
main_cpu=$(echo "${G_cpu}" | awk '{print substr($1,1,4)}')
wiz_model_cpu=""
echo "Found CPU: ${main_cpu}. Using SMB address ${G_SmBusNumber} for SMB2 based drivers"
#default for most F1x cards
wiz_model_busif=1
bCreateXm01bcDrv=0
bCreateF14bcDrv=0
bCreateSmb2GenericDrv=0

COMMIT_ID=$(cat "${MEN_LIN_DIR}/HISTORY/13MD05-90_version.txt")
DATE=$(LANG=en_us_88591; date)
# Add cretion note into system.dsc file
echo "# ${CREATION_NOTE}" > "${OUTPUT_DIR_PATH}/${DSC_FILE}"
echo "# ${COMMIT_ID}" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
echo "# ${DATE}" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"

makeMdisDriversFileMap

#unfortunately some F-cards seem to be have IDs with and without '0' (marketing name)
case $main_cpu in
    CB70)
        wiz_model_cpu=CB70C
        wiz_model_smb=SMBPCI_FCH
        ;;
    SC24)
        wiz_model_cpu=Bx50x
        wiz_model_smb=SMBPCI_FCH
        ;;
    SC25)
        wiz_model_cpu=Bx70x
        wiz_model_smb=SMBPCI_FCH
        ;;
    SC31)
        wiz_model_cpu=Bx51x
        wiz_model_smb=SMBPCI_FCH
        ;;
    F011)
        wiz_model_cpu=F11S
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x3c
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    F11S)
        wiz_model_cpu=F11S
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x3c
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    F14|F014)
        wiz_model_cpu=F14
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        add_mdis_drivers "XM01BC"
        ;;
    F15)
        wiz_model_cpu=F15
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        add_mdis_drivers "XM01BC"
        ;;
    F015)
        wiz_model_cpu=F15
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        add_mdis_drivers "XM01BC"
        ;;
    F17|F017)
        wiz_model_cpu=F17
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateF14bcDrv=1
        add_mdis_drivers "F14BC"
        ;;
    F19P|F19C|F019)
        wiz_model_cpu=F19P_F19C
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    F21P|F21C|F021)
        wiz_model_cpu=F21P_F21C
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        wiz_model_busif=0
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    F026)
        wiz_model_cpu=F26L
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        wiz_model_busif=0
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    F022|F22P)
        wiz_model_cpu=F22P
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        wiz_model_busif=0
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    F023|F23P)
        wiz_model_cpu=F23P
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=0
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    F075|F75P)
        wiz_model_cpu=F75P
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x18
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    XM01)
        wiz_model_cpu=XM1
        wiz_model_smb=SMBPCI_SCH
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    MM01)
        wiz_model_cpu=MM1
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x1c
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_mdis_drivers "SMB2"
        ;;
    G20-)
        wiz_model_cpu=G20
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        add_z001_io_support
        bCreateXm01bcDrv=1
        ;;
    G22-|G022)
        wiz_model_cpu=G22
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        bCreateSmb2GenericDrv=1
        bCreateXm01bcDrv=1
        add_mdis_drivers "XM01BC"
        add_z001_io_support
        add_mdis_drivers "SMB2"
        ;;
    G23-|G023)
        wiz_model_cpu=G23
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_z001_io_support
        add_mdis_drivers "SMB2"
        ;;
    G25-|G25A|G025)
        wiz_model_cpu=G25A
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_mdis_drivers "XM01BC"
        add_z001_io_support
        add_mdis_drivers "SMB2"
        ;;
    A025)
        makeVMEDriversFileMap
        wiz_model_cpu=A25
        add_vme_drivers "TSI148"
        G_mdisExtraDefs+=" -DCONFIG_MEN_VME_KERNELIF"
        ;;
    *)
        echo "No MEN CPU type found!"
        ;;
esac

debug_print "Using _WIZ_MODEL = ${wiz_model_cpu}"

# create SC24 based Bx50x CPU model
if [ "${main_cpu}" == "SC24" ]; then
    map_sc24_fpga
    < "${DSC_TPL_DIR}/sc24.tpl" sed "s/SCAN_WIZ_MODEL/${wiz_model_cpu}/g; s/SCAN_SMBNR1/$(printf 0x%x "$((G_SmBusNumber - 1))")/g; s/SCAN_SMBNR2/$(printf 0x%x "${G_SmBusNumber}")/g;" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
    blacklist_warning_message
    cat "${DSC_TPL_DIR}/Makefile.sc24.tpl" >> "${MAKE_FILE}"
# create SC25 based Bx70x CPU model - no FPGA mapping necessary here
elif  [ "${main_cpu}" == "SC25" ]; then 
    < "${DSC_TPL_DIR}/sc25.tpl" sed "s/SCAN_WIZ_MODEL/${wiz_model_cpu}/g;" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
    blacklist_warning_message
    cat "${DSC_TPL_DIR}/Makefile.sc24.tpl" >> "${MAKE_FILE}"
elif  [ "${main_cpu}" == "SC31" ]; then 
    < "${DSC_TPL_DIR}/sc31.tpl" sed "s/SCAN_WIZ_MODEL/${wiz_model_cpu}/g; s/SCAN_SMB_BUS_NR/$(printf 0x%x "${G_SmBusNumber}")/g;" >> "${OUTPUT_DIR_PATH}/${DSC_FILE}"
    blacklist_warning_message
    cat"${DSC_TPL_DIR}/Makefile.sc31.tpl" >> "${MAKE_FILE}"
else
    #all other CPUs: detect PCI boards, start with CPU/SMB drivers
    create_entry_dsc_cpu_type "${DSC_TPL_DIR}" "${wiz_model_cpu}"
    create_entry_dsc_smb_type "${DSC_TPL_DIR}" "${G_SmBusNumber}" "${wiz_model_smb}" "${wiz_model_busif}"
    if [ "${bCreateSmb2GenericDrv}" == "1" ]; then
        create_entry_dsc_smb_drv  "${DSC_TPL_DIR}" "${G_SmBusNumber}" smb2_1 SMB2 SMB2 "${G_SmbDeviceSlotNumber}"
        add_device_smb_scan_list "${DSC_TPL_DIR}" "${G_SmbDeviceSlotNumber}" smb2_1
        G_SmbDeviceSlotNumber=$((G_SmbDeviceSlotNumber+1))
    fi
    if [ "${bCreateXm01bcDrv}" == "1" ]; then
        create_entry_dsc_smb_drv  "${DSC_TPL_DIR}" "${G_SmBusNumber}" xm01bc_1 XM01BC XM01BC "${G_SmbDeviceSlotNumber}"
        add_device_smb_scan_list "${DSC_TPL_DIR}" "${G_SmbDeviceSlotNumber}" xm01bc_1
        G_SmbDeviceSlotNumber=$((G_SmbDeviceSlotNumber+1))
    fi
    if [ "${bCreateF14bcDrv}" == "1" ]; then
        create_entry_dsc_smb_drv "${DSC_TPL_DIR}" "${G_SmBusNumber}" f14bc_1 F14BC F14BC "${G_SmbDeviceSlotNumber}"
        add_device_smb_scan_list "${DSC_TPL_DIR}" "${G_SmbDeviceSlotNumber}" f14bc_1
        G_SmbDeviceSlotNumber=$((G_SmbDeviceSlotNumber+1))
    fi
    #insert all smb drv scan list into smb2_1 device
    fill_entry_dsc_smb_scan_list

    debug_print "Check if all required memory regions are enabled"
    enable_memory_regions
    echo "Scanning for MEN PCI devices: "
    scan_for_pci_devs "${G_primPciPath}"
    # display mcb blacklist warning if fpga is in use 
    if [ ! "${count_instance_f2xx}" == "0" ]; then
        blacklist_warning_message
    fi
    # dsc section build done, now create the Makefile
    create_makefile
    echo "Makefile and system.dsc files are located in:"
    echo "${OUTPUT_DIR_PATH}"
fi

# remove unnecessary fields from dsc file
sed -i ':a;N;$!ba;s/#SCAN_NEXT_DEVID\n//g' "${OUTPUT_DIR_PATH}/${DSC_FILE}"

echo "Finished"
