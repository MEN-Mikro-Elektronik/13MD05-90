#!/bin/bash
############################################################################
#
# scan_system.sh   script to generate an automatic MDIS configuration
#                  when doing a selfhosted project
#
#                  The script checks which CPU we are on. The SMB2 drivers
#                  are always added to the CPU to provide BMC and watchdog
#                  drivers.
#
#                  Some simplifications were made to make generating the
#                  system.dsc easier:
#                  - BBIS instances are numbered in straight ascending order.
#                    E.g. if 2xF208, 2xF210 are present they are not labeled
#                    like by MDIS wizard: f208_1, f208_2, f210_1, f210_2
#                    but instead: f208_1,f208_2,f210_3,f210_4.
#                  - the same is done with MDIS devices.
#
# parameters:
# $1    MEN_LIN_DIR   path to MDIS installation, passed by mdiswizard
#                     (if script is run manually it must be passed)
# $2    verbosity     if "1" then additional debug info is dumped
# $3    PCI drytest   if passed as alternative PCI devices temp file the
#                     default file /tmp/men_pci_devs is not written. Used to
#                     test system.dsc generation with predefined test data.
############################################################################
# copyright (c) 2013-2019 MEN Mikro Elektronik GmbH Nuremberg
############################################################################

##########
# DEFINES
readonly CREATION_NOTE="Generated by scan_system.sh script version: "
#            <commit_id>
#            <date>

# proc entry to scan pci devs
PROC_PCI_DEV=/proc/bus/pci/devices
# where the linux kernel sources/headers are expected
LIN_SRC_DIR=/usr/src/linux
# where are the SMBus controller drivers located ?
MOD_DIR=/lib/modules/`uname -r`

# currently detected CPU boards. ADD NEW BOARDS HERE!
# also take care for special (native) driver adding etc.
CPU_KNOWN_BOARDS="SC25 SC24 SC31 F011 F11S F14- F014 F15- F015 F17- F017 F075 F75P F19P F19C F019 F21P F22P F23P F21C F021 F026 XM01 MM01 G20- G22- G022 G22A G23- G23A G25- G25A G025"

# which SMB adresses to scan for CPU ID eeproms
ID_EEPROM_ADRESSES="0x57 0x55"
# the generated example system dsc
DSC_FILE=system.dsc  #.example
# the generated example Makefile
MAKE_FILE=Makefile   #.example
# the generated example Makefile
TMP_MAKE_FILE=/tmp/Makefile   #.example
# temporary BBIS section file to add BBIS data first, then DEVICE_IDV2_x data
TMP_BBIS_DSC=/tmp/bbis.dsc.tmp
# temporary PCI device file to iterate through
TMP_PCIDEVS=/tmp/men_pci_devs.tmp
# temporary chameleon table file to scan IPcore IDs
TMP_CHAM_TBL=/tmp/men_cham_tbl.tmp
# temporaty F205 devices file
TMP_F205_DSC=/tmp/men_f205.dsc.tmp
# fpga_load to use (32/64 bit)
# (Mind: without ia32 lib 32bit programs cant run under 64bit)
FPGA_LOAD=fpga_load
# mm_ident to use
MM_IDENT=mm_ident
# debugging/verbosity: 0=none, 1=verbose 2=verbose+function arguments
VERBOSE_PRINT=0
# run drytest with test PCI device list ?
PCI_DRYTEST=""


# really writing pcitree/temp. cham table or use simulation data ?
# 0 = normal operation, scan and write PCI devices
# 1 = use predefined /tmp/men_pci_devs.tmp file to run tests
SCAN_SIM=0

# for simulation add here which SMBus and CPU shall be assumed
SCAN_SIM_SMBUS=0
SCAN_SIM_CPU="MM01"

#########
# GLOBALS

# MDIS instance label
G_mdisInstanceCount=1

# CPU on which we run, detected in ID EEprom on SMbus <G_SmBusNumber>
G_cpu=""
G_SmBusNumber=0
G_SmbDeviceSlotNumber=0 
# PCI_BUS_xxx entries for all MDIS devs within one chameleon BBIS device.
G_bus_slot_count=0
G_primPciPath=0

# counting PCI_BUS_SLOT number for cPCI Standard cards like F210. Begins per
# default at 2 (1 = system slot)
G_cPciRackSlotStandard=2

# counting PCI_BUS_SLOT number for cPCI Serial cards like G215
# default at 2 (1 = system slot)
G_cPciRackSlotSerial=2

# number of detected F205 like carrier boards
G_cF205=0

# lists for driver/library/program mak files
G_makefileLlDriver=""
G_makefileLlTool=""
G_makefileBbisDriver=""
G_makefileNatDriver=""
G_makefileUsrLibs=""
# DEVICE_IDV2_xx list
G_deviceIdV2=""
# SMB device list 
G_smbDeviceList=""
# list of all used makefiles so far
G_makefileUniqList=""

### @brief M-Module ID to XML file map
declare -A mmodFileList
### @brief M-Module specification map
declare -A mmodSpecList
### @brief M-Moudle instance counters
declare -A mModuleInstances=()
### @brief IP Core ID to XML file map
declare -A ipcoreFileList
### @brief IP Core specification map list
declare -a ipcoreSpecList=()

############################################################################
# verbose debug outputs if VERBOSE_PRINT is 1 or 2
#
# parameters: $1  text to print
#
function debug_print {
    if [ "$VERBOSE_PRINT" == "1" ]; then
        echo $1
    elif [ "$VERBOSE_PRINT" == "2" ]; then
        echo $1
    fi
}

function debug_args {
    if [ "$VERBOSE_PRINT" == "2" ]; then
        echo $1
    fi
}

############################################################################
# usage text
#
function usage {
    echo " scan_system <MEN_LIN_DIR> [verbosity] [PCI simulation file]"
    echo
    echo " used together with MDIS wizard or to be called standalone."
}

############################################################################
# determine if an ID EEprom content is really a MEN CPU. A check if the
# characters are ASCII isnt enough because from DDC ports or other bitbang
# interfaces any char salad might be returned. Save approach: check
# explicitely for our CPU names
#
# parameters: $1     found string
#
function check_if_men_cpu {
    detectedCpu=$1
    for i in $CPU_KNOWN_BOARDS;
    do
    debug_print "\$i = $i  detectedCpu = $detectedCpu"
    if [ "$i" == "$detectedCpu" ] ; then
        G_cpu=$i;
        echo "found matching CPU: $i"
        break
    else
        G_cpu="";
    fi
    done
}


############################################################################
# scan for production data EEPROM to find out who we are
#
# parameters: N/A
#
function detect_board_id {
    echo "Scanning for MEN ID EEProm."
    # these can be safely assumed to exist on any recent distribution.
    modprobe i2c-dev   # for i2cdetect
    modprobe i2c-i801  # F1x SMB controllers

    # these might not exist on all Distros
    if [ -e "$MOD_DIR/kernel/drivers/i2c/busses/i2c-isch.ko" ]; then
        modprobe i2c-isch
    fi
    if [ -e "$MOD_DIR/kernel/drivers/i2c/busses/i2c-piix4.ko" ]; then
        modprobe i2c-piix4 # SC24 SMB controller. Use 13SC24-90 modified driver!
    fi

    G_cpu=""
    for adrs in $ID_EEPROM_ADRESSES; do
    for dev in /dev/i2c-*; do
        smbus=`echo $dev | awk '{print substr($1,10,2)}'`
            # scan for ID EEprom 0x55 at every present bus
        echo "scan SMBus: bus $smbus SMB addr $adrs"
        RES=`i2cdump -r 9-12 -y $smbus $adrs b | tail -n 1 | awk '{print $6}'`

        check_if_men_cpu $RES

        if [[ $SCAN_SIM == 1 && $smbus == $SCAN_SIM_SMBUS ]]; then
        G_cpu=$SCAN_SIM_CPU
        echo "- simulating CPU $G_cpu on bus $smbus"
        break
        fi
        # board found ? break inner loop
        if [ "$G_cpu" != "" ]; then
        break
        fi
    done;

    # board found ? break outer loop
    if [ "$G_cpu" != "" ]; then
        break
    fi
    done

    if [ "$G_cpu" == "" ]; then
        echo "*** could not find CPU type or no ID EEprom present!"
    exit 1
    fi
}


############################################################################
# Map SC24 FPGA (in case old BIOS is present)
# the IRQ settings are switched on loading BBIS driver
#
# parameters: N/A
#
function map_sc24_fpga {
    echo "SC24 detected, mapping FPGA."
    # PCI location is fixed (inside AMD chipset)
    setpci -s 00:14.3 0x48.B=0x27
    setpci -s 00:14.3 0x60.B=0x00
    setpci -s 00:14.3 0x61.B=0xe0
    setpci -s 00:14.3 0x62.B=0x01
    setpci -s 00:14.3 0x63.B=0xe0
}


############################################################################
# write the smb section for the cpu in the system.dsc
#
# parameters:
# $1    DSC template directory
# $2    SM Bus number
# $3    SMB driver, e.g. SMBPCI_ICH
# $4    SMB bus IF nr "cpu,0' or "cpu,1" etc
#
function create_entry_dsc_smb_type {
    echo "Writing CPU SMB BBIS section."
    #echo " _WIZ_MODEL = $3, SM Bus nr. = $2  SM Bus IF nr. = $4 "
    cat $1/smb.tpl | sed "s/SCAN_SMBDRV/$3/g; s/SCAN_SMBNR/`printf \"0x%x\" $2`/g; s/SCAN_SMBUSIF/$4/g;" >> $DSC_FILE
}

############################################################################
# write the smb devices list into smb section for the cpu
#
# parameters:
# None
#
function fill_entry_dsc_smb_scan_list {
    echo "fill smb devices scan list in system.dsc file"
    dscTmpFile=$(<$DSC_FILE)
    formattedSmbDeviceList="$(echo "${G_smbDeviceList}" | sed ':a;N;$!ba;s/\n/\\n/g' )"
    dscTmpFile=$(echo -e "$dscTmpFile" | sed "s/SCAN_LIST_OF_SMB_DEVICES/$formattedSmbDeviceList/g")
    #echo "$dscTmpFile"
    echo "$dscTmpFile" > "$DSC_FILE"
}

############################################################################
# add smb single device into list of smb devices
#
# parameters:
# $1    DSC template directory
# $2    SMB device number
# $3    SMB device name 
#
function add_device_smb_scan_list {
    echo "add_device_smb_scan_list"
    tmpSmbDeviceList=$(cat $1/smb_device.tpl | sed "s/SCAN_SMB_DEV_NUMBER/$2/g;s/SCAN_SMB_DEV_NAME/$3/g")
    # new line is not required for the first device    
    if [ "$2" == "0" ]; then
        G_smbDeviceList+="$tmpSmbDeviceList"
    else
        G_smbDeviceList+="\n$tmpSmbDeviceList"
    fi
}

############################################################################
# write the smb section for the cpu in the system.dsc
#
# parameters:
# $1    DSC template directory
# $2    SCAN_MDIS_INSTANCE nr of found PP04
# $3    SCAN_BBIS_INSTANCE carrier boards instance
#
function create_entry_dsc_pp04 {
    echo "Writing PP04 MDIS driver section."
    #echo " _WIZ_MODEL = $3, SM Bus nr. = $2  SM Bus IF nr. = $4 "
    cat $1/pp04.tpl | sed "s/SCAN_MDIS_INSTANCE/$2/g;s/SCAN_BBIS_INSTANCE/$3/g" >> $DSC_FILE
    if [ "$2" == "1" ]; then
        G_makefileLlDriver+=" PP04/DRIVER/COM/driver.mak"
    fi
}


############################################################################
# write a SMB driver section
#
# parameters:
# $1    DSC template directory
# $2    SM Bus number
# $3    MDIS device name, e.g. xm01bc_1 or smb2_2
# $4    HW_TYPE, e.g. XM01BC (not always the capitalized MDIS dev. type
# $5    WIZ_MODEL
#
function create_entry_dsc_smb_drv {
    echo "creating CPU SMB driver section: _WIZ_MODEL = $3, SM Bus nr. = $2 at DEVICE_SLOT = $6"

    if [ "$3" == "smb2_1" ]; then
        cat $1/smb_drv_no_addr.tpl | \
        sed "s/SCAN_DEVNAME/$3/g;s/SCAN_HWTYPE/$4/g;s/SCAN_WIZMODEL/$5/g;s/SCAN_SMBNR/`printf \"0x%x\" $2`/g;s/SCAN_DEVICE_SLOT/`printf \"0x%x\" $6`/g" >> $DSC_FILE
    else
        cat $1/smb_drv.tpl | \
        sed "s/SCAN_DEVNAME/$3/g;s/SCAN_HWTYPE/$4/g;s/SCAN_WIZMODEL/$5/g;s/SCAN_SMBNR/`printf \"0x%x\" $2`/g;s/SCAN_DEVICE_SLOT/`printf \"0x%x\" $6`/g" >> $DSC_FILE
    fi 
}


############################################################################
# write the cpu section of the system.dsc file
#
# parameters:
# $1    DSC template directory
# $2    _WIZ_MODEL
#
function create_entry_dsc_cpu_type {
    echo "Writing system.dsc cpu section: _WIZ_MODEL = $2"
    cat $1/cpu.tpl | sed "s/SCAN_CPU/$2/g" >> $DSC_FILE
}


############################################################################
# write a chameleon BBIS section
#
# parameters:
# $1 DSC template directory
# $2 BBIS instance number  (subst. SCAN_BBIS_INSTANCE )
# $3 _WIZ_MODEL, e.g. F210 (subst. SCAN_WIZ_MODEL   )
# $4 PCI bus number        (subst. SCAN_PCI_BUS_NR  )
# $5 PCI device nr..       (subst. SCAN_PCI_DEV_NR  )
# $6 DEVICE_IDV2_x array of found IP cores inside this BBIS device
#
# Addendum 05/2015: With the new unified generic mezz_cham carrier we must check
# if its a cPCI Serial card (G2xx, e.g. G215) or a parallel cPCI card like F2xx.
# Based on this the position can be rougly estimated on the FPGA file name:
#  
#  Example entries for a hybrid backplane: 
#
#  standard cPCI slots          cPCI Serial slots
#   
# cpu,1 cpu,1 cpu,1 cpu,1       cpu,2 cpu,3 cpu,4 cpu,5      <- _WIZ_BUSIF = STRING ...  
#   5     4     3     2    SYS    2     3     4     5        <- PCI_BUS_SLOT = U_INT32 ...
#  ---   ---   ---   ---   ---   
#  | |   | |   | |   | |   | | 
#  | |   | |   | |   | |   | | 
#  | |   | |   | |   | |   | | 
#  | |   | |   | |   | |   | |  
#  | |   | |   | |   | |   | |   ----  ----  ----  ----
#  | |   | |   | |   | |   | |   |  |  |  |  |  |  |  |
#  ---   ---   ---   ---   ---   ----  ----  ----  ----  
#
#  This results in the following algorithm described below. In this script we can 
#  not detect the true physical slots, so we assign just incrementing slots according to
#  each card type (cPCI serial, standard cPCI)
#
function create_entry_dsc_bbis_cham {
    echo "create chameleon BBIS device - based on lspci data"
    debug_args " \$1 = ${1}  \$2 = ${2}  \$3 = ${3}  \$4 = ${4}  \$5 = ${5}  \$6 = ${6}"
    
    local pci_vd=$(echo ${1} | sed "s:"0x":"":g")
    local pci_dev=$(echo ${2} | sed "s:"0x":"":g")
    local pci_devnr=${3}
    local pci_subv=$(echo ${4} | sed "s:"0x":"":g")
    local tpl_dir=${5}
    local pci_busnr=${6}

    local wiz_mod="MEZZ_CHAM"
    
    local lspci_device_verbose_data=$(lspci -s $(lspci -d ${pci_vd}:${pci_dev} -m | grep "${pci_subv}" | cut -f 1 -d " ") -v)
    debug_args "${lspci_device_verbose_data}"

    local is_pcie=$(echo "${lspci_device_verbose_data}" | grep "Capabilities.*Express Legacy Endpoint")
    if [ -z "${is_pcie}" ]; then
        echo  "Device: ${pci_vd}:${pci_dev} PCI subvendor: ${pci_subv} is CPCI device"
        local pcibus_slot=${G_cPciRackSlotStandard}
        # for standard cPCI always
        local bus_if="cpu,1"
        # count to next stndard cPCI slot nr.
        G_cPciRackSlotStandard=`expr ${G_cPciRackSlotStandard} + 1`
    else
        echo  "Device: ${pci_vd}:${pci_dev} PCI subvendor: ${pci_subv} is CPCI serial device"
        local pcibus_slot=${G_cPciRackSlotSerial}
        # on cPCI serial the businterface nr. is equal to its slot
        # what about boards that are connected to CPU board?
        local bus_if="cpu,"${G_cPciRackSlotSerial}
        # count to next cPCI serial slot nr.
        G_cPciRackSlotSerial=`expr ${G_cPciRackSlotSerial} + 1`
    fi

    # no support for "MM01-IC..."
    tpl_name=mezz_cham.tpl

    # TODO generate the long filter commands dynamically..
    cat ${tpl_dir}/${tpl_name} | sed "s/SCAN_BBIS_INSTANCE/${bbis_instance}/g;s/SCAN_WIZ_MODEL/${wiz_mod}/g;s/SCAN_WIZ_BUSIF/${bus_if}/g;s/SCAN_PCI_BUS_NR/`printf \"0x%x\" ${pci_busnr}`/g;s/SCAN_PCI_BUS_SLOT/`printf \"0x%x\" ${pcibus_slot}`/g;s/SCAN_PCI_DEV_NR/`printf \"0x%x\" ${pci_devnr}`/g" > ${TMP_BBIS_DSC}

}
############################################################################
# write all MDIS device sections for the detected BBIS entry (cham device)
#
# The scan of IPcore entries per chameleon device is done 2 times, first to
# just collect DEVICE_IDV2 data to write the BBIS section in system dsc,
# then also to generate every MDIS device section. The BBIS section
#
# parameters:
# $1  DSC template directory
# $2  FPGA file name, e.g. 'F210'
# $3  BBIS board instance number ( x as in f210_x)
# $4  0: just get DEVICE_IDV2 data (to complete BBIS dsc entry)
#     1: also write MDIS dsc data  (to add device sections below BBIS entry)
# $5  PCI device
#
function scan_cham_table {
    debug_args "\$1 = $1 \$2 = $2 \$3 = $3 \$4 = $4 "
    fpga_file=$2
    bbis_instance=$3
    do_parse=0
    write_mdis_dsc=$4
    local ipcoreId
    local ipcoreXml
    local ipcoreType
    local ipcoreName
    local ipcoreHwName
    local ipcoreSettings
    local -i listSize
    local -i listItem
    local -a listChoice
    local -i i
    local listName
    local listEntry
    local listPrompt
    local itemMatch
    local hwName

    while read devline <&3; do
    if [ "$do_parse" == "1" ]; then
        ipcore=`echo $devline | awk '{print $3}'`
        devid=`echo $devline | awk '{print $2}' | awk '{print substr($1,5,2)}'`
        inst_raw=`echo $devline | awk '{print $5}'`
        instance=`printf "%02x" $inst_raw`

        makeIpCoreFileMap
        ipcoreId="$((16#${devid}))"
        ipcoreXml="${ipcoreFileList["${ipcoreId}"]}"
        if [ "${ipcoreXml}" == "" ]; then
            is_cham_dev=0
        fi

        if [ "${ipcoreXml}" != "" ] ; then
            G_deviceIdV2+=" 0x$devid$instance"
            if [ $write_mdis_dsc == "1" ]; then
                makeIpCoreOutputData "${ipcoreId}"
                listItem="0"
                listChoice=()
                listSize="${#ipcoreSpecList[@]}"
                if [ "${listSize}" -gt "1" ]; then
                    itemMatch=""
                    for (( i=0; i<listSize; i++ )); do
                        listName="${ipcoreSpecList[${i}]}"
                        hwName="$(mapGet "${listName}" "hwname")"
                        if [ "${hwName}" == "${ipcore}" ]; then
                            if [ "${itemMatch}" == "" ]; then
                                itemMatch="${i}"
                            else
                                itemMatch=""
                                break
                            fi
                        fi
                    done
                    if [ "${itemMatch}" != "" ]; then
                        listItem="${itemMatch}"
                    else
                        for (( i=0; i<listSize; i++ )); do
                            listName="${ipcoreSpecList[${i}]}"
                            listEntry="$(mapGet "${listName}" "hwname")"
                            listEntry+=" - $(mapGet "${listName}" "description")"
                            listChoice+=("${listEntry}")
                        done
                        listPrompt="There are ${listSize} drivers matching IP core ${ipcore} #${inst_raw} on PCI device ${5}"
                        listPrompt+=$'\n'
                        listPrompt+="Which one would you like to use?"
                        displayQuestion "${listPrompt}" "${listChoice[@]}"
                        listItem="${?}"
                    fi
                fi
                if [ "${listItem}" -ge "${listSize}" ]; then
                    echo "*** Aborted by user."
                    exit "1"
                fi

                listName="${ipcoreSpecList[${listItem}]}"
                bbis_name=`echo $fpga_file | awk '{print tolower($1)}'`
                ipcoreType="$(mapGet "${listName}" "devnameprefix")"
                ipcoreHwName="$(mapGet "${listName}" "hwname")"
                ipcoreName="$(mapGet "${listName}" "name")"
                if [ "${ipcoreName}" == "" ]; then
                    ipcoreName="$(mapGet "${listName}" "swname")"
                fi
                ipcoreSettings="$(mapGet "${listName}" "settings")"
                if [ "${ipcoreSettings}" != "" ]; then
                    ipcoreSettings="${ipcoreSettings//$'\n'/\\n}"
                fi

                echo "Writing ${ipcoreType,,}_${G_mdisInstanceCount} section to system.dsc"

                cat $1/16zX.tpl | sed "s/SCAN_MDIS_INSTANCE/$G_mdisInstanceCount/g;s/SCAN_BBIS_NAME/$bbis_name/g;s/USCORESCAN_BBIS_INSTANCE/_$bbis_instance/g;s/SCAN_DEV_SLOT/`printf \"0x%x\" $G_bus_slot_count`/g;s/SCAN_IPCORE_TYPE/${ipcoreType,,}/g;s/SCAN_IPCORE_NAME/${ipcoreName^^}/g;s/SCAN_WIZMODEL_NAME/${ipcoreHwName}/g;s/SCAN_DEVICE_SETTINGS/${ipcoreSettings}/g;" >> $DSC_FILE

                G_bus_slot_count=`expr $G_bus_slot_count + 1`
                G_mdisInstanceCount=`expr $G_mdisInstanceCount + 1`

                G_makefileNatDriver+=" $(mapGet "${listName}" "Native_Driver")"
                G_makefileLlDriver+=" $(mapGet "${listName}" "Low_Level_Driver")"
                G_makefileLlTool+=" $(mapGet "${listName}" "Driver_Specific_Tool")"
                G_makefileUsrLibs+=" $(mapGet "${listName}" "User_Library")"

                for (( i=0; i<listSize; i++ )); do
                    mapDelete "${ipcoreSpecList[${i}]}"
                done
            fi
        fi
    fi # do_parse

    # skip to begin of IP cores table
    delimiter=`echo $devline | awk '{print $1}'`
    if [ "$delimiter" == "---" ]; then
        do_parse=1
    elif [ "$delimiter" == "" ]; then
        do_parse=0
    fi

    done 3< $TMP_CHAM_TBL
}


############################################################################
# check if a PCI device is a MEN chameleon device
#
# if a chameleon device is found ( valid chameleon table could be dumped)
# the table is parsed, BBIS name and wizard model extracted.
# After scanning the IP cores the DEVICE_IDV2_x = U_INT32 0x.... entry is
# added.
#
# example:
#  8 0x0022 16Z034_GPIO      0    0   0   9  63   0 0x00000a00 0x91100a00
#  9 0x0022 16Z034_GPIO      0    1   0   9  63   0 0x00000b00 0x91100b00
# 10 0x0022 16Z034_GPIO      0    2   0   9  63   0 0x00000c00 0x91100c00
#  is converted into:
#  DEVICE_IDV2_0 = U_INT32 0x2200
#  DEVICE_IDV2_1 = U_INT32 0x2201
#  DEVICE_IDV2_2 = U_INT32 0x2202
#
# parameters:
# $1  MEN linux dir (/opt/menlinux)
# $2  PCI vendor
# $3  PCI device id
# $4  PCI device nr.
# $5  PCI subvendor
# $6  instance count
# $7  pci primary path
# $8  pci bus nr.
#
function check_for_cham_devs {
    debug_args "MEN_LIN_DIR:$1 pcivend:$2 pcidevid:$3 pcidevnr:$4  pcisubvend:$5 count_instance_f2xx:$6 pcibus:$7"
    cham_file=""
    device_id_count=0

    # check if we find a chameleon table
    $1/BIN/$FPGA_LOAD $2 $3 $5 0 -t > /dev/null
    if [[ $? == "0" || "$SCAN_SIM" == "1" ]]; then
        # store temp. cham table ( '>' to start new file!)
        if [ "$SCAN_SIM" == "0" ]; then
            $1/BIN/$FPGA_LOAD $2 $3 $5 0 -t > $TMP_CHAM_TBL
        fi

        # extract board name from 'file='
        # cham_file=`fgrep "file=" $TMP_CHAM_TBL | awk '{print substr($1,6,4)}'`
        # ts: new generic chameleon carrier is named mezz_cham_<instance>
        cham_file="mezz_cham"
        debug_print "cham_file = $cham_file (= _WIZ_MODEL)"
        inst_count=$6

        G_bus_slot_count=0 # in next BBIS carrier PCI_BUS_SLOT starts at 0 again
        G_deviceIdV2=""    # clear list of IDs for next BBIS

        # gather DEVICE_IDV2 data for this BBIS first
        scan_cham_table $DSC_TPL_DIR $cham_file $inst_count 0 "${7}:${4}:0"

            # Now add the found device IDs to temporary BBIS desc file
        create_entry_dsc_bbis_cham $2 $3 $4 $5 $DSC_TPL_DIR $7
        for id in $G_deviceIdV2; do
            # format data into a DEVICE_IDV2 entry and add same scan tag in next line
            idv2line="    DEVICE_IDV2_$device_id_count = U_INT32 $id\n#SCAN_NEXT_DEVID"
            sed -i.bak "s/#SCAN_NEXT_DEVID/$idv2line/g" $TMP_BBIS_DSC
            device_id_count=`expr $device_id_count + 1`
        done
            # BBIS dsc section now complete. append it to $DSC_FILE
        cat $TMP_BBIS_DSC >> $DSC_FILE

        # all F2xx BBIS are supported by chameleon PCI table driver..
        G_makefileBbisDriver+=" CHAMELEON/DRIVER/COM/driver_pcitbl.mak"

        # create MDIS dev entries under this BBIS device
        G_bus_slot_count=0
        G_deviceIdV2=""    # clear list of IDs for next BBIS
        scan_cham_table $DSC_TPL_DIR $cham_file $inst_count 1 "${7}:${4}:0"
    fi

}


############################################################################
# create a f223_x BBIS section plus 1 gpio driver on it.
# The assigned gpio driver instance number is equal to
# the BBIS instance (instance of found F223) so on f223_1
# theres pi7c9_gpio_1, on f223_2 theres pi7c9_gpio_2 etc.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI bus number (subst. SCAN_PCI_BUS_NR tag)
# $4  PCI device number (subst. SCAN_PCI_DEV_NR tag)
#
function create_entry_dsc_f223 {
    echo "Writing f223_$2 section to system.dsc "
    debug_args " \$1 = $1   \$2 = $2    \$3 = $3    \$4 = $4  "
    cat $1/f223.tpl  | sed "s/SCAN_BBIS_INSTANCE/$2/g;"\
"s/SCAN_MDIS_INSTANCE/$2/g;s/SCAN_PCI_BUS_NR/`printf \"0x%x\" $3`/g;"\
"s/SCAN_PCI_DEV_NR/`printf \"0x%x\" $4`/g" >> $DSC_FILE

}

############################################################################
# create a f207_x BBIS section.
# F207 section is added when a PP04 was found.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI_BUS primary path (subst. SCAN_PCIPATH_PRIM tag)
# $4  PCI_BUS sec. path (subst. SCAN_PCIPATH_SEC tag)
#
function create_entry_dsc_f207 {
    echo "Writing f207_$2 section to system.dsc "
    debug_args " \$1 = $1 \$2 = $2  \$3 = $3  \$4 = $4 "
    cat $1/f207.tpl  | sed "s/SCAN_BBIS_INSTANCE/$2/g;s/SCAN_PCIPATH_PRIM/`printf \"0x%x\" $3`/g;s/SCAN_PCIPATH_SEC/`printf \"0x%x\" $4`/g" >> $DSC_FILE
}

############################################################################
# create a d203_x BBIS section.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI_BUS slot (subst. SCAN_SMBUSIF tag)
# $4  PCI_BUS number (subst. SCAN_PCI_BUS_NR tag)
# $5  board name (subst. SCAN_BBIS_NAME tag)
# $6  PCI device number (subst. SCAN_PCI_DEV_NR tag)
# $7  DSC output file
#
function create_entry_dsc_d203 {
    echo "Writing d203_$2 section to system.dsc "
    debug_args " \$1 = $1 \$2 = $2  \$3 = $3  \$4 = $4  \$5 = $5  \$6 = $6 "
    cat $1/d203.tpl  | sed "s/SCAN_BBIS_INSTANCE/$2/g;s/SCAN_SMBUSIF/$3/g;s/SCAN_PCI_BUS_NR/`printf \"0x%x\" $4`/g;s/SCAN_BBIS_NAME/$5/g;s/SCAN_PCI_DEV_NR/`printf \"0x%x\" $6`/g" >> $7
    if [ "$2" == "1" ]; then
        G_makefileBbisDriver+=" D203/DRIVER/COM/driver.mak"
    fi
    scan_for_mmodules $1 $2 d203 $4 $6 0 "A08/D16" $7
}

############################################################################
# create a d203_a24_x BBIS section.
#
# parameters:
# $1  DSC template directory
# $2  instance number (subst. SCAN_BBIS_INSTANCE tag)
# $3  PCI_BUS slot (subst. SCAN_SMBUSIF tag)
# $4  PCI_BUS number (subst. SCAN_PCI_BUS_NR tag)
# $5  board name (subst. SCAN_BBIS_NAME tag)
# $6  PCI device number (subst. SCAN_PCI_DEV_NR tag)
# $7  DSC output file
#
function create_entry_dsc_d203_a24 {
    echo "Writing d203_a24_$2 section to system.dsc "
    debug_args " \$1 = $1 \$2 = $2 \$3 = $3 \$4 = $4 \$5 = $5 \$6 = $6 "
    cat $1/d203_a24.tpl | sed "s/SCAN_BBIS_INSTANCE/$2/g;s/SCAN_SMBUSIF/$3/g;s/SCAN_PCI_BUS_NR/`printf \"0x%x\" $4`/g;s/SCAN_BBIS_NAME/$5/g;s/SCAN_PCI_DEV_NR/`printf \"0x%x\" $6`/g" >> $7
    if [ "$2" == "1" ]; then
        G_makefileBbisDriver+=" D203/DRIVER/COM/driver_a24.mak"
    fi
    scan_for_mmodules $1 $2 d203_a24 $4 $6 0 "A24/D32" $7
}

############################################################################
# add the xm01bc LL driver, tool to LL driver and LL tool list. Some
# F-Cards have a BMC, some dont (F21P). bundle necessary mak file adding here
#
function add_xm01bc_support {
    G_makefileLlTool+=" XM01BC/TOOLS/XM01BC_CTRL/COM/program.mak"
    G_makefileLlDriver+=" XM01BC/DRIVER/COM/driver.mak"
}

############################################################################
# add the xm01bc LL driver, tool to LL driver and LL tool list. Some
# F-Cards have a BMC, some dont (F21P). bundle necessary mak file adding here
#
function add_f14bc_support {
    G_makefileLlTool+=" F14BC/TOOLS/F14BC_CTRL/COM/program.mak"
    G_makefileLlDriver+=" F14BC/DRIVER/COM/driver.mak"
}

############################################################################
# add the xm01bc LL driver, tool to LL driver and LL tool list. Some
# F-Cards have a BMC, some dont (F21P). bundle necessary mak file adding here
#
function add_z001_io_support {
    G_makefileNatDriver+=" DRIVERS/Z001_SMB/driver_g2x.mak DRIVERS/CHAMELEON/driver.mak"
}

############################################################################
# add the smb2_x generic support with tools 
#
function add_smb2_generic_support {
    G_makefileLlTool+=" SMB2/EXAMPLE/SMB2_SIMP/COM/program.mak"
    G_makefileLlTool+=" SMB2/EXAMPLE/SMB2_F601/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_CTRL/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_BOARDIDENT/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_TOUCH/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_BMC_CTRL/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_SHC_CTRL/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_STM32_FLASH/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_EETEMP/COM/program.mak"
    G_makefileLlTool+=" SMB2/TOOLS/SMB2_POE/COM/program.mak"
    G_makefileLlDriver+=" SMB2/DRIVER/COM/driver.mak"
    G_makefileUsrLibs+=" SMB2_SHC/COM/library.mak"
}

############################################################################
# For some MEN CPU boards memory regions are disabled by default while
# booting from UEFI mode.
# This function checks and enable all required memory regions on MEN
# G204/F204/F205 boards
#
function enable_memory_regions {
    while read line <&4; do
        # Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
        #  25   0   5  15   0   0x12d8   0xe110    0x0000
        local listNr="$(echo ${line} | awk '{print $1}')"
        local pciBusHex="$(printf "%x" $(echo ${line} | awk '{print $3}'))"
        local pciDevNrHex="$(printf "%x" $(echo ${line} | awk '{print $4}'))"
        local pciDevFunHex="$(printf "%x" $(echo ${line} | awk '{print $5}'))"
        local pciVend="$(echo ${line} | awk '{print $6}')"
        local pciDevId="$(echo ${line} | awk '{print $7}')"
        local pciSubVend="$(echo ${line} | awk '{print $8}')"
        local memPciDevDisable="$(lspci -s ${pciBusHex}:${PciDevNrHex}.${pciDevFunHex} -v | grep 'Memory at.*disabled' | wc -l )"
        if [ "${memPciDevDisable}" -gt 0 ]; then
            if [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0x203d" ] && [ "${pciSubVend}" == "0x00b9" ]; then
                echo "Found d203 G204 board with 1 M-Module A24 with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            elif [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0xd203" ] && [ "${pciSubVend}" == "0xff00" ]; then
                echo "Found d203 F204/F205 board with 1 or 2 M-Modules A08 with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            elif [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0x203d" ] && [ "${pciSubVend}" == "0xff00" ]; then
                echo "Found d203 F204/F205 board with 1 or 2 M-Modules A24 with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            elif [ "${pciVend}" == "0x1172" ] && [ "${pciDevId}" == "0x4d45" ] || [ "${pciVend}" == "0x1a88" ]; then
                echo "Found F2xx/G2xx carrier with disabled memory region(s)"
                set_command_register "${pciBusHex}" "${pciDevNrHex}" "${pciDevFunHex}" "3"
            else
                echo "Memory disabled on device ${pciBusHex}:${pciDevNrHex}.${pciDevFunHex}"
                echo "This is not valid board to enable memory regions, skip .."
            fi
        fi
    done 4< <(tail -n "+3" ${TMP_PCIDEVS})
}

############################################################################
# Set COMMAND register bits.
# Function reads current COMMAND register value and sets specified bits
# Bits that are set don't change.
#
# parameters:
# $1    PCI_BUS_NR (Hex)
# $2    PCI_DEV_NR (Hex)
# $3    PCI_DEV_FUN_NR (Hex)
# $4    COMMAND register value(Hex)
#
function set_command_register {
    local pciBusHex=${1}
    local pciDevNrHex=${2}
    local pciDevFunHex=${3}
    local pciCommandRegBits=${4}
    echo "Enabling memory via setpci cmd:"
    pciCommandRegValue="$(printf "%x" $(setpci -s ${pciBusHex}:${pciDevNrHex}.${pciDevFunHex} COMMAND))"
    pciCommandRegValue="$(( 0x${pciCommandRegValue} | 0x${pciCommandRegBits} ))"
    setpci -s ${pciBusHex}:${pciDevNrHex}.${pciDevFunHex} COMMAND=0x${pciCommandRegValue}
}

############################################################################
# scan the generated PCI list tmp file for known devices. read the PCI list
# linewise to find multiple cards etc. Parse the generated temporary file for
# F2xx cards.
# For F223 the search is performed in a state machine like manner. A F223 is
# identified by a Pericom PCI bridge with 4 USB bridges directly after it.
# PP04 cards are identified by a TI cPCI bride + PP04 FPGA directly after it.
#
# parameters:
# $1    WIZ_BUS_PATH_PRIM primary PCI bus path of CPU
#
function scan_for_pci_devs {

    state_check_f223=0
    state_check_pp04=0
    count_usb_devs=0
    count_pp04_devs=0
    count_instance_f223=0 # handled separately
    count_instance_f207=0
    count_instance_f2xx=0 # any other F2xx cham. carrier
    count_instance_d203=0
    count_instance_d203_a24=0
    bus_path_prim=$1
    bus_path_sec=0
    bus_num_f223=0
    dev_num_f223=0
    reverse_enum_f205=0

    while read line <&4; do
    # Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
    #  25   0   5  15   0   0x12d8   0xe110    0x0000
        listnr=`echo $line | awk '{print $1}'`
        pcibus=`echo $line | awk '{print $3}'`
        pcidevnr=`echo $line | awk '{print $4}'`
        pcivend=`echo $line | awk '{print $6}'`
        pcidevid=`echo $line | awk '{print $7}'`
        pcisubvend=`echo $line | awk '{print $8}'`
        debug_print "Vendor: $pcivend Device: $pcidevid PCI bus: $pcibus PCI devnr. $pcidevnr "

        ###################
        # state actions
        if [ "$state_check_f223" == "1" ]; then
            # previous line was a Pericom bridge. Are now 4 subsequent USB bridges following?
            if [ "$pcivend" == "0x12d8" ] && [ "$pcidevid" == "0x400a" ]; then
                count_usb_devs=`expr $count_usb_devs + 1`
            else # other device showed up in between -> its no F223.
                state_check_f223=0
                count_usb_devs=0
            fi

            if [ "$count_usb_devs" == "1" ] && [ "$pcidevid" == "0x400a" ]; then
                bus_num_f223=$pcibus
                dev_num_f223=$pcidevnr
            fi

            if [ "$count_usb_devs" == "4" ] && [ "$pcidevid" == "0x400a" ]; then
                count_instance_f223=`expr $count_instance_f223 + 1`
                echo " -> F223 nr. $count_instance_f223 found, adding to system descriptor"
                count_usb_devs=0
                state_check_f223=0
                if [ "$count_instance_f223" == "1" ]; then
                    G_makefileBbisDriver+=" PCI/DRIVER/COM/driver.mak"
                    G_makefileLlDriver+=" PI7C9_GPIO/DRIVER/COM/driver.mak"
                    G_makefileLlTool+=" PI7C9_GPIO/EXAMPLE/PI7C9_GPIO_SIMP/COM/program.mak"
                fi
                create_entry_dsc_f223 $DSC_TPL_DIR $count_instance_f223 \
                  $bus_num_f223 $dev_num_f223
            fi
        fi

        # does a PP04 show up ?
        if [ "$state_check_pp04" == "1" ]; then
            # previous line was a F207. Do we find a PP04 now? PP04 has V0 cham table.
            if [ "$pcivend"=="0x1172" ] && [ "$pcidevid"=="0x000c" ] && [ "$pcisubvend"=="0x4d45" ]; then
                echo "Found PP04 MVB card. adding dsc entries for F207 and PP04."
                count_pp04_devs=`expr $count_pp04_devs + 1`
                create_entry_dsc_f207 $DSC_TPL_DIR $count_instance_f207 $bus_path_prim $bus_path_sec
                create_entry_dsc_pp04 $DSC_TPL_DIR $count_pp04_devs $count_instance_f207
            else # other device showed up in between -> its no F223.
                state_check_pp04=0
            fi
        fi

        ############################
        # state events

        # check if a F223 starts here
        if [ "$pcivend" == "0x12d8" ] && [ "$pcidevid" == "0xe110" ]; then
            echo "Found Pericom PCI bridge. Keep looking if F223 appears"
            state_check_f223=1
        fi

         # check if TI Bridge (=F207), if so check if a PP04 follows next
        if [ "$pcivend" == "0x104c" ] && [ "$pcidevid" == "0xac28" ]; then
            echo "Found TI2050 PCI bridge, possibly F207. Keep looking if PP04 appears."
            # store PCI devnr. in case its a F223
            bus_path_sec=$pcidevnr
            count_instance_f207=`expr $count_instance_f207 + 1`
            state_check_pp04=1
        fi

        # any other F2xx/G2xx carrier (mezzanine chameleon) ?
        if [ "$pcivend" == "0x1172" ] && [ "$pcidevid" == "0x4d45" ] || [ "$pcivend" == "0x1a88" ]; then
            count_instance_f2xx=`expr $count_instance_f2xx + 1`
            echo "Found possible MEN chameleon device(s), checking."
            check_for_cham_devs $MEN_LIN_DIR \
                $pcivend $pcidevid $pcidevnr $pcisubvend \
                $count_instance_f2xx $pcibus
        fi

        if [ "$pcivend" == "0x1172" ] && [ "$pcidevid" == "0x203d" ] && [ "$pcisubvend" == "0x00b9" ]; then
            echo "Found d203 G204 board with 1 M-Module A24"
            pcibusslot=$G_cPciRackSlotSerial
            count_instance_d203_a24=`expr $count_instance_d203_a24 + 1`
            G_cPciRackSlotSerial=`expr $G_cPciRackSlotSerial + 1`
            echo "Found d203_a24 no. $count_instance_d203_a24"
            create_entry_dsc_d203_a24 $DSC_TPL_DIR $count_instance_d203_a24 $pcibusslot $pcibus "G204_A24" $pcidevnr $DSC_FILE
        fi

        # support for F204/F205 carrier board with A08 M-Module access boards
        if [ "$pcivend" == "0x1172" ] && [ "$pcidevid" == "0xd203" ] && [ "$pcisubvend" == "0xff00" ]; then
            echo "Found d203 F204/F205 board with 1 or 2 M-Modules A08"
            pcibusslot=$G_cPciRackSlotStandard
            busif="1"     # for standard cPCI always "cpu,1"
            if [ $reverse_enum_f205 == 0 ]; then
                cat /dev/null > "$TMP_F205_DSC"
                cat /dev/null > "$TMP_F205_DSC.tmp"
                reverse_enum_f205=1
                G_cPciRackSlotStandard=$(($G_cPciRackSlotStandard + 1 + (15 - $pcidevnr)))
            else
                reverse_enum_f205=$(($reverse_enum_f205 + 1))
        fi
        count_instance_d203=$(($G_cF205 + 1 - $reverse_enum_f205))
        echo "Found d203 no. $count_instance_d203"
        create_entry_dsc_d203 $DSC_TPL_DIR $count_instance_d203 $busif $pcibus "F205" $pcidevnr "$TMP_F205_DSC.tmp"
        if [ -e "$TMP_F205_DSC.tmp" ]; then
            if [ -e "$TMP_F205_DSC" ]; then
                cat "$TMP_F205_DSC" >> "$TMP_F205_DSC.tmp"
            fi
            mv "$TMP_F205_DSC.tmp" "$TMP_F205_DSC"
        fi
            boardPosition=$(get_board_outermost_position "0x1172" "0xd203" "0xff00" $pcibus)
        if [ "$pcidevnr" == "$boardPosition" ]; then
            if [ -e "$TMP_F205_DSC" ]; then
                cat "$TMP_F205_DSC" >> "$DSC_FILE"
            fi
            reverse_enum_f205=0
        fi
    fi

    # support for F204/F205 carrier board with A24 M-Module access boards
    if [ "$pcivend" == "0x1172" ] && [ "$pcidevid" == "0x203d" ] && [ "$pcisubvend" == "0xff00" ]; then
        echo "Found d203 F204/F205 board with 1 or 2 M-Modules A24"
        pcibusslot=$G_cPciRackSlotStandard
        busif="1"     # for standard cPCI always "cpu,1"
        count_instance_d203_a24=`expr $count_instance_d203_a24 + 1`
        echo "Found d203_a24 no. $count_instance_d203_a24"
        create_entry_dsc_d203_a24 $DSC_TPL_DIR $count_instance_d203_a24 $busif $pcibus "F205_A24" $pcidevnr $DSC_FILE
    fi

    done 4<  $TMP_PCIDEVS
}

### @brief Create M-Module section
###
### @param $1 DSC template directory
### @param $2 M-Module name
### @param $3 Board instance number
### @param $4 Board name
### @param $5 DSC output file
function create_entry_dsc_mmodule {
    local tplDir
    local boardNum
    local boardName
    local outFile
    local mModule
    local xMakefile

    tplDir="${1}"
    boardNum="${2}"
    boardName="${3}"
    outFile="${4}"

    mModule="${mmodSpecList["hwname"]}"

    if [ "${mModule}" == "" ] || \
        [ "${mmodSpecList["hwname"]}" == "" ] || \
        [ "${mmodSpecList["name"]}" == "" ]; then
        return 22
    fi

    if [ "${mModuleInstances["${mModule}"]}" == "" ]; then
        mModuleInstances["${mModule}"]="1"
    else
        mModuleInstances["${mModule}"]="$((mModuleInstances["${mModule}"]+=1))"
    fi

    echo "Found ${mModule^^} (${mmodSpecList["mmoduleid"]}) on ${boardName}_${boardNum}"

    echo "Writing ${mModule,,}_${mModuleInstances["${mModule}"]} section to system.dsc"
    cat "${tplDir}/mX.tpl" | sed "s/SCAN_MMODULE_INSTANCE/${mModuleInstances["${mModule}"]}/g;s/SCAN_BBIS_NAME/${boardName}/g;s/USCORESCAN_BBIS_INSTANCE/_${boardNum}/g;s/SCAN_DEV_SLOT/`printf \"0x%x\" ${mm_device_slot}`/g;s/SCAN_MMODULE_NAMELCASE/${mmodSpecList["hwname"],,}/g;s/SCAN_MMODULE_NAME/${mmodSpecList["name"]^^}/g;s/SCAN_WIZMODEL_NAME/${mmodSpecList["hwname"]^^}/g" >> "${outFile}"

    if [ "${mModuleInstances["${mModule}"]}" == "1" ]; then
        if [ "${mmodSpecList["Low Level Driver"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["Low Level Driver"]}; do
                G_makefileLlDriver+=" ${xMakefile}"
            done
        fi
        if [ "${mmodSpecList["Native Driver"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["Native Driver"]}; do
                G_makefileNatDriver+=" ${xMakefile}"
            done
        fi
        if [ "${mmodSpecList["Driver Specific Tool"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["Driver Specific Tool"]}; do
                G_makefileLlTool+=" ${xMakefile}"
            done
        fi
        if [ "${mmodSpecList["User Library"]}" != "" ]; then
            for xMakefile in ${mmodSpecList["User Library"]}; do
                G_makefileUsrLibs+=" ${xMakefile}"
            done
        fi
    fi
}

############################################################################
# scan for M-Modules on specific board
#
# parameters:
# $1  DSC template directory
# $2  board instance number
# $3  board name
# $4  PCI bus number to scan (decimal)
# $5  PCI device number to scan (decimal)
# $6  PCI device function to scan (decimal)
# $7  carrier board type (A24/D32 or A08/D16)
# $8  DSC output file
#
function scan_for_mmodules {
    mm_a08d16xx="0x0000200 0x0000600 0x0000a00 0x0000e00"
    mm_a24d32x0="0x0000000 0x1000000 0x1fffd00 0x1fffe00"
    mm_a24d32x1="0x2000000 0x3000000 0x3fffd00 0x3fffe00"
    mm_a24d32x2="0x4000000 0x5000000 0x5fffd00 0x5fffe00"
    mm_a24d32x3="0x6000000 0x7000000 0x7fffd00 0x7fffe00"
    mm_device_slot=0
    mm_pci_bus=`printf "%x" $4`
    mm_pci_dev=`printf "%x" $5`
    mm_pci_fun=`printf "%x" $6`
    bar_address=`lspci -s $mm_pci_bus:$mm_pci_dev.$mm_pci_fun -v | grep 'Memory at' | head -n 1 | awk '{print $3}'`
    if [ "$7" == "A08/D16" ]; then
        for mm_offset in $mm_a08d16xx; do
            mm_address=`printf "0x%x" $((0x$bar_address + $mm_offset))`
            mm_id="$(getMmodId "${mm_address}")"
            if [ "${mm_id}" != "" ]; then
                makeMmodFileMap
                makeMmodOutputData "${mm_id}"
                create_entry_dsc_mmodule $1 $2 $3 $8
            fi
            mm_device_slot=$(($mm_device_slot + 1))
        done
    elif [ "$7" == "A24/D32" ]; then
        mm_a24d32xx="mm_a24d32x0 mm_a24d32x1 mm_a24d32x2 mm_a24d32x3"
        for mm_a24d32 in $mm_a24d32xx; do
            for mm_offset in ${!mm_a24d32}; do
                mm_address=`printf "0x%x" $((0x$bar_address + $mm_offset))`
                mm_id="$(getMmodId "${mm_address}")"
                if [ "${mm_id}" != "" ]; then
                    makeMmodFileMap
                    makeMmodOutputData "${mm_id}"
                    create_entry_dsc_mmodule $1 $2 $3 $8
                    if [ $? == 0 ]; then
                        break
                    fi
                fi
            done
            mm_device_slot=$(($mm_device_slot + 1))
        done
    fi
}

############################################################################
# count f205 like carrier boards
#
#   Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
#     .
#     .
#     .
#    15|  0   4  13   0   0x1172   0xd203    0xff00
#    16|  0   4  15   0   0x1172   0xd203    0xff00
#     .
#     .
#     .
#
function count_f205_boards {
    G_cF205=`cat $TMP_PCIDEVS | awk '{if ($6 == "0x1172" && $7 == "0xd203" && $8 == "0xff00") print $1}' | wc -l`
}

############################################################################
# Check Compact PCI board outermost dev position on bus
#
#   Nr.| dom|bus|dev|fun| Ven ID | Dev ID | SubVen ID |
#     .
#
#    15|  0   4  13   0   0x1172   0x203d    0xff00
#    16|  0   4  15   0   0x1172   0x203d    0xff00
#
# parameters:
# $1 Ven ID
# $2 Dev ID
# $3 SubVen ID
# $4 Bus number
#
function get_board_outermost_position {
    PciDevNrLast=0

    DeviceNr=`grep "$1 * $2 * $3" $TMP_PCIDEVS | wc -l`
    if [ $DeviceNr -eq "0" ]; then
        echo "No device found: $1 $2 $3 "
    fi

    for i in `seq 1 $DeviceNr`
    do
        PciBus=`grep "$1 * $2 * $3" $TMP_PCIDEVS | awk NR==$i'{print $3}'`
        PciDevNr=`grep "$1 * $2 * $3" $TMP_PCIDEVS | awk NR==$i'{print $4}'`
        if [ $PciBus -eq $4 ] && [ $PciDevNrLast -lt $PciDevNr ]; then
                PciDevNrLast=$PciDevNr
        fi
    done
    echo $PciDevNrLast
}

############################################################################
# check if .mak should be added into main Makefile
#
function check_makefile {
    local singleMak=${1}
    local duplicateCnt=$(echo "${G_makefileUniqList}" | grep "${singleMak}" | wc -l) 

    if [ ${duplicateCnt} -ne 0 ]; then
        return 1
    else
        G_makefileUniqList+=${singleMak}
        G_makefileUniqList+="\n"
        return 0
    fi
}
############################################################################
# create MDIS Makefile from collected driver data
#
#   Makefile.tpl is completed by replacing following tags
#   with real driver/library/program.mak references:
#
#   #SCAN_LIN_KERNEL_DIR   -> LIN_KERNEL_DIR
#   #SCAN_NEXT_LL_DRIVER   -> ALL_LL_DRIVERS
#   #SCAN_NEXT_BB_DRIVER   -> ALL_BB_DRIVERS
#   #SCAN_NEXT_USR_LIB     -> ALL_USR_LIBS
#   #SCAN_NEXT_LL_TOOL     -> ALL_LL_TOOLS
#   #SCAN_NEXT_NAT_DRIVER  -> ALL_NATIVE_DRIVERS
#
#   Also check .mak files to really exist in the MEN_LIN_DIR folder.
#   The xml files contain also MEN internal test tools
#
function create_makefile {
    echo "creating Makefile..."

    # start with the template
    cat $DSC_TPL_DIR/Makefile.tpl > $TMP_MAKE_FILE
    # Add cretion note into Makefile
    sed -i "s/CREATION_NOTE/ ${CREATION_NOTE}\n# ${COMMIT_ID}\n# ${DATE}/g" $TMP_MAKE_FILE

    # write library installation directory
    local LIB_INSTALL_DIR="/usr/local/lib"
    local LIN_DISTRO_NAME="$(grep -oPs "(?<=^NAME=\")[^\"]+(?=\")" /etc/os-release)"
    if [ "${LIN_DISTRO_NAME}" == "CentOS Linux" ]; then
        LIB_INSTALL_DIR="/usr/lib"
    elif [[ "${LIN_DISTRO_NAME}" =~ Yocto ]]; then
        LIB_INSTALL_DIR="/usr/lib"
    fi
    local lib_dir="$(echo "${LIB_INSTALL_DIR}" | sed "s/\//@/g")"
    sed -i.bak "s/SCAN_LIB_INSTALL_DIR/${lib_dir}/g" $TMP_MAKE_FILE

    # write linux kernel directory
    kern_dir=`echo "$LIN_SRC_DIR" | sed "s/\//@/g"`
    sed -i.bak "s/SCAN_LIN_KERNEL_DIR/$kern_dir/g" $TMP_MAKE_FILE

    # insert all collected BBIS drivers into Makefile
    for i in $G_makefileBbisDriver; do
    debug_print "checking bbis driver: $i"
        if [ -f $MEN_LIN_DIR/DRIVERS/BBIS/$i ]; then
            debug_print "bbis driver: $i"
            check_makefile ${i}
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=`echo "    $i" | sed "s/\//@/g"`
                sed -i.bak "s/#SCAN_NEXT_BB_DRIVER/$subs\n#SCAN_NEXT_BB_DRIVER/g" $TMP_MAKE_FILE
            fi
        else
        debug_print "BB driver '$i' not found in MDIS tree, skipping."
        fi
    done
    sed -i.bak "s/$subs/#LAST_BBIS_DRIVER/g" $TMP_MAKE_FILE
    subs=$(echo "$subs" | sed "s/\.mak/\.lastmak/g")
    sed -i.bak "s/#LAST_BBIS_DRIVER/$subs\n/g" $TMP_MAKE_FILE
    sed -i.bak "s/#SCAN_NEXT_BB_DRIVER//g" $TMP_MAKE_FILE


    # insert all collected LL drivers into Makefile
    for i in $G_makefileLlDriver; do
    debug_print "checking LL driver: $i"
        if [ -f $MEN_LIN_DIR/DRIVERS/MDIS_LL/$i ]; then
            debug_print "ll driver: $i "
            check_makefile ${i}
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=`echo "    $i" | sed "s/\//@/g"`
                sed -i.bak "s/#SCAN_NEXT_LL_DRIVER/$subs\n#SCAN_NEXT_LL_DRIVER/g" $TMP_MAKE_FILE
            fi
        else
            debug_print "skipping LL driver '$i'"
        fi
    done
    sed -i.bak "s/$subs/#LAST_LL_DRIVER/g" $TMP_MAKE_FILE
    subs=$(echo "$subs" | sed "s/\.mak/\.lastmak/g")
    sed -i.bak "s/#LAST_LL_DRIVER/$subs\n/g" $TMP_MAKE_FILE
    sed -i.bak "s/#SCAN_NEXT_LL_DRIVER//g" $TMP_MAKE_FILE

    # insert all collected LL Tools into Makefile
    for i in $G_makefileLlTool; do
        if [ -f $MEN_LIN_DIR/DRIVERS/MDIS_LL/$i ]; then
            debug_print "ll tool: $i"
            check_makefile ${i}
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=`echo "    $i" | sed "s/\//@/g"`
                sed -i.bak "s/#SCAN_NEXT_LL_TOOL/$subs\n#SCAN_NEXT_LL_TOOL/g" $TMP_MAKE_FILE
            fi
        else
            debug_print "skipping LL tool '$i'"
        fi
    done
    sed -i.bak "s/$subs/#LAST_LL_TOOL/g" $TMP_MAKE_FILE
    subs=$(echo "$subs" | sed "s/\.mak/\.lastmak/g")
    sed -i.bak "s/#LAST_LL_TOOL/$subs\n/g" $TMP_MAKE_FILE
    sed -i.bak "s/#SCAN_NEXT_LL_TOOL//g" $TMP_MAKE_FILE

    # insert all collected native drivers into Makefile
    for i in $G_makefileNatDriver; do
        if [ -f $MEN_LIN_DIR/$i ]; then
            debug_print "native driver: $i"
            check_makefile ${i}
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=`echo "    $i" | sed "s/\//@/g"`
                sed -i.bak "s/#SCAN_NEXT_NAT_DRIVER/$subs\n#SCAN_NEXT_NAT_DRIVER/g" $TMP_MAKE_FILE
            fi
        else
            echo "native driver '$i' not found in MDIS tree, skipping."
        fi
    done
    sed -i.bak "s/$subs/#LAST_NAT_DRIVER/g" $TMP_MAKE_FILE
    subs=$(echo "$subs" | sed "s/\.mak/\.lastmak/g")
    sed -i.bak "s/#LAST_NAT_DRIVER/$subs\n/g" $TMP_MAKE_FILE
    sed -i.bak "s/#SCAN_NEXT_NAT_DRIVER//g" $TMP_MAKE_FILE

    for i in $G_makefileUsrLibs; do
        if [ -f $MEN_LIN_DIR/LIBSRC/$i ]; then
            debug_print "usr lib: $i"
            check_makefile ${i}
            CmdResult=$?
            if [ ${CmdResult} -eq 0 ]; then
                subs=`echo "    $i" | sed "s/\//@/g"`
                sed -i.bak "s/#SCAN_NEXT_USR_LIB/$subs\n#SCAN_NEXT_USR_LIB/g" $TMP_MAKE_FILE
            fi
        else
            echo "user lib '$usrlib' not found in MDIS tree, skipping."
        fi
    done
    sed -i.bak "s/$subs/#LAST_USR_LIB/g" $TMP_MAKE_FILE
    subs=$(echo "$subs" | sed "s/\.mak/\.lastmak/g")
    sed -i.bak "s/#LAST_USR_LIB/$subs\n/g" $TMP_MAKE_FILE
    sed -i.bak "s/#SCAN_NEXT_USR_LIB//g" $TMP_MAKE_FILE


    # add '\' behind every .mak that is not last and replace @ with '/'
    sed -i.bak "s/@/\//g;s/\.mak/\.mak \\\/g" $TMP_MAKE_FILE
    sed -i.bak "s/\.lastmak/\.mak/g" $TMP_MAKE_FILE

    # finally replace ##REPLNEWLINExxx tags with LF (after
    # removing all doublette line no linefeeds would be left
    # making the Makefile looking ugly...)
    sed -i.bak "s/##REPLNEWLINE...//g" $TMP_MAKE_FILE
    cat -s "$TMP_MAKE_FILE" > $MAKE_FILE
}

### @brief Create map
### @param $1 Map name
mapNew() {
    local -r keys="__MAP_KEYS_${1}"
    local -r values="__MAP_VALUES_${1}"

    declare -a "${keys}"
    declare -a "${values}"

    eval "${keys}=()"
    eval "${values}=()"
}

### @brief Delete map
### @param $1 Map name
mapDelete() {
    local -r keys="__MAP_KEYS_${1}"
    local -r values="__MAP_VALUES_${1}"

    eval "unset -v \"${keys}\""
    eval "unset -v \"${values}\""
}

### @brief Clear map
### @param $1 Map name
mapClear() {
    local -r keys="__MAP_KEYS_${1}"
    local -r values="__MAP_VALUES_${1}"

    eval "${keys}=()"
    eval "${values}=()"
}

### @brief Get key value
### @param $1 Map name
### @param $2 Key
### @return Value associated with key is echoed
mapGet() {
    local -r keys="__MAP_KEYS_${1}"
    local -r values="__MAP_VALUES_${1}"
    local -ir size="$(eval "echo \${#${keys}[@]}")"
    local -i i
    local key

    for (( i=0 ; i<size ; i++ )); do
        key="$(eval "echo \${${keys}[${i}]}")"
        if [ "${key}" == "${2}" ]; then
            eval "echo \"\${${values}[${i}]}\""
            break
        fi
    done
}

### @brief Associate value with key
### @param $1 Map name
### @param $2 Key
### @param $3 Value
mapPut() {
    local -r keys="__MAP_KEYS_${1}"
    local -r values="__MAP_VALUES_${1}"
    local -ir size="$(eval "echo \${#${keys}[@]}")"
    local -i i
    local key

    if [ "${size}" == 0 ]; then
        eval "${keys}+=(\"$2\")"
        eval "${values}+=(\"$3\")"
    else
        for (( i=0 ; i<size ; i++ )); do
            key="$(eval "echo \${${keys}[${i}]}")"
            if [ "${key}" == "${2}" ]; then
                eval "${values}[${i}]=\"${3}\""
                break
            fi
        done
        if [ "${i}" == "${size}" ]; then
            eval "${keys}+=(\"$2\")"
            eval "${values}+=(\"$3\")"
        fi
    fi
}

### @brief Remove key (and associated value)
### @param $1 Map name
### @param $2 Key
mapRemove() {
    local -r keys="__MAP_KEYS_${1}"
    local -r values="__MAP_VALUES_${1}"
    local -i size
    local -i i
    local key

    size="$(eval "echo \${#${keys}[@]}")"
    for (( i=0 ; i<size ; i++ )); do
        key="$(eval "echo \${${keys}[${i}]}")"
        if [ "${key}" == "${2}" ]; then
            size="$((size-1))"
            if [ "${size}" != "0" ]; then
                eval "${keys}[${i}]=\"\${${keys}[${size}]}\""
                eval "${values}[${i}]=\"\${${values}[${size}]}\""
            fi
            eval "unset -v \"${keys}[${size}]\""
            eval "unset -v \"${values}[${size}]\""
            break
        fi
    done
}

### @brief Get keys
### @param $1 Map name
### @return All keys are echoed
mapKeys() {
    local -r keys="__MAP_KEYS_${1}"

    eval "echo \${${keys}[@]}"
}

### @brief Get values
### @param $1 Map name
### @return All values are echoed
mapValues() {
    local -r values="__MAP_VALUES_${1}"

    eval "echo \${${values}[@]}"
}

### @brief Check if key is in map
### @param $1 Map name
### @param $2 Key
### @return 0 if key is in map
### @return non-zero otherwise
mapKey() {
    local -r keys="__MAP_KEYS_${1}"
    local -ir size="$(eval "echo \${#${keys}[@]}")"
    local -i i
    local key

    for (( i=0 ; i<size ; i++ )); do
        key="$(eval "echo \${${keys}[${i}]}")"
        if [ "${key}" == "${2}" ]; then
            return "0"
        fi
    done

    return "1"
}

### @brief Check if value is in map
### @param $1 Map name
### @param $2 Value
### @return 0 if value is in map
### @return non-zero otherwise
mapValue() {
    local -r values="__MAP_VALUES_${1}"
    local -ir size="$(eval "echo \${#${values}[@]}")"
    local -i i
    local value

    for (( i=0 ; i<size ; i++ )); do
        value="$(eval "echo \${${values}[${i}]}")"
        if [ "${value}" == "${2}" ]; then
            return "0"
        fi
    done

    return "1"
}

### @brief Get size
### @param $1 Map name
### @return Map size is echoed
mapSize() {
    local -r keys="__MAP_KEYS_${1}"

    eval "echo \${#${keys}[@]}"
}

### @brief Parse XML file
### @details SAX parser.
### Callback function is called on events like tag start (startElement), tag end
### (endElement) and tag content (characters).
### On tag start event callback function is called with following arguments:
### "callbackArgument" "startElement" "/current/path" "tagName" "[attr]="value""
### On tag end event callback function is called with following arguments:
### "callbackArgument" "endElement" "/current/path" "tagName"
### On tag content event callback function is called with following arguments:
### "callbackArgument" "characters" "/current/path" "tag content"
### Known limitations: only valid XML syntax allowed; no tag embedded in comment
### allowed; no CDATA recognized
### @param $1 Input XML file
### @param $2 Name of callback function
### @param $3 Callback function argument
xmlParseXml() {
    local -r EV_START="startElement"
    local -r EV_END="endElement"
    local -r EV_CHARS="characters"
    local -r RE_XML="^(/?)([[:alnum:]]+)(([[:space:]]+[:[:alpha:]]+=\"[^\"]+\")*)(/?)$"
    local -r RE_ATTR="s/([:[:alnum:]]+)=\"([^\"]+)\"/[\1]=\"\2\"/g"
    local inFile
    local cbFunc
    local cbArg
    local IFS
    local xmlPath
    local strLen
    local escArg
    local escPath
    local escTag
    local escAttr
    local escChars

    inFile="${1}"
    cbFunc="${2}"
    cbArg="${3}"
    xmlPath=""

    if [ ! -f "${inFile}" ]; then
        return "1"
    fi

    IFS=">"
    while read -rd "<" "xmlEntity" "xmlContent"; do
        IFS=$' \t\n'
        if [ "${cbFunc}" != "" ] && \
            [ "${xmlEntity}" != "" ] && \
            [[ "${xmlEntity}" =~ ${RE_XML} ]]; then
            if [ "${BASH_REMATCH[1]}" == "" ]; then
                escArg="$(printf '%q' "${cbArg}")"
                escPath="$(printf '%q' "${xmlPath}")"
                escTag="$(printf '%q' "${BASH_REMATCH[2]}")"
                escAttr="$(sed -E "${RE_ATTR}" <<< "${BASH_REMATCH[3]}")"
                escAttr="$(printf '%q' "${escAttr}")"
                eval "${cbFunc}" "${escArg}" "${EV_START}" "${escPath}" "${escTag}" "${escAttr}"
                xmlPath+="/${BASH_REMATCH[2]}"
                if [ "${xmlContent}" != "" ]; then
                    escArg="$(printf '%q' "${cbArg}")"
                    escPath="$(printf '%q' "${xmlPath}")"
                    escChars="$(printf '%q' "${xmlContent}")"
                    eval "${cbFunc}" "${escArg}" "${EV_CHARS}" "${escPath}" "${escChars}"
                fi
            fi
            if [ "${BASH_REMATCH[1]}" == "/" ] || \
                [ "${BASH_REMATCH[5]}" == "/" ]; then
                escArg="$(printf '%q' "${cbArg}")"
                escPath="$(printf '%q' "${xmlPath}")"
                escTag="$(printf '%q' "${BASH_REMATCH[2]}")"
                eval "${cbFunc}" "${escArg}" "${EV_END}" "${escPath}" "${escTag}"
                strLen="${#xmlPath}"
                strLen="$((strLen-${#BASH_REMATCH[2]}))"
                strLen="$((strLen-1))"
                xmlPath="${xmlPath:0:${strLen}}"
            fi
        fi
        IFS=">"
    done < "${inFile}"
}

### @brief Create M-Module to XML file mapping associative array
makeMmodFileMap() {
    local xFiles
    local xFile

    if [ "${#mmodFileList[@]}" != "0" ]; then
        return "0"
    fi

    echo -n "Building M-Module database..."
    xFiles=($(ls "${MEN_LIN_DIR}/PACKAGE_DESC/"13m0*.xml 2> "/dev/null"))
    for xFile in "${xFiles[@]}"; do
        echo -n "."
        xmlParseXml "${xFile}" "makeMmodFileMapCallback" "${xFile##*/}"
    done
    echo "done!"
}

### @brief xmlParseXml() callback for makeMmodFileMap()
### @param $1 Callback argument
### @param $2 Event reason
### @param $3 Current xPath
### @param $4 Event specific data#1
### @param $5 Event specific data#2
makeMmodFileMapCallback() {
    if [ "${2}" == "characters" ] && \
        [ "${3}" == "/package/modellist/model/autoid/mmoduleid" ] && \
        [ "${mmodFileList["${4}"]}" == "" ]; then
        mmodFileList+=(["${4}"]="${1}")
    fi
}

### @brief Create M-Module output data
### @param $1 M-Module ID
makeMmodOutputData() {
    local xId
    local xFile
    local -A xModel
    local -A xModule

    xId="${1}"

    mmodSpecList=()

    xFile="${mmodFileList["${xId}"]}"
    if [ "${xFile}" == "" ]; then
        return "1"
    fi

    xmlParseXml "${MEN_LIN_DIR}/PACKAGE_DESC/${xFile}" "makeMmodOutputDataCallback" "${xId}"
}

### @brief xmlParseXml() callback for makeMmodOutputData()
### @param $1 Callback argument
### @param $2 Event reason
### @param $3 Current xPath
### @param $4 Event specific data#1
### @param $5 Event specific data#2
makeMmodOutputDataCallback() {
    local xKey

    if [ "${2}" == "startElement" ]; then
        if [ "${3}" == "/package/modellist" ] && \
            [ "${4}" == "model" ]; then
            xModel=()
        elif [[ ("${3}" == "/package/modellist/model/swmodulelist" || \
            "${3}" == "/package/swmodulelist") && \
            "${4}" == "swmodule" ]]; then
            xModule=()
            if [ "${5}" != "" ]; then
                eval "xModule+=(${5})"
            fi
        fi
    elif [ "${2}" == "characters" ]; then
        if [ "${3}" == "/package/modellist/model/hwname" ]; then
            xModel+=(["hwname"]="${4}")
        elif [ "${3}" == "/package/modellist/model/autoid/mmoduleid" ]; then
            xModel+=(["mmoduleid"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/name" ] || \
            [ "${3}" == "/package/swmodulelist/swmodule/name" ]; then
            xModule+=(["name"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/type" ] || \
            [ "${3}" == "/package/swmodulelist/swmodule/type" ]; then
            xModule+=(["type"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/makefilepath" ] || \
            [ "${3}" == "/package/swmodulelist/swmodule/makefilepath" ]; then
            xModule+=(["makefilepath"]="${4}")
        fi
    elif [ "${2}" == "endElement" ]; then
        if [ "${3}" == "/package/modellist/model" ] && \
            [ "${4}" == "model" ]; then
            if [ "${1}" == "${xModel["mmoduleid"]}" ] && \
                [ "${mmodSpecList["mmoduleid"]}" == "" ]; then
                for xKey in "${!xModel[@]}"; do
                    mmodSpecList+=(["${xKey}"]="${xModel["${xKey}"]}")
                done
            fi
            xModel=()
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule" ] && \
            [ "${4}" == "swmodule" ]; then
            if [[ "${1}" == "${xModel["mmoduleid"]}" && \
                ( "${xModel["internal"]}" != "true" ||
                "${INTERNAL_SWMODULES}" != "0" ) ]]; then
                if [ "${xModel["name"]}" == "" ]; then
                    xModel+=(["name"]="${xModule["name"]}")
                fi
                if [ "${xModule["type"]}" != "" ] && \
                    [ "${xModule["makefilepath"]}" != "" ]; then
                    if [ "${xModel["${xModule["type"]}"]}" != "" ]; then
                        xModel["${xModule["type"]}"]+=" "
                    fi
                    xModel["${xModule["type"]}"]+="${xModule["makefilepath"]}"
                fi
            fi
            xModule=()
        elif [ "${3}" == "/package/swmodulelist/swmodule" ] && \
            [ "${4}" == "swmodule" ]; then
            if [[ "${xModel["internal"]}" != "true" ||
                "${INTERNAL_SWMODULES}" != "0" ]]; then
                if [ "${mmodSpecList["name"]}" == "" ]; then
                    mmodSpecList+=(["name"]="${xModule["name"]}")
                fi
                if [ "${xModule["type"]}" != "" ] && \
                    [ "${xModule["makefilepath"]}" != "" ]; then
                    if [ "${mmodSpecList["${xModule["type"]}"]}" != "" ]; then
                        mmodSpecList["${xModule["type"]}"]+=" "
                    fi
                    mmodSpecList["${xModule["type"]}"]+="${xModule["makefilepath"]}"
                fi
            fi
            xModule=()
        fi
    fi
}

### @brief Get M-Module ID
### @param $1 M-Module address
### @return M-Module ID is echoed
### @return Empty string is echoed on error
getMmodId() {
    local mmAddress
    local mmId
    local mmMagic
    local mmIdent

    mmAddress="${1}"

    mmMagic="$("${MEN_LIN_DIR}"/BIN/"${MM_IDENT}" "${mmAddress}" | grep "MAGIC:" | head -n 1)"
    if [[ "${mmMagic}" =~ ^MAGIC:[[:space:]]0x([[:xdigit:]]{4})$ ]]; then
        mmMagic="${BASH_REMATCH[1]}"
        mmIdent="$("${MEN_LIN_DIR}"/BIN/"${MM_IDENT}" "${mmAddress}" | grep "ID:" | head -n 1)"
        if [[ "${mmIdent}" =~ [[:space:]]ID:[[:space:]]0x([[:xdigit:]]{4}), ]]; then
            mmIdent="${BASH_REMATCH[1]}"
            mmId="0x${mmMagic}${mmIdent}"
        fi
    fi

    echo "${mmId}"
}

### @brief Create IP core to XML file mapping associative array
makeIpCoreFileMap() {
    local xFiles
    local xFile

    if [ "${#ipcoreFileList[@]}" != "0" ]; then
        return "0"
    fi

    echo -n "Building IP core database..."
    xFiles=($(ls "${MEN_LIN_DIR}/PACKAGE_DESC/"13z*.xml 2> "/dev/null"))
    for xFile in "${xFiles[@]}"; do
        echo -n "."
        xmlParseXml "${xFile}" "makeIpCoreFileMapCallback" "${xFile##*/}"
    done
    echo "done!"
}

### @brief xmlParseXml() callback for makeIpCoreFileMap()
### @param $1 Callback argument
### @param $2 Event reason
### @param $3 Current xPath
### @param $4 Event specific data#1
### @param $5 Event specific data#2
makeIpCoreFileMapCallback() {
    if [ "${2}" == "characters" ] && \
        [ "${3}" == "/package/modellist/model/autoid/chamv2id" ] && \
        [ "${ipcoreFileList["${4}"]}" == "" ]; then
        ipcoreFileList+=(["${4}"]="${1}")
    fi
}

### @brief Create IP core output data
### @param $1 IP core ID
makeIpCoreOutputData() {
    local xId
    local xFile
    local -A xModel
    local -A xModule
    local -A xSetting
    local xName

    xId="${1}"

    ipcoreSpecList=()

    xFile="${ipcoreFileList["${xId}"]}"
    if [ "${xFile}" == "" ]; then
        return "1"
    fi

    xmlParseXml "${MEN_LIN_DIR}/PACKAGE_DESC/${xFile}" "makeIpCoreOutputDataCallback" "${xId}"
}

### @brief xmlParseXml() callback for makeIpCoreOutputData()
### @param $1 Callback argument
### @param $2 Event reason
### @param $3 Current xPath
### @param $4 Event specific data#1
### @param $5 Event specific data#2
makeIpCoreOutputDataCallback() {
    local xKey
    local xVal
    local xSize
    local xMap
    local xIdx

    if [ "${2}" == "startElement" ]; then
        if [ "${3}" == "/package/modellist" ] && \
            [ "${4}" == "model" ]; then
            xModel=()
            xSize="${#ipcoreSpecList[@]}"
            xName="ipcoreSwModule${xSize}"
            mapNew "${xName}"
        elif [[ ( "${3}" == "/package/modellist/model/swmodulelist" || \
            "${3}" == "/package/swmodulelist" ) && \
            "${4}" == "swmodule" ]]; then
            xModule=()
            if [ "${5}" != "" ]; then
                eval "xModule+=(${5})"
            fi
        elif [ "${3}" == "/package/modellist/model/settinglist" ] && \
            [ "${4}" == "setting" ]; then
            xSetting=()
        fi
    elif [ "${2}" == "characters" ]; then
        if [ "${3}" == "/package/modellist/model/hwname" ]; then
            xModel+=(["hwname"]="${4}")
        elif [ "${3}" == "/package/modellist/model/modelname" ]; then
            xModel+=(["modelname"]="${4}")
        elif [ "${3}" == "/package/modellist/model/description" ]; then
            xModel+=(["description"]="${4}")
        elif [ "${3}" == "/package/modellist/model/autoid/chamv2id" ]; then
            xModel+=(["chamv2id"]="${4}")
        elif [ "${3}" == "/package/modellist/model/devnameprefix" ]; then
            xModel+=(["devnameprefix"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/name" ]; then
            xModule+=(["name"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/type" ] || \
            [ "${3}" == "/package/swmodulelist/swmodule/type" ]; then
            xModule+=(["type"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/makefilepath" ] || \
            [ "${3}" == "/package/swmodulelist/swmodule/makefilepath" ]; then
            xModule+=(["makefilepath"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/os" ] || \
            [ "${3}" == "/package/swmodulelist/swmodule/os" ]; then
            xModule+=(["os"]="${4}")
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule/notos" ] || \
            [ "${3}" == "/package/swmodulelist/swmodule/notos" ]; then
            if [ "${4}" == "Linux" ]; then
                xModule+=(["notos"]="${4}")
            fi
        elif [ "${3}" == "/package/swmodulelist/swmodule/name" ]; then
            if [ "${xModule["swname"]}" == "" ]; then
                xModule+=(["swname"]="${4}")
            fi
        elif [ "${3}" == "/package/modellist/model/settinglist/setting/name" ]; then
            xSetting+=(["name"]="${4}")
        elif [ "${3}" == "/package/modellist/model/settinglist/setting/type" ]; then
            xSetting+=(["type"]="${4}")
        elif [ "${3}" == "/package/modellist/model/settinglist/setting/value" ]; then
            xSetting+=(["value"]="${4}")
        fi
    elif [ "${2}" == "endElement" ]; then
        if [ "${3}" == "/package/modellist/model" ] && \
            [ "${4}" == "model" ]; then
            if [ "${1}" == "${xModel["chamv2id"]}" ] && \
                [ "${xModel["name"]: -3}" != "_io" ]; then
                ipcoreSpecList+=("${xName}")
                for xKey in "${!xModel[@]}"; do
                    mapPut "${xName}" "${xKey// /_}" "${xModel["${xKey}"]}"
                done
            else
                mapDelete "${xName}"
            fi
            xModel=()
        elif [ "${3}" == "/package/modellist/model/swmodulelist/swmodule" ] && \
            [ "${4}" == "swmodule" ]; then
            if [[ "${1}" == "${xModel["chamv2id"]}" && \
                ( "${xModel["internal"]}" != "true" || \
                "${INTERNAL_SWMODULES}" != "0" ) ]]; then
                if [ "${xModel["name"]}" == "" ]; then
                    xModel+=(["name"]="${xModule["name"]}")
                fi
                if [ "${xModule["type"]}" != "" ] && \
                    [ "${xModule["makefilepath"]}" != "" ]; then
                    if [ "${xModel["${xModule["type"]}"]}" != "" ]; then
                        xModel["${xModule["type"]}"]+=" "
                    fi
                    xModel["${xModule["type"]}"]+="${xModule["makefilepath"]}"
                fi
            fi
            xModule=()
        elif [ "${3}" == "/package/swmodulelist/swmodule" ] && \
            [ "${4}" == "swmodule" ]; then
            if [[ "${xModule["internal"]}" != "true" || \
                "${INTERNAL_SWMODULES}" != "0" ]]; then
                if [[ "${xModule["type"]}" != "" && \
                    "${xModule["makefilepath"]}" != "" && \
                    ( ( "${xModule["os"]}" == "" || \
                    "${xModule["os"]}" == "Linux" ) && \
                    "${xModule["notos"]}" != "Linux" ) ]]; then
                    xSize="${#ipcoreSpecList[@]}"
                    for (( xIdx=0; xIdx<xSize; xIdx++ )); do
                        xMap="${ipcoreSpecList[${xIdx}]}"
                        xKey="${xModule["type"]}"
                        xKey="${xKey// /_}"
                        xVal="$(mapGet "${xMap}" "${xKey}")"
                        if [ "${xVal}" == "" ]; then
                            xVal="${xModule["makefilepath"]}"
                        else
                            xVal+=" ${xModule["makefilepath"]}"
                        fi
                        mapPut "${xMap}" "${xKey}" "${xVal}"
                        xKey="swname"
                        xVal="${xModule[${xKey}]}"
                        if [ "${xVal}" != "" ]; then
                            if ! mapKey "${xMap}" "${xKey}"; then
                                mapPut "${xMap}" "${xKey}" "${xVal}"
                            fi
                        fi
                    done
                fi
            fi
            xModule=()
        elif [ "${3}" == "/package/modellist/model/settinglist/setting" ] && \
            [ "${4}" == "setting" ]; then
            if [ "${xSetting["value"]}" != "" ]; then
                xSet="${xSetting["name"]} = ${xSetting["type"]} ${xSetting["value"]}"
                if [ "${xModel["settings"]}" == "" ]; then
                    xModel+=(["settings"]="${xSet}")
                else
                    xModel["settings"]+=$'\n'
                    xModel["settings"]+="    ${xSet}"
                fi
            fi
            xSetting=()
        fi
    fi
}

### @brief Compile mm_ident tool
function compile_mm_ident {
    echo "compiling mm_ident"
    if [ -d "${MEN_LIN_DIR}TOOLS/mm_ident" ]; then
        make clean -C "${MEN_LIN_DIR}TOOLS/mm_ident" &> ${MEN_LIN_DIR}TOOLS/mm_ident/make_clean.log
        make -C "${MEN_LIN_DIR}TOOLS/mm_ident" &> ${MEN_LIN_DIR}TOOLS/mm_ident/make_mm_ident.log
        local CmdResult=$?
        if [ ${CmdResult} -ne "0" ]; then
            echo "mm_ident compilation failed, see log: "
            echo "${MEN_LIN_DIR}TOOLS/mm_ident/make_mm_ident.log"
        else
            echo "mm_ident compilation succeed, see log:"
            echo "${MEN_LIN_DIR}TOOLS/mm_ident/make_mm_ident.log"
            rm ${MEN_LIN_DIR}TOOLS/mm_ident/make_clean.log
        fi
    else
        echo "mm_ident tool not found in MDIS - error "
    fi

    return ${CmdResult}
}

### @brief Compile fpga_load tool
function compile_fpga_tools {
    echo "compiling fpga_tools"
    echo "compiling fpga_tools, and other requried libraries like pciutils..."
    if [ -d "${MEN_LIN_DIR}TOOLS/FPGA_LOAD" ]; then
        make clean -C "${MEN_LIN_DIR}TOOLS/FPGA_LOAD" &> ${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_clean.log
        make -C "${MEN_LIN_DIR}TOOLS/FPGA_LOAD" &> ${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_fpga_load.log
        local CmdResult=$?
        if [ ${CmdResult} -ne "0" ]; then
            echo "fpga_tools compilation failed, see log: "
            echo "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_fpga_load.log"
        else
            echo "fpga_tools compilation succeed"
            echo "${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_fpga_load.log"
            rm ${MEN_LIN_DIR}TOOLS/FPGA_LOAD/make_clean.log
        fi
    else
        echo "fpga_tools tool not found in MDIS - error "
    fi

    return ${CmdResult}
}

### @brief script usage --help
function scan_system_usage {
    echo "scan_system.sh   script to generate an automatic MDIS configuration"
    echo "                 when doing a selfhosted project"
    echo ""
    echo "  The script checks which CPU we are on. The SMB2 drivers"
    echo "  are always added to the CPU to provide BMC and watchdog"
    echo "  drivers."
    echo ""
    echo "IMPORTANT:"
    echo "     1. Path to MDIS install dir has to passed as first argument"
    echo "     2. Tools must be available in system: i2cdump, setpci, lspci,"
    echo "        libelf-dev or libelf-devel."
    echo "     3. /usr/src/linux/ points to valid kernel headers"
    echo ""
    echo "parameters:"
    echo "     'MEN_LIN_DIR'          path to MDIS installation dir - default"
    echo "                            /opt/menlinux/"
    echo "     -y, --yes"
    echo "     --assume-yes           scan without user interaction."
    echo "                            answer 'yes' for all questions"
    echo "     --mdiswiz              used by mdiswiz only!"
    echo "     --verbose              if 1 or 2 then additional debug info is dumped"
    echo "                            ex: --verbose 1"
    echo "     --buildtools           build mm_ident and fpga_load from source"
    echo "     --drytest              run drytest with test PCI device list "
    echo "                            if passed as alternative PCI devices temp" 
    echo "                            file the default file /tmp/men_pci_devs is"
    echo "                            not written. Used to test system.dsc"
    echo "                            generation with predefined test data."
    echo "                            ex: --drytest sth"
    echo "     --prerequisites        check if all prerequisites are met"
    echo "     --internal-swmodules   also add internal sw modules"
    echo "     -h, --help             print help"
    echo ""
}

### @brief check if passed argument is valid directory in system
function check_if_mdis_path {
    local DirPath=${1}
    echo "${DirPath}" | grep "/.*"
    local CmdResult=$?

    if [ ${CmdResult} -ne 0 ]; then
        return 0
    fi

    if [ -d "${DirPath}" ]; then
        return 1
    else
        echo "Wrong MDIS INSTALL path"
        echo "PATH: ${DirPath} does not exists"
        return 2
    fi
}

### @brief check if all system prerequisites are met
### return 0 if success
function check_scan_system_prerequisites {

    local prerequisites_result=0
    echo "checking if I2C tools exists..."
    local have_i2ctools=`which i2cdump`
    if [ "${have_i2ctools}" == "" ]; then
        echo "*** error: please install i2c-tools. Examples: Ubuntu: apt-get install i2c-tools, Fedora: yum install i2c-tools"
        prerequisites_result=1
    else
        echo "I2C tools exists: PASSED"
    fi

    echo "checking if PCI utils exists..."
    local have_pciutils1=`which setpci`
    local have_pciutils2=`which lspci`
    if [[ "$have_pciutils1" == "" || \
          "$have_pciutils2" == "" ]]; then
        echo "*** error: please install pciutils. Ubuntu: apt-get install pciutils, Fedora: yum install pciutils"
        prerequisites_result=2
    else
        echo "PCI utils exists: PASSED"
    fi

    # check if /usr/src/linux/ exists and if its a valid kernel src/header folder
    echo "checking if /usr/src/linux/ points to valid kernel headers..."
    find ${LIN_SRC_DIR}/include/ -name "autoconf.h" > /dev/null 2>&1
    local linux_src_link=$?
    if [ "${linux_src_link}" == "0" ]; then
        echo "/usr/src/linux/ points to valid kernel headers: PASSED"
    else
        echo "*** error: please set a symlink /usr/src/linux to the headers of your current running kernel:"
        echo "           e.g.   ln -s /usr/src/linux-headers.x.y.z /usr/src/linux"
        prerequisites_result=3
    fi
    echo "In case of warning: \"Cannot use CONFIG_STACK_VALIDATION=y\""
    echo "please install libelf-dev, libelf-devel or elfutils-libelf-devel"

    return ${prerequisites_result}
}

### @brief display question 'arg1' 
### @input: arg1 message to print
###       check for y/n/q
### @returns: 0="y"
###           1="n"
###           2="q"
get_ynq_answer() {
    while true
    do
        echo -e -n $1 '(y/n/q): '
        read answer
        case ${answer} in
        [Yy]) return 0;;
        [Nn]) return 1;;
        [Qq]) return 2;;
        esac
    done
}

### @brief Display question and obtain answer,
### @input: {1} - Question
###         {2} - Array of possible answers
### @returns: choosen index of array (starting from 0)
###
### Example use:
### readonly questionMsg="Would you like to select the default driver for this device? (y)
### Otherwise please choose the proper driver number"
###
### array=("one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten")
### displayQuestion "${questionMsg}" "${array[@]}"
### value=$?
### echo "Use driver idx: ${value}"
displayQuestion() {
    local question=${1}
    shift
    local arr=("$@")
    local argLimit=${#arr[@]}
    local i=0
    local arrIterator=0
    local answer
    question+="\n"

    for i in "${arr[@]}";
    do
        if [ ${arrIterator} -eq 0 ]; then
            question+="[y/0] ${i} - default\n"
        else
            question+="[${arrIterator}] ${i}\n"
        fi
        arrIterator=$((arrIterator+1))
    done

    if [ ${ASSUME_YES} -eq 0 ]; then
        echo -e "${question}"
        while true
        do
            read answer
            case ${answer} in
            [Yy]) return 0;;
            [Qq]) echo "*** Aborted by user."
                  exit 1;;
            *)    if [[ "${answer}" =~ ^[0][0-9]+$ ]] || ! [[ "${answer}" =~ ^[0-9]+$ ]]; then
                      echo -e "${question}"
                  else
                      if ((0<=answer && answer<argLimit)); then
                          return ${answer}
                      else
                          echo -e "${question}"
                      fi
                  fi;;
            esac
        done
    else
        return 0
    fi
}

### @brief display mcb mcb_pci blacklist warning
blacklist_warning_message() {
    # display warning if any F2xx/G2xx carrier is present in system
    readonly blacklist_warning="Starting with Linux kernel 3.15, the modules mcb and mcb_pci
must be blacklisted to avoid inconveniences which could led to a kernel panic.
Please refer to the MDIS User Manual 21md05-90.pdf for details."

    # if user choose 'n' or 'q' option, then Makefile is not generated
    readonly blacklist_warning_question="Would you like to proceed?"
    echo ""
    echo "${blacklist_warning}"
    if [ ${ASSUME_YES} -eq 0 ]; then
        get_ynq_answer "${blacklist_warning_question}"
        case $? in
        1 | 2)
            echo "*** Aborted by user."
            exit 1;
            ;;
        esac
    fi

}

############################################################################
############################################################################
## main
##

#set -x
echo "============================================================"
echo "MDIS System Scan - generate initial system.dsc / Makefile"
echo "============================================================"
echo

PCI_DRYTEST=""
BUILD_TOOLS=""
MEN_LIN_DIR=""
ASSUME_YES=0
INTERNAL_SWMODULES="0"

if [ $# -lt 1 ] || [ "${1}" = "--help" ] || [ "${1}" = "-h" ]; then
    scan_system_usage
    exit 1
fi

check_if_mdis_path $1
CmdResult=$?
if [ ${CmdResult} -eq 0 ]; then
    echo "$1 :is not path"
    exit 1
elif [ ${CmdResult} -eq 1 ]; then
    MEN_LIN_DIR=$1
    shift
else
    echo "$1 :invalid path"
    exit 1
fi  

# read parameters
while test $# -gt 0 ; do
    # This 'check_if_mdis_path' part is necessary to make scan_system.sh script  
    # compatible with  previous versions
    case "$1" in
        -h|--help)
                scan_system_usage
                exit 1
                ;;
        --buildtools)
                shift
                export BUILD_TOOLS="1"
                echo "Build mm_ident and fpga_load tool"
                ;;
        --mdiswiz|-y|--yes|--assume-yes)
                shift
                ASSUME_YES=1
                echo "Automatic yes to prompts; assume \"yes\" as answer"
                echo "to all prompts and run non-interactively"
                ;;
        --verbose)
                shift
                if test $# -gt 0; then
                        VERBOSE_PRINT=$1
                        echo "Verbose option: ${VERBOSE_PRINT}"
                else
                        echo "VERBOSE_PRINT unspecified"
                        exit 1
                fi
                shift
                ;;
        --drytest)
                shift
                if test $# -gt 0; then
                        PCI_DRYTEST=$1
                        echo "drytest option: ${PCI_DRYTEST}"
                else
                        echo "PCI_DRYTEST unspecified"
                        exit 1
                fi
                shift
                ;;
        --prerequisites)
                shift
                check_scan_system_prerequisites
                exit 1
                ;;
        --internal-swmodules)
                shift
                INTERNAL_SWMODULES="1"
                echo "Internal sw modules will also be added"
                ;;
        *)
                echo "No valid parameters"
                break
                ;;
        esac
done

if [ ${UID} != 0 ]; then
    echo "*** error: only root can run this script"
    echo "*** if you are running this script via mdiswiz, please run mdiswiz as root" 
    exit 1
fi

DSC_TPL_DIR=${MEN_LIN_DIR}/BUILD/MDIS/TPL/DSC
debug_print "MEN_LIN_DIR = ${MEN_LIN_DIR}"

##
# prerequisites
#
check_scan_system_prerequisites
CmdResult=$?
if [ "${CmdResult}" != "0" ]; then
    echo "*** error: prerequisites are not met, see help"
    exit 1
fi

if [[ -e "$DSC_FILE" && $SCAN_SIM == 0 ]]; then
    echo "backing up system.dsc..."
    mv $DSC_FILE $DSC_FILE.bak
fi
if [[ -e "$MAKE_FILE" && $SCAN_SIM == 0 ]]; then
    echo "backing up Makefile..."
    mv $MAKE_FILE $MAKE_FILE.bak
fi


if [ "$PCI_DRYTEST" == "" ]; then
    # write PCI devices into tmp file for further analysis
    if [[ -e $TMP_PCIDEVS && $SCAN_SIM == 0 ]]; then
        rm $TMP_PCIDEVS
    fi
    if [ $SCAN_SIM == 0 ]; then
    $MEN_LIN_DIR/BIN/$FPGA_LOAD -s > $TMP_PCIDEVS
    count_f205_boards
    fi

else
    echo "PCI_DRYTEST set, using file $PCI_DRYTEST."
    TMP_PCIDEVS=$PCI_DRYTEST
fi

# check target architecture, for non -x86 target system rebuild tools:
# fpga_load, mm_ident tool
CPU_ARCHITECTURE=$(arch | grep "86")
if [ "${BUILD_TOOLS}" == "1" ] || [ "${CPU_ARCHITECTURE}" == "" ]; then
    compile_mm_ident
    CmdResult=$?
    echo "compile_mm_ident=${CmdResult}"

    if [ "${CmdResult}" == "0" ]; then
        # Rewrite mm_ident binary in MDIS installed sources
        cp ${MEN_LIN_DIR}TOOLS/mm_ident/mm_ident ${MEN_LIN_DIR}BIN/mm_ident
        echo "mm_ident tool copied into ${MEN_LIN_DIR}BIN/"
    fi

    compile_fpga_tools
    CmdResult=$?
    echo "compile_fpga_tools=${CmdResult}"
    if [ "${CmdResult}" == "0" ]; then
        # Rewrite mm_ident binary in MDIS installed sources
        cp ${MEN_LIN_DIR}TOOLS/FPGA_LOAD/fpga_load ${MEN_LIN_DIR}BIN/fpga_load
        echo "fpga_load tool copied into ${MEN_LIN_DIR}BIN/"
    fi
fi

# all ok, let the games begin...
# check on which CPU we are running

detect_board_id

G_SmBusNumber=$smbus
main_cpu=`echo $G_cpu | awk '{print substr($1,1,4)}'`
wiz_model_cpu=""
echo "Found CPU: $main_cpu. Using SMB address $G_SmBusNumber for SMB2 based drivers"
#default for most F1x cards
wiz_model_busif=1
bCreateXm01bcDrv=0
bCreateF14bcDrv=0
bCreateSmb2GenericDrv=0

COMMIT_ID=$(cat ${MEN_LIN_DIR}/HISTORY/13MD05-90_version.txt)
DATE=$(LANG=en_us_88591; date)
# Add cretion note into system.dsc file
echo "# ${CREATION_NOTE}\n# ${COMMIT_ID}\n# ${DATE}\n" > $DSC_FILE

#unfortunately some F-cards seem to be have IDs with and without '0' (marketing name)
case $main_cpu in
    SC24)
        wiz_model_cpu=Bx50x
        wiz_model_smb=SMBPCI_FCH
        ;;
    SC25)
        wiz_model_cpu=Bx70x
        wiz_model_smb=SMBPCI_FCH
        ;;
    SC31)    
        wiz_model_cpu=Bx51x
        wiz_model_smb=SMBPCI_FCH
        ;;
    F011)
        wiz_model_cpu=F11S
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x3c
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    F11S)
        wiz_model_cpu=F11S
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x3c
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    F14|F014)
        wiz_model_cpu=F14
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        add_xm01bc_support
        ;;
    F15)
        wiz_model_cpu=F15
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        add_xm01bc_support
        ;;
    F015)
        wiz_model_cpu=F15
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        add_xm01bc_support
        ;;
    F17|F017)
        wiz_model_cpu=F17
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateF14bcDrv=1
        add_f14bc_support
        ;;
    F19P|F19C|F019)
        wiz_model_cpu=F19P_F19C
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    F21P|F21C|F021)
        wiz_model_cpu=F21P_F21C
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        wiz_model_busif=0
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    F026)
        wiz_model_cpu=F26L
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        wiz_model_busif=0
        bCreateXm01bcDrv=1
                bCreateSmb2GenericDrv=1
        add_xm01bc_support
                add_smb2_generic_support
        ;;
    F022|F22P)
        wiz_model_cpu=F22P
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1e
        wiz_model_busif=0
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    F023|F23P)
        wiz_model_cpu=F23P
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=0
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
                add_smb2_generic_support
        ;;
    F075|F75P)
        wiz_model_cpu=F75P
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x18
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    XM01)
        wiz_model_cpu=XM1
        wiz_model_smb=SMBPCI_SCH
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    MM01)
        wiz_model_cpu=MM1
        wiz_model_smb=SMBPCI_SCH
        G_primPciPath=0x1c
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_smb2_generic_support
        ;;
    G20-)
        wiz_model_cpu=G20
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        add_z001_io_support
        bCreateXm01bcDrv=1
        ;;
    G22-|G022)
        wiz_model_cpu=G22
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        bCreateSmb2GenericDrv=1
        bCreateXm01bcDrv=1
        add_xm01bc_support
        add_z001_io_support
        add_smb2_generic_support
        ;;
    G23-|G023)
        wiz_model_cpu=G23
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_z001_io_support
        add_smb2_generic_support
        ;;

    G25-|G25A|G025)
        wiz_model_cpu=G25A
        wiz_model_smb=SMBPCI_ICH
        G_primPciPath=0x1c
        wiz_model_busif=7
        bCreateXm01bcDrv=1
        bCreateSmb2GenericDrv=1
        add_xm01bc_support
        add_z001_io_support
        add_smb2_generic_support
        ;;
    *)
        echo "No MEN CPU type found!"
        ;;
esac

debug_print "Using _WIZ_MODEL = $wiz_model_cpu"

# create SC24 based Bx50x CPU model
if [ "$main_cpu" == "SC24" ]; then
    map_sc24_fpga
    cat $DSC_TPL_DIR/sc24.tpl | sed "s/SCAN_WIZ_MODEL/$wiz_model_cpu/g; s/SCAN_SMBNR1/`printf \"0x%x\" $((G_SmBusNumber - 1))`/g; s/SCAN_SMBNR2/`printf \"0x%x\" $G_SmBusNumber`/g;" >> $DSC_FILE
    blacklist_warning_message
    cat $DSC_TPL_DIR/Makefile.sc24.tpl >> $MAKE_FILE
# create SC25 based Bx70x CPU model - no FPGA mapping necessary here
elif  [ "$main_cpu" == "SC25" ]; then 
    cat $DSC_TPL_DIR/sc25.tpl | sed "s/SCAN_WIZ_MODEL/$wiz_model_cpu/g;" >> $DSC_FILE
    blacklist_warning_message
    cat $DSC_TPL_DIR/Makefile.sc24.tpl >> $MAKE_FILE
elif  [ "$main_cpu" == "SC31" ]; then 
    cat $DSC_TPL_DIR/sc31.tpl | sed "s/SCAN_WIZ_MODEL/$wiz_model_cpu/g; s/SCAN_SMB_BUS_NR/`printf \"0x%x\" $G_SmBusNumber`/g;" >> $DSC_FILE
    blacklist_warning_message
    cat $DSC_TPL_DIR/Makefile.sc31.tpl >> $MAKE_FILE
else
    #all other CPUs: detect PCI boards, start with CPU/SMB drivers
    create_entry_dsc_cpu_type $DSC_TPL_DIR $wiz_model_cpu
    create_entry_dsc_smb_type $DSC_TPL_DIR $G_SmBusNumber $wiz_model_smb $wiz_model_busif
    if [ "$bCreateSmb2GenericDrv" == "1" ]; then
        create_entry_dsc_smb_drv  $DSC_TPL_DIR $G_SmBusNumber smb2_1 SMB2 SMB2 $G_SmbDeviceSlotNumber
        add_device_smb_scan_list $DSC_TPL_DIR $G_SmbDeviceSlotNumber smb2_1
        G_SmbDeviceSlotNumber=$((G_SmbDeviceSlotNumber+1))
    fi 
    if [ "$bCreateXm01bcDrv" == "1" ]; then
    create_entry_dsc_smb_drv  $DSC_TPL_DIR $G_SmBusNumber xm01bc_1 XM01BC XM01BC $G_SmbDeviceSlotNumber
    add_device_smb_scan_list $DSC_TPL_DIR $G_SmbDeviceSlotNumber xm01bc_1
    G_SmbDeviceSlotNumber=$((G_SmbDeviceSlotNumber+1))
    fi
    if [ "$bCreateF14bcDrv" == "1" ]; then
    create_entry_dsc_smb_drv  $DSC_TPL_DIR $G_SmBusNumber f14bc_1 F14BC F14BC $G_SmbDeviceSlotNumber
        add_device_smb_scan_list $DSC_TPL_DIR $G_SmbDeviceSlotNumber f14bc_1
        G_SmbDeviceSlotNumber=$((G_SmbDeviceSlotNumber+1))
    fi
    #insert all smb drv scan list into smb2_1 device
    fill_entry_dsc_smb_scan_list 

    # add the SMB2 userland API too
    G_makefileUsrLibs+=" SMB2_API/COM/library.mak"
    echo "Check if all required memory regions are enabled"
    enable_memory_regions
    echo "Scanning for MEN PCI devices: "
    scan_for_pci_devs $G_primPciPath
    # display mcb blacklist warning if fpga is in use 
    if [ ! "${count_instance_f2xx}" == "0" ]; then
        blacklist_warning_message
    fi
    # dsc section build done, now create the Makefile
    create_makefile
fi

# remove unnecessary fields from dsc file
sed -i ':a;N;$!ba;s/#SCAN_NEXT_DEVID\n//g' $DSC_FILE

echo "finished."
