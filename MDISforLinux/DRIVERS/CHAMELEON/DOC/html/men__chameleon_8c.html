<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - Chameleon System Unit Driver - men_chameleon.c File Reference</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;">
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Chameleon System Unit Driver &nbsp; </h1>
	<h3>men_chameleon.c File Reference</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>men_chameleon.c File Reference</h1>MEN Chameleon FPGA driver/device registration.  
<a href="#_details">More...</a>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structCHAM__IPCORE__SYSFS__T.html">CHAM_IPCORE_SYSFS_T</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">data structure providing sysfs entries for one IP core within the table </em> <a href="structCHAM__IPCORE__SYSFS__T.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structCHAMELEON__HANDLE__T.html">CHAMELEON_HANDLE_T</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">data structure that handles one instance of a chameleon FPGA </em> <a href="structCHAMELEON__HANDLE__T.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="men_chameleon.c::NR_CHAM_TBL_ATTRS"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a9">NR_CHAM_TBL_ATTRS</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sysfs files per table: fpgafile,model,revision,magic <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="men_chameleon.c::NR_CHAM_IPCORE_ATTRS"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a10">NR_CHAM_IPCORE_ATTRS</a>&nbsp;&nbsp;&nbsp;10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sysfs files per IP core: (Unit),devId,Grp,Rev,Var,Inst,IRQ,BAR,Offset,Addr (Unit is derived from devID) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="men_chameleon.c::CHAM_SYSFS_MODE"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a11">CHAM_SYSFS_MODE</a>&nbsp;&nbsp;&nbsp;0644</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sysfs attributs access mode <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="men_chameleon.c::CHAM_TBL_DFLT_LEN"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a12">CHAM_TBL_DFLT_LEN</a>&nbsp;&nbsp;&nbsp;24</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sysfs attribute default string length <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a13" doxytag="men_chameleon.c::CHAM_TBL_UNIT_LEN"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a13">CHAM_TBL_UNIT_LEN</a>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">string length for IP core Unit names <br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a40" doxytag="men_chameleon.c::LIST_HEAD"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a40">LIST_HEAD</a> (G_chamLst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of chameleon FPGAs <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a41" doxytag="men_chameleon.c::LIST_HEAD"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a41">LIST_HEAD</a> (G_drvLst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of registered drivers <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a42" doxytag="men_chameleon.c::LIST_HEAD"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a42">LIST_HEAD</a> (G_drvV2Lst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of registered V2 drivers <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a46">chameleon_announce</a> (<a class="el" href="structCHAMELEON__UNIT__T.html">CHAMELEON_UNIT_T</a> *unit, <a class="el" href="structCHAMELEON__DRIVER__T.html">CHAMELEON_DRIVER_T</a> *drv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Probes driver if it can handle the new unit. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a47">chameleonV2_announce</a> (<a class="el" href="structCHAMELEONV2__UNIT__T.html">CHAMELEONV2_UNIT_T</a> *unit, <a class="el" href="structCHAMELEONV2__DRIVER__T.html">CHAMELEONV2_DRIVER_T</a> *drv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Probes driver if it can handle the new unit. </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a48" doxytag="men_chameleon.c::chameleon_announce_fpga"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a48">chameleon_announce_fpga</a> (<a class="el" href="structCHAMELEON__HANDLE__T.html">CHAMELEON_HANDLE_T</a> *h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">probes all units of new FPGA against all registered drivers <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a49">men_chameleon_register_driver</a> (<a class="el" href="structCHAMELEON__DRIVER__T.html">CHAMELEON_DRIVER_T</a> *drv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">register a new chameleon driver </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a50">men_chameleonV2_register_driver</a> (<a class="el" href="structCHAMELEONV2__DRIVER__T.html">CHAMELEONV2_DRIVER_T</a> *drv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">register a new chameleon V2 driver </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a51">men_chameleon_unregister_driver</a> (<a class="el" href="structCHAMELEON__DRIVER__T.html">CHAMELEON_DRIVER_T</a> *drv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unregister a chameleon driver </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a52">men_chameleonV2_unregister_driver</a> (<a class="el" href="structCHAMELEONV2__DRIVER__T.html">CHAMELEONV2_DRIVER_T</a> *drv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unregister a chameleon V2 driver </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a53">men_chameleon_unit_find</a> (int modCode, int idx, <a class="el" href="structCHAMELEON__UNIT__T.html">CHAMELEON_UNIT_T</a> *unit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the system wide nth occurrance of a chameleon module <em>modCode</em>. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a54">men_chameleonV2_unit_find</a> (int devId, int idx, <a class="el" href="structCHAMELEONV2__UNIT__T.html">CHAMELEONV2_UNIT_T</a> *unit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the system wide nth occurrance of a chameleon module <em>devId</em>. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ssize_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a55">cham_sysfs_read</a> (struct kobject *kobj, struct kobj_attribute *attr, char *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sysfs read function (writing is not supported) </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int __devinit&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a56">pci_init_one</a> (struct pci_dev *pdev, const struct pci_device_id *ent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Probe/initialize Chameleon FPGA. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a17" doxytag="men_chameleon.c::debug"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a17">debug</a> = DEBUG_DEFAULT</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enable debug printouts <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a18" doxytag="men_chameleon.c::G_chamInit"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a18">G_chamInit</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">men_chameleon_init was called <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a19" doxytag="men_chameleon.c::G_chamFctTable"></a>
<a class="el" href="structCHAM__FUNCTBL.html">CHAM_FUNCTBL</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a19">G_chamFctTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chameleon function table. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a20" doxytag="men_chameleon.c::G_cham_devs"></a>
device *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a20">G_cham_devs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">base node for sysfs entries <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a21" doxytag="men_chameleon.c::G_tblIdx"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="men__chameleon_8c.html#a21">G_tblIdx</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">index of chameleon table <br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
MEN Chameleon FPGA driver/device registration. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>kp/ub/ts <dl compact><dt><b>Date</b></dt><dd>2013/08/29 16:49:09 </dd></dl>
<dl compact><dt><b>Revision</b></dt><dd>1.34 </dd></dl>
</dd></dl>
<p>
Derived from <a class="el" href="men__chameleon_8c.html">men_chameleon.c</a> contained in EM04A Linux BSP by Klaus Popp.<p>
Registers each chameleon FPGA found to the PCI subsystem. Provides a driver registration/probe interface similar to the PCI subsystem.<p>
Module parameters: usePciIrq : if 1, use the IRQ from the PCI config table for all devices in the FPGA - default if 0 use the IRQ from the Chameleon table. Can be different for every device. Currently makes sense with EM04/A only.<p>
Switches: MEN_CHAMV2_IRQ_OFFSET - needed for onboard chameleon FPGAs with IRQs connected to external CPU IRQs instead of PCI interrupt.<hr><h2>Function Documentation</h2>
<a name="a55" doxytag="men_chameleon.c::cham_sysfs_read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ssize_t cham_sysfs_read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct kobject *&nbsp;</td>
          <td class="mdname" nowrap> <em>kobj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct kobj_attribute *&nbsp;</td>
          <td class="mdname" nowrap> <em>attr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
sysfs read function (writing is not supported) 
<p>
The common sysfs show function searches the list of found chameleon tables and each IP core present in each table. When the matching kobj pointer is found, it's requested attribute files data is returned. the kobj argument can either be one of the 10 per-IP-core attributes or one of the 4 per-cham-table attributes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>kobj</em>&nbsp;</td><td>kobject of sysfs parent entry (=IP core) </td></tr>
    <tr><td valign=top><em>attr</em>&nbsp;</td><td>kobj_attribute (= &amp;ip-&gt;attr_ip[0-9]), the requested sysfs file per IP core) </td></tr>
    <tr><td valign=top><em>buf</em>&nbsp;</td><td>pointer to which data are to be written </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td># of bytes to return</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd># of written bytes or error code (negative number). </dd></dl>
    </td>
  </tr>
</table>
<a name="a46" doxytag="men_chameleon.c::chameleon_announce"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int chameleon_announce </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structCHAMELEON__UNIT__T.html">CHAMELEON_UNIT_T</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>unit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structCHAMELEON__DRIVER__T.html">CHAMELEON_DRIVER_T</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>drv</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Probes driver if it can handle the new unit. 
<p>
<ul>
<li>does nothing if the unit has already a driver attached</li><li>checks if the unit's module code is to be handled by <em>drv</em> </li><li>if so, calls the driver's probe function</li><li>on success, assigns the driver to the unit</li></ul>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>1 if <em>drv</em> assigned to unit, 0 if not </dd></dl>
    </td>
  </tr>
</table>
<a name="a47" doxytag="men_chameleon.c::chameleonV2_announce"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int chameleonV2_announce </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structCHAMELEONV2__UNIT__T.html">CHAMELEONV2_UNIT_T</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>unit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structCHAMELEONV2__DRIVER__T.html">CHAMELEONV2_DRIVER_T</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>drv</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Probes driver if it can handle the new unit. 
<p>
<ul>
<li>does nothing if the unit has already a driver attached</li><li>checks if the unit's module code is to be handled by <em>drv</em> </li><li>if so, calls the driver's probe function</li><li>on success, assigns the driver to the unit</li></ul>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>1 if <em>drv</em> assigned to unit, 0 if not </dd></dl>
    </td>
  </tr>
</table>
<a name="a49" doxytag="men_chameleon.c::men_chameleon_register_driver"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int men_chameleon_register_driver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structCHAMELEON__DRIVER__T.html">CHAMELEON_DRIVER_T</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>drv</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
register a new chameleon driver 
<p>
Adds the driver structure to the list of registered drivers. Immediately checks if any known FPGA unit can be handled by the new driver and calls it probe() function if so.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>drv</em>&nbsp;</td><td><b>IN</b> the driver structure to register. Must be kept intact by caller.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of chameleon units which were claimed by the driver during registration. The driver remains registered even if the return value is zero. </dd></dl>
    </td>
  </tr>
</table>
<a name="a53" doxytag="men_chameleon.c::men_chameleon_unit_find"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int men_chameleon_unit_find </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>modCode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structCHAMELEON__UNIT__T.html">CHAMELEON_UNIT_T</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>unit</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the system wide nth occurrance of a chameleon module <em>modCode</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>modCode</em>&nbsp;</td><td><b>IN</b> module code to search </td></tr>
    <tr><td valign=top><em>idx</em>&nbsp;</td><td><b>IN</b> nth occurance of module (system wide!) </td></tr>
    <tr><td valign=top><em>unit</em>&nbsp;</td><td><b>OUT</b> filled with unit information </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative linux error number </dd></dl>
    </td>
  </tr>
</table>
<a name="a51" doxytag="men_chameleon.c::men_chameleon_unregister_driver"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void men_chameleon_unregister_driver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structCHAMELEON__DRIVER__T.html">CHAMELEON_DRIVER_T</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>drv</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
unregister a chameleon driver 
<p>
Deletes the driver structure from the list of registered chameleon drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>drv</em>&nbsp;</td><td><b>IN</b> the driver structure to register. Must be kept intact by caller. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a50" doxytag="men_chameleon.c::men_chameleonV2_register_driver"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int men_chameleonV2_register_driver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structCHAMELEONV2__DRIVER__T.html">CHAMELEONV2_DRIVER_T</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>drv</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
register a new chameleon V2 driver 
<p>
Adds the driver structure to the list of registered drivers. Immediately checks if any known FPGA unit can be handled by the new driver and calls it probe() function if so.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>drv</em>&nbsp;</td><td><b>IN</b> the driver structure to register. Must be kept intact by caller.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of chameleon units which were claimed by the driver during registration. The driver remains registered even if the return value is zero. </dd></dl>
    </td>
  </tr>
</table>
<a name="a54" doxytag="men_chameleon.c::men_chameleonV2_unit_find"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int men_chameleonV2_unit_find </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>devId</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structCHAMELEONV2__UNIT__T.html">CHAMELEONV2_UNIT_T</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>unit</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the system wide nth occurrance of a chameleon module <em>devId</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>devId</em>&nbsp;</td><td><b>IN</b> device id to search </td></tr>
    <tr><td valign=top><em>idx</em>&nbsp;</td><td><b>IN</b> nth occurance of module (system wide!) </td></tr>
    <tr><td valign=top><em>unit</em>&nbsp;</td><td><b>OUT</b> filled with unit information </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative linux error number </dd></dl>
    </td>
  </tr>
</table>
<a name="a52" doxytag="men_chameleon.c::men_chameleonV2_unregister_driver"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void men_chameleonV2_unregister_driver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structCHAMELEONV2__DRIVER__T.html">CHAMELEONV2_DRIVER_T</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>drv</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
unregister a chameleon V2 driver 
<p>
Deletes the driver structure from the list of registered chameleon drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>drv</em>&nbsp;</td><td><b>IN</b> the driver structure to register. Must be kept intact by caller. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a56" doxytag="men_chameleon.c::pci_init_one"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int __devinit pci_init_one </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct pci_dev *&nbsp;</td>
          <td class="mdname" nowrap> <em>pdev</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const struct pci_device_id *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Probe/initialize Chameleon FPGA. 
<p>
Gets called (during execution of pci_register_driver for already existing devices or later if a new device gets inserted) for all PCI devices which match the ID table and are not handled by the other drivers yet. This function gets passed a pointer to the pci_dev structure representing the device and also which entry in the ID table did the device match. It returns zero when the driver has accepted the device or an error code (negative number) otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pdev</em>&nbsp;</td><td>pci_dev structure representing the device </td></tr>
    <tr><td valign=top><em>ent</em>&nbsp;</td><td>entry in PCI table that matches</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 when the driver has accepted the device or an error code (negative number) otherwise. </dd></dl>
    </td>
  </tr>
</table>

	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for Chameleon System Unit Driver using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2019 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

